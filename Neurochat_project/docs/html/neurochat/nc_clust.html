<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>neurochat.nc_clust API documentation</title>
<meta name="description" content="This module implements NClust Class for NeuroChaT software â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neurochat.nc_clust</code></h1>
</header>
<section id="section-intro">
<p>This module implements NClust Class for NeuroChaT software</p>
<p>@author: Md Nurul Islam; islammn at tcd dot ie</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module implements NClust Class for NeuroChaT software

@author: Md Nurul Islam; islammn at tcd dot ie
&#34;&#34;&#34;
import logging

import numpy as np

from neurochat.nc_base import NBase
from neurochat.nc_spike import NSpike

from neurochat.nc_utils import bhatt, find, hellinger

import scipy as sc
from sklearn.decomposition import PCA


class NClust(NBase):
    &#34;&#34;&#34;
    This class facilitates clustering-related operations. Although no clustering
    algorithm is implemented in this class, it can be subclassed to create such
    algorithms.
    
    &#34;&#34;&#34;
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Attributes
        ----------
        spike : NSpike
            An object of NSpike() class or its subclass
            
        &#34;&#34;&#34;
        
        spike = kwargs.get(&#39;spike&#39;, None)
        self.wavetime = []
        self.UPSAMPLED = False
        self.ALLIGNED = False
        self.NULL_CHAN_REMOVED = False

        if isinstance(spike, NSpike):
            self.spike = spike
        else:
            self.spike = NSpike(**kwargs)
        super().__init__(**kwargs)

    def get_unit_tags(self):
        &#34;&#34;&#34;
        Returns tags of the spiking waveforms from clustering
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        return self.spike.get_unit_tags()

    def set_unit_tags(self, new_tags=None):
        &#34;&#34;&#34;
        Returns tags of the spiking waveforms from clustering
        
        Parameters
        ----------
        new_tags : ndarray
            Array that contains the tags for spike-waveforms based on the cluster number
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        self.spike.set_unit_tags(new_tags)

    def get_unit_list(self):
        &#34;&#34;&#34;
        Returns the list of units in a spike dataset
        
        Parameters
        ----------
        None
        
        Returns
        -------
        list
            List of units
        
        &#34;&#34;&#34;
        
        return self.spike.get_unit_list()

    def _set_unit_list(self):
        &#34;&#34;&#34;
        Sets the unit list
        
        Delegetaes to NSpike._set_unit_list()
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        See also
        --------
        nc_spike.NSPike()._set_unit_list
        
        &#34;&#34;&#34;
        
        self.spike._set_unit_list()

    def get_timestamp(self, unit_no=None):    
        &#34;&#34;&#34;
        Returns the timestamps of the spike-waveforms of specified unit
        
        Parameters
        ----------
        unit_no : int
            Unit whose timestamps are to be returned
        
        Returns
        -------
        ndarray
            Timestamps of the spiking waveforms
            
        &#34;&#34;&#34;
        
        self.spike.get_timestamp(unit_no=unit_no)

    def get_unit_spikes_count(self, unit_no=None):
        &#34;&#34;&#34;
        Returns the total number of spikes in a specified unit
        
        Parameters
        ----------
        unit_no : int
            Unit whose count is returned
        
        Returns
        -------
        int
            Total number of spikes in the unit
        
        &#34;&#34;&#34;
            
        return self.spike.get_unit_spikes_count(unit_no=unit_no)

    def get_waveform(self):
        &#34;&#34;&#34;
        Returns the waveforms in the spike dataset
        
        Parameters
        ----------
        None        

        Returns
        -------
        dict
            Each key represents one channel of the electrode group, each value
            represents the waveforms of the spikes in a matrix form (no_samples x no_spikes)
        
        &#34;&#34;&#34; 
        return self.spike.get_waveform()

    def _set_waveform(self, spike_waves=[]):
        &#34;&#34;&#34;
        Sets the waveforms of the spike dataset
        
        Parameters
        ----------
        spike_waves : dict
            Spike waveforms
        
        Returns
        -------
        None        
        
        &#34;&#34;&#34;
        self.spike._set_waveform(spike_waves=spike_waves)

    def get_unit_waves(self, unit_no=None):
        &#34;&#34;&#34;
        Returns spike waveforms of a specific unit
        
        Parameters
        ----------
        unit_no : int
            Unit whose waveforms are returned
        
        Returns
        -------
        dict
            Spike wavefoorms in each channel of the electrode group 
        
        &#34;&#34;&#34;
        return self.spike.get_unit_waves(unit_no=unit_no)

    # For multi-unit analysis, {&#39;SpikeName&#39;: cell_no} pairs should be used as function input

    def load(self, filename=None, system=None):
        &#34;&#34;&#34;
        Loads spike dataset from the file
        
        Parameters
        ----------
        filename: str
            Name of the spike file
        
        Returns
        -------
        system
            Data format or recording system
        
        &#34;&#34;&#34;
        self.spike.load(filename=filename, system=system)

    def add_spike(self, spike=None, **kwargs):
        &#34;&#34;&#34;
        Adds new spike node to current NSpike() object
        
        Parameters
        ----------
        spike : NSpike
            NSPike object. If None, new object is created
        
        Returns
        -------
        `:obj:NSpike`
            A new NSpike() object

        &#34;&#34;&#34;
        
        return self.spike.add_spike(spike=spike, **kwargs)

    def load_spike(self, names=None):
        &#34;&#34;&#34;
        Loads datasets of the spike nodes. Name of each node is used for obtaining the
        filenames.
        
        Parameters
        ----------
        names : list of str
            Names of the nodes to load. If None, current NSpike() object is loaded
        
        Returns
        -------
        None

        &#34;&#34;&#34;
        self.spike.load_spike(names=names)

    def wave_property(self):
        &#34;&#34;&#34;
        Claulates different waveform properties for currently set unit
        
        Delegates to NSpike().wave_property()
        
        Parameters
        ----------
        None
 
        Returns
        -------
        dict
            Graphical data of the analysis
        
        See also
        --------
        NSpike().wave_property()

        &#34;&#34;&#34;
        
        return self.spike.wave_property()

    def isi(self, bins=&#39;auto&#39;, bound=None, density=False):
        &#34;&#34;&#34;
        Calulates the ISI histogram of the spike train
        
        Delegates to NSpike().isi()
        
        Parameters
        ----------
        bins : str or int
            Number of ISI histogram bins. If &#39;auto&#39;, NumPy default is used
            
        bound : int
            Length of the ISI histogram in msec
        density : bool
            If true, normalized historagm is calcultaed
 
        Returns
        -------
        dict
            Graphical data of the analysis
        
        See also
        --------
        NSpike().isi()
    
        &#34;&#34;&#34;
        
        return self.spike.isi(bins=bins, bound=bound, density=density)

    def isi_corr(self, **kwargs):
        &#34;&#34;&#34;
        Analysis of ISI autocrrelation histogram
        
        Delegates to NSpike().isi_auto_corr()
        
        Parameters
        ----------            
        **kwargs
            Keyword arguments
 
        Returns
        -------
        dict
            Graphical data of the analysis
    
        See also
        --------
        nc_spike.NSpike().isi_corr

        &#34;&#34;&#34;
        
        return self.spike.isi_corr(**kwargs)

    def psth(self, event_stamp, **kwargs):
        &#34;&#34;&#34;
        Calculates peri-stimulus time histogram (PSTH)
        
        Delegates to NSpike().psth()
        
        Parameters
        ----------
        event_stamp : ndarray
            Event timestamps
            
        **kwargs
            Keyword arguments
 
        Returns
        -------
        dict
            Graphical data of the analysis
            
        See also
        --------
        NSpike().psth()
    
        &#34;&#34;&#34;
        
        return self.spike.psth(event_stamp, **kwargs)

    def burst(self, burst_thresh=5, ibi_thresh=50):
        &#34;&#34;&#34;
        Burst analysis of spik-train
        
        Delegates to NSpike().burst()
        
        Parameters
        ----------
        burst_thresh : int
            Minimum ISI between consecutive spikes in a burst
            
        ibi_thresh : int
            Minimum inter-burst interval between two bursting groups of spikes
 
        Returns
        -------
        None
    
        See also
        --------
        nc_spike.NSpike().burst

        &#34;&#34;&#34;
        
        self.spike.burst(burst_thresh=burst_thresh, ibi_thresh=ibi_thresh)

    def get_total_spikes(self):
        &#34;&#34;&#34;
        Returns total number of spikes in the recording
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Total number of spikes

        &#34;&#34;&#34;
        
        return self.spike.get_total_spikes()

    def get_total_channels(self):
        &#34;&#34;&#34;
        Returns total number of electrode channels in the spike data file
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Total number of electrode channels

        &#34;&#34;&#34;
        
        return self.spike.get_total_channels()

    def get_channel_ids(self):
        &#34;&#34;&#34;
        Returns the identities of individual channels
                
        Parameters
        ----------
        None
 
        Returns
        -------
        list
            Identities of individual channels 

        &#34;&#34;&#34;
        
        return self.spike.get_channel_ids()

    def get_timebase(self):
        &#34;&#34;&#34;
        Returns the timebase for spike event timestamps
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Timebase for spike event timestamps

        &#34;&#34;&#34;
        
        return  self.spike.get_timebase()

    def get_sampling_rate(self):
        &#34;&#34;&#34;
        Returns the sampling rate of spike waveforms
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Sampling rate for spike waveforms

        &#34;&#34;&#34;
        
        return self.spike.get_sampling_rate()

    def get_samples_per_spike(self):
        &#34;&#34;&#34;
        Returns the number of bytes to represent each timestamp in the binary file
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Number of bytes to represent timestamps

        &#34;&#34;&#34;
        return self.spike.get_samples_per_spike()

    def get_wave_timestamp(self):
        &#34;&#34;&#34;
        Returns the temporal resolution to  represent samples of spike-waves.
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Number of bytes to represent timestamps

        &#34;&#34;&#34;
        
        # resturn as microsecond
        fs = self.spike.get_sampling_rate()/10**6 # fs downsampled so that the time is given in microsecond
        return 1/fs

    def save_to_hdf5(self):
        &#34;&#34;&#34;
        Stores NSpike() object to HDF5 file
        
        Delegates to NSPike().save_to_hdf5()
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        Also see
        --------
        nc_hdf.Nhdf().save_spike()
        
        &#34;&#34;&#34;
        
        self.spike.save_to_hdf5()

    def get_feat(self, npc = 2):
        &#34;&#34;&#34;
        Returns the spike-waveform features.
        
        Parameters
        ----------
        nc : int
            Number of principle components in each channel.
        
        Returns
        -------
        feat : ndarray
            Matrix of size (number_spike X number_features)
        
        &#34;&#34;&#34;
        
        if not self.NULL_CHAN_REMOVED:
            self.remove_null_chan()
        if not self.ALLIGNED:
            self.align_wave_peak()

        trough, trough_loc = self.get_min_wave_chan() # trough only in max_channel
        peak, peak_chan, peak_loc = self.get_max_wave_chan()
#        amp = np.abs(peak-trough)
        pc = self.get_wave_pc(npc=npc)
        shape = (self.get_total_spikes(), 1)
        feat = np.concatenate((peak.reshape(shape), trough.reshape(shape), pc), axis=1)

        return feat

        # for all units
    def get_feat_by_unit(self, unit_no = None):
        &#34;&#34;&#34;
        Returns the spike-waveform features for a paricular unit.
        
        Parameters
        ----------
        unit_no : int
            Unit of interest
        
        Returns
        -------
        feat : ndarray
            Matrix of size (number_spike X number_features)
        
        &#34;&#34;&#34;
        
        
        if unit_no in self.get_unit_list():
            feat = self.get_feat()
            return feat[self.get_unit_tags() == unit_no, :]
        else:
            logging.error(&#39;Specified unit does not exist in the spike dataset&#39;)
            
    def get_wave_peaks(self):
        &#34;&#34;&#34;
        Returns the peaks of the spike-waveforms.
        
        Parameters
        ----------
        None        

        Returns
        -------
        peak : ndarray
            Spike waveform peaks in all the electrode channels (num_waves X num_channels)
        peak_loc : ndarray
            Index of peak locations
        &#34;&#34;&#34;
        
        wave = self.get_waveform()
        peak = np.zeros((self.get_total_spikes(), len(wave.keys())))
        peak_loc = np.zeros((self.get_total_spikes(), len(wave.keys())), dtype=int)
        for i, key in enumerate(wave.keys()):
            peak[:, i] = np.amax(wave[key], axis=1)
            peak_loc[:, i] = np.argmax(wave[key], axis=1)

        return peak, peak_loc

    def get_max_wave_chan(self):
        &#34;&#34;&#34;
        Returns the maximum of waveform peaks among the electrode groups.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        max_wave_val : ndarray
            Maximum value of the peaks of the waveforms
        max_wave_chan : ndarray
            Channel of the electrode group where a spike waveform is strongest
        peak_loc : ndarray
            Peak location in the channel with strongest waveform
        
        &#34;&#34;&#34;
        
        # Peak value at the highest channel, the highest channel, and the index of the peak
        peak, peak_loc = self.get_wave_peaks()
        max_wave_chan = np.argmax(peak, axis=1)
        max_wave_val = np.amax(peak, axis=1)
        return max_wave_val, max_wave_chan, peak_loc[np.arange(len(peak_loc)), max_wave_chan]

    def align_wave_peak(self, reach=300, factor=2):
        &#34;&#34;&#34;
        Align the waves by their peaks.
        
        Parameters
        ----------
        reach : int
            Maximum allowed time-shift in microsecond
        factors : int
            Resampling factor
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        if not self.UPSAMPLED:
            self.resample_wave(factor=factor)
        if not self.ALLIGNED:
            shift = round(reach/self.get_wave_timestamp()) # maximum 300microsecond allowed for shift
            wave = self.get_waveform() # NC waves are stroed in waves[&#39;ch1&#39;], waves[&#39;ch2&#39;] etc. ways
            maxInd = shift + self.get_max_wave_chan()[2]
            shift_ind = int(np.median(maxInd)) - maxInd
            shift_ind[np.abs(shift_ind) &gt; shift] = 0
            stacked_chan = np.empty((self.get_total_spikes(), self.get_samples_per_spike(), self.get_total_channels()))
            keys = []
            i = 0
            for key, val in wave.items():
                stacked_chan[:, :, i] = val
                keys.append(key)
                i += 1

            stacked_chan = np.lib.pad(stacked_chan, [(0, 0), (shift, shift), (0, 0)], &#39;edge&#39;) # Shows error in Jupyter, check again

            stacked_chan = np.array([np.roll(stacked_chan[i, :, :], shift_ind[i], axis=0)[shift: shift+ self.get_samples_per_spike()] for i in np.arange(shift_ind.size)])

            for i, key in enumerate(keys):
                wave[key] = stacked_chan[:, :, i]
            self._set_waveform(wave)
            self.ALLIGNED = True

#        stacked_chan = np.roll(stacked_chan, tuple(shift_ind), axis=tuple(np.ones(shift_ind.size)))

    def get_wave_min(self):
        &#34;&#34;&#34;
        Returns the minimum values of the spike-waveforms.
        
        Parameters
        ----------
        None

        Returns
        -------
        min_w : ndarray
            Minimum value of the  wavefforms
        min_loc : ndarray
            Index of minimum value
            
        &#34;&#34;&#34;
        
        wave = self.get_waveform()
        min_w = np.zeros((self.get_total_spikes(), len(wave.keys())))
        min_loc = np.zeros((self.get_total_spikes(), len(wave.keys())))
        for i, key in enumerate(wave.keys()):
            min_w[:, i] = np.amin(wave[key], axis=1)
            min_loc[:, i] = np.argmin(wave[key], axis=1)

        return min_w, min_loc

    def get_min_wave_chan(self):
        &#34;&#34;&#34;
        Returns the maximum of waveform peaks among the electrode groups.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        ndarray
            Minimum value of the waveform at channels with maximum peak value
        ndarray
            Index of minimum values
        
        &#34;&#34;&#34;
        # Peak value at the highest channel, the highest channel, and the index of the peak
        max_wave_chan = self.get_max_wave_chan()[1]
        trough, trough_loc = self.get_wave_min()
        return trough[np.arange(len(max_wave_chan)), max_wave_chan], \
                trough_loc[np.arange(len(max_wave_chan)), max_wave_chan]
        # use get_max_channel to determine

    def get_wave_pc(self, npc=2):
        &#34;&#34;&#34;
        Returns the Principle Components of the waveforms
        
        Parameters
        ----------
        npc : int
            Number of principle components from waveforms of each channel
        
        Returns
        -------
        pc : ndarray
            Principle components (num_waves X npc*num_channels)        
        &#34;&#34;&#34;
        wave = self.get_waveform()
        pc = np.array([])
        for key, w in wave.items():
            pca = PCA(n_components=5)
            w_new = pca.fit_transform(w)
            pc_var = pca.explained_variance_ratio_

            if npc and npc &lt; w_new.shape[1]:
                w_new = w_new[:, :npc]
            else:
                w_new = w_new[:, 0:(find(np.cumsum(pc_var) &gt;= 0.95, 1, &#39;first&#39;)[0]+1)]
            if not len(pc):
                pc = w_new
            else:
                pc = np.append(pc, w_new, axis=1)
        return pc

    def get_wavetime(self):
        &#34;&#34;&#34;
        Returns the timestamps of the waveforms, not the spiking-event timestamp
        
        Parameters
        ----------
        None
        
        Returns
        -------
            Timestamps of the spike-waveforms
            
        &#34;&#34;&#34;
        
        # calculate the wavetime from the sampling rate and number of sample, returns in microsecond
        nsamp = self.spike.get_samples_per_spike()
        timestamp = self.get_wave_timestamp()
        return np.arange(0, (nsamp)*timestamp, timestamp)

    def resample_wavetime(self, factor=2):
        &#34;&#34;&#34;
        Resamples the timestamps of spike-waveforms
        
        Parameters
        ----------
        factor : int
            Resampling factor
        
        Returns
        -------
            Resampled timestamps
            
        &#34;&#34;&#34;
        
        wavetime = self.get_wavetime()
        timestamp = self.get_wave_timestamp()
        
        return np.arange(0, wavetime[-1], timestamp/factor)
        # return resampled time

    def resample_wave(self, factor=2):
        &#34;&#34;&#34;
        Resamples spike waveforms
        
        Parameters
        ----------
        factor : int
            Resampling factor
        
        Returns
        -------
        wave : dict
            Upsampled waveforms
        uptime  ndarray
            Upsampled wave timestamps
            
        &#34;&#34;&#34;
        # resample wave using spline interpolation using the resampled_time,return wave
        if not self.UPSAMPLED:
            wavetime = self.get_wavetime()
            uptime = self.resample_wavetime(factor=factor)
            wave = self.get_waveform()
            for key, w in wave.items():
                f = sc.interpolate.interp1d(wavetime, w, axis=1, kind=&#39;quadratic&#39;)
                wave[key] = f(uptime)

            self.spike._set_sampling_rate(self.get_sampling_rate()*factor)
            self.spike._set_samples_per_spike(uptime.size)
            self.UPSAMPLED = True
            
            return wave, uptime
        
        else:
            logging.warning(&#39;You can upsample only once. Please reload data from source file for changing sampling factor!&#39;)

    def get_wave_energy(self):
        &#34;&#34;&#34;
        Energy of the spike waveforms, measured as the summation of the square of samples
        
        Parameters
        ----------
        None
        
        Returns
        -------
        energy : ndarray
            Energy of spikes (num_spike X num_channels)
        &#34;&#34;&#34;
        wave = self.get_waveform()
        energy = np.zeros((self.get_total_spikes(), len(wave.keys())))
        for i, key in enumerate(wave.keys()):
            energy[:, i] = np.sum(np.square(wave[key]), 1)/10**6 # taken the enrgy in mV2
        return energy

    def get_max_energy_chan(self):
        &#34;&#34;&#34;
        Returns the maximum energy of the spike waveforms
        
        Parameters
        ----------
        None
        
        Returns
        -------
        ndarray
            Maximum energy of the spikes
        &#34;&#34;&#34;
        
        energy = self.get_wave_energy()
        return np.argmax(energy, axis=1)

    def remove_null_chan(self):
        &#34;&#34;&#34;
        Removes the channel from the electrode group that has no spike in it
        
        Parameters
        ----------
        None
        
        Returns
        -------
        off_chan : int
            Channel number that has been removed
            
        &#34;&#34;&#34;
        
        wave = self.get_waveform()
        off_chan = []
        for key, w in wave.items():
            if np.abs(w).sum() == 0:
                off_chan.append(key)
        if off_chan:
            for key in off_chan:
                del wave[key]
            self._set_waveform(wave)
            self.NULL_CHAN_REMOVED = True
        
        return off_chan
        # simply detect in which channel everything is zero, which means it&#39;s a reference channel or nothing is recorded here

    def cluster_separation(self, unit_no=0):
        &#34;&#34;&#34;
        Quantitatively measures the separation of a specific unit from other clusters
        
        Parameters
        ----------
        unit_no : int
            Unit of interest. If &#39;0&#39;, pairwise comparison of all units are returned
        
        Returns
        -------
        bc : ndarray
            Bhattacharyya coefficient
        dh : ndarray
            Hellinger distance
            
        &#34;&#34;&#34;
        
        # if unit_no==0 all units, matrix output for pairwise comparison,
        # else maximum BC for the specified unit
        feat = self.get_feat()
        unit_list = self.get_unit_list()
        n_units = len(unit_list)

        if unit_no == 0:
            bc = np.zeros([n_units, n_units])
            dh = np.zeros([n_units, n_units])
            for c1 in np.arange(n_units):
                for c2 in np.arange(n_units):
                    X1 = feat[self.get_unit_tags() == unit_list[c1], :]
                    X2 = feat[self.get_unit_tags() == unit_list[c2], :]
                    bc[c1, c2] = bhatt(X1, X2)[0]
                    dh[c1, c2] = hellinger(X1, X2)
                    unit_list = self.get_unit_list()
        else:
            bc = np.zeros(n_units)
            dh = np.zeros(n_units)
            X1 = feat[self.get_unit_tags() == unit_no, :]
            for c2 in np.arange(n_units):
                if c2 == unit_no:
                    bc[c2] = 0
                    dh[c2] = 1
                else:
                    X2 = feat[self.get_unit_tags() == unit_list[c2], :]
                    bc[c2] = bhatt(X1, X2)[0]
                    dh[c2] = hellinger(X1, X2)
                idx = find(np.array(unit_list) != unit_no)

            return bc[idx], dh[idx]

    def cluster_similarity(self, nclust=None, unit_1=None, unit_2=None):
        &#34;&#34;&#34;
        Quantitatively measures the similarity or distance of cluster of one unit
        in a spike dataset to cluster of another unit in another dataset
        
        Parameters
        ----------
        nclust : Nclust
            NClust object whose unit is under comparison
        unit_1 : int
            Unit of current Nclust object
        unit_2 : int
            Unit of another NClust object  under comparison
        
        Returns
        -------
        
        bc : ndarray
            Bhattacharyya coefficient
        dh : ndarray
            Hellinger distance
            
        &#34;&#34;&#34;
        
        if isinstance(nclust, NClust):
            if unit_1 in self.get_unit_list() and unit_2 in nclust.get_unit_list():
                X1 = self.get_feat_by_unit(unit_no=unit_1)
                X2 = nclust.get_feat_by_unit(unit_no=unit_2)
                bc = bhatt(X1, X2)[0]
                dh = hellinger(X1, X2)
        return bc, dh</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="neurochat.nc_clust.NClust"><code class="flex name class">
<span>class <span class="ident">NClust</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This class facilitates clustering-related operations. Although no clustering
algorithm is implemented in this class, it can be subclassed to create such
algorithms.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>spike</code></strong> :&ensp;<code>NSpike</code></dt>
<dd>An object of NSpike() class or its subclass</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NClust(NBase):
    &#34;&#34;&#34;
    This class facilitates clustering-related operations. Although no clustering
    algorithm is implemented in this class, it can be subclassed to create such
    algorithms.
    
    &#34;&#34;&#34;
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Attributes
        ----------
        spike : NSpike
            An object of NSpike() class or its subclass
            
        &#34;&#34;&#34;
        
        spike = kwargs.get(&#39;spike&#39;, None)
        self.wavetime = []
        self.UPSAMPLED = False
        self.ALLIGNED = False
        self.NULL_CHAN_REMOVED = False

        if isinstance(spike, NSpike):
            self.spike = spike
        else:
            self.spike = NSpike(**kwargs)
        super().__init__(**kwargs)

    def get_unit_tags(self):
        &#34;&#34;&#34;
        Returns tags of the spiking waveforms from clustering
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        return self.spike.get_unit_tags()

    def set_unit_tags(self, new_tags=None):
        &#34;&#34;&#34;
        Returns tags of the spiking waveforms from clustering
        
        Parameters
        ----------
        new_tags : ndarray
            Array that contains the tags for spike-waveforms based on the cluster number
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        self.spike.set_unit_tags(new_tags)

    def get_unit_list(self):
        &#34;&#34;&#34;
        Returns the list of units in a spike dataset
        
        Parameters
        ----------
        None
        
        Returns
        -------
        list
            List of units
        
        &#34;&#34;&#34;
        
        return self.spike.get_unit_list()

    def _set_unit_list(self):
        &#34;&#34;&#34;
        Sets the unit list
        
        Delegetaes to NSpike._set_unit_list()
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        See also
        --------
        nc_spike.NSPike()._set_unit_list
        
        &#34;&#34;&#34;
        
        self.spike._set_unit_list()

    def get_timestamp(self, unit_no=None):    
        &#34;&#34;&#34;
        Returns the timestamps of the spike-waveforms of specified unit
        
        Parameters
        ----------
        unit_no : int
            Unit whose timestamps are to be returned
        
        Returns
        -------
        ndarray
            Timestamps of the spiking waveforms
            
        &#34;&#34;&#34;
        
        self.spike.get_timestamp(unit_no=unit_no)

    def get_unit_spikes_count(self, unit_no=None):
        &#34;&#34;&#34;
        Returns the total number of spikes in a specified unit
        
        Parameters
        ----------
        unit_no : int
            Unit whose count is returned
        
        Returns
        -------
        int
            Total number of spikes in the unit
        
        &#34;&#34;&#34;
            
        return self.spike.get_unit_spikes_count(unit_no=unit_no)

    def get_waveform(self):
        &#34;&#34;&#34;
        Returns the waveforms in the spike dataset
        
        Parameters
        ----------
        None        

        Returns
        -------
        dict
            Each key represents one channel of the electrode group, each value
            represents the waveforms of the spikes in a matrix form (no_samples x no_spikes)
        
        &#34;&#34;&#34; 
        return self.spike.get_waveform()

    def _set_waveform(self, spike_waves=[]):
        &#34;&#34;&#34;
        Sets the waveforms of the spike dataset
        
        Parameters
        ----------
        spike_waves : dict
            Spike waveforms
        
        Returns
        -------
        None        
        
        &#34;&#34;&#34;
        self.spike._set_waveform(spike_waves=spike_waves)

    def get_unit_waves(self, unit_no=None):
        &#34;&#34;&#34;
        Returns spike waveforms of a specific unit
        
        Parameters
        ----------
        unit_no : int
            Unit whose waveforms are returned
        
        Returns
        -------
        dict
            Spike wavefoorms in each channel of the electrode group 
        
        &#34;&#34;&#34;
        return self.spike.get_unit_waves(unit_no=unit_no)

    # For multi-unit analysis, {&#39;SpikeName&#39;: cell_no} pairs should be used as function input

    def load(self, filename=None, system=None):
        &#34;&#34;&#34;
        Loads spike dataset from the file
        
        Parameters
        ----------
        filename: str
            Name of the spike file
        
        Returns
        -------
        system
            Data format or recording system
        
        &#34;&#34;&#34;
        self.spike.load(filename=filename, system=system)

    def add_spike(self, spike=None, **kwargs):
        &#34;&#34;&#34;
        Adds new spike node to current NSpike() object
        
        Parameters
        ----------
        spike : NSpike
            NSPike object. If None, new object is created
        
        Returns
        -------
        `:obj:NSpike`
            A new NSpike() object

        &#34;&#34;&#34;
        
        return self.spike.add_spike(spike=spike, **kwargs)

    def load_spike(self, names=None):
        &#34;&#34;&#34;
        Loads datasets of the spike nodes. Name of each node is used for obtaining the
        filenames.
        
        Parameters
        ----------
        names : list of str
            Names of the nodes to load. If None, current NSpike() object is loaded
        
        Returns
        -------
        None

        &#34;&#34;&#34;
        self.spike.load_spike(names=names)

    def wave_property(self):
        &#34;&#34;&#34;
        Claulates different waveform properties for currently set unit
        
        Delegates to NSpike().wave_property()
        
        Parameters
        ----------
        None
 
        Returns
        -------
        dict
            Graphical data of the analysis
        
        See also
        --------
        NSpike().wave_property()

        &#34;&#34;&#34;
        
        return self.spike.wave_property()

    def isi(self, bins=&#39;auto&#39;, bound=None, density=False):
        &#34;&#34;&#34;
        Calulates the ISI histogram of the spike train
        
        Delegates to NSpike().isi()
        
        Parameters
        ----------
        bins : str or int
            Number of ISI histogram bins. If &#39;auto&#39;, NumPy default is used
            
        bound : int
            Length of the ISI histogram in msec
        density : bool
            If true, normalized historagm is calcultaed
 
        Returns
        -------
        dict
            Graphical data of the analysis
        
        See also
        --------
        NSpike().isi()
    
        &#34;&#34;&#34;
        
        return self.spike.isi(bins=bins, bound=bound, density=density)

    def isi_corr(self, **kwargs):
        &#34;&#34;&#34;
        Analysis of ISI autocrrelation histogram
        
        Delegates to NSpike().isi_auto_corr()
        
        Parameters
        ----------            
        **kwargs
            Keyword arguments
 
        Returns
        -------
        dict
            Graphical data of the analysis
    
        See also
        --------
        nc_spike.NSpike().isi_corr

        &#34;&#34;&#34;
        
        return self.spike.isi_corr(**kwargs)

    def psth(self, event_stamp, **kwargs):
        &#34;&#34;&#34;
        Calculates peri-stimulus time histogram (PSTH)
        
        Delegates to NSpike().psth()
        
        Parameters
        ----------
        event_stamp : ndarray
            Event timestamps
            
        **kwargs
            Keyword arguments
 
        Returns
        -------
        dict
            Graphical data of the analysis
            
        See also
        --------
        NSpike().psth()
    
        &#34;&#34;&#34;
        
        return self.spike.psth(event_stamp, **kwargs)

    def burst(self, burst_thresh=5, ibi_thresh=50):
        &#34;&#34;&#34;
        Burst analysis of spik-train
        
        Delegates to NSpike().burst()
        
        Parameters
        ----------
        burst_thresh : int
            Minimum ISI between consecutive spikes in a burst
            
        ibi_thresh : int
            Minimum inter-burst interval between two bursting groups of spikes
 
        Returns
        -------
        None
    
        See also
        --------
        nc_spike.NSpike().burst

        &#34;&#34;&#34;
        
        self.spike.burst(burst_thresh=burst_thresh, ibi_thresh=ibi_thresh)

    def get_total_spikes(self):
        &#34;&#34;&#34;
        Returns total number of spikes in the recording
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Total number of spikes

        &#34;&#34;&#34;
        
        return self.spike.get_total_spikes()

    def get_total_channels(self):
        &#34;&#34;&#34;
        Returns total number of electrode channels in the spike data file
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Total number of electrode channels

        &#34;&#34;&#34;
        
        return self.spike.get_total_channels()

    def get_channel_ids(self):
        &#34;&#34;&#34;
        Returns the identities of individual channels
                
        Parameters
        ----------
        None
 
        Returns
        -------
        list
            Identities of individual channels 

        &#34;&#34;&#34;
        
        return self.spike.get_channel_ids()

    def get_timebase(self):
        &#34;&#34;&#34;
        Returns the timebase for spike event timestamps
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Timebase for spike event timestamps

        &#34;&#34;&#34;
        
        return  self.spike.get_timebase()

    def get_sampling_rate(self):
        &#34;&#34;&#34;
        Returns the sampling rate of spike waveforms
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Sampling rate for spike waveforms

        &#34;&#34;&#34;
        
        return self.spike.get_sampling_rate()

    def get_samples_per_spike(self):
        &#34;&#34;&#34;
        Returns the number of bytes to represent each timestamp in the binary file
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Number of bytes to represent timestamps

        &#34;&#34;&#34;
        return self.spike.get_samples_per_spike()

    def get_wave_timestamp(self):
        &#34;&#34;&#34;
        Returns the temporal resolution to  represent samples of spike-waves.
                
        Parameters
        ----------
        None
 
        Returns
        -------
        int
            Number of bytes to represent timestamps

        &#34;&#34;&#34;
        
        # resturn as microsecond
        fs = self.spike.get_sampling_rate()/10**6 # fs downsampled so that the time is given in microsecond
        return 1/fs

    def save_to_hdf5(self):
        &#34;&#34;&#34;
        Stores NSpike() object to HDF5 file
        
        Delegates to NSPike().save_to_hdf5()
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        Also see
        --------
        nc_hdf.Nhdf().save_spike()
        
        &#34;&#34;&#34;
        
        self.spike.save_to_hdf5()

    def get_feat(self, npc = 2):
        &#34;&#34;&#34;
        Returns the spike-waveform features.
        
        Parameters
        ----------
        nc : int
            Number of principle components in each channel.
        
        Returns
        -------
        feat : ndarray
            Matrix of size (number_spike X number_features)
        
        &#34;&#34;&#34;
        
        if not self.NULL_CHAN_REMOVED:
            self.remove_null_chan()
        if not self.ALLIGNED:
            self.align_wave_peak()

        trough, trough_loc = self.get_min_wave_chan() # trough only in max_channel
        peak, peak_chan, peak_loc = self.get_max_wave_chan()
#        amp = np.abs(peak-trough)
        pc = self.get_wave_pc(npc=npc)
        shape = (self.get_total_spikes(), 1)
        feat = np.concatenate((peak.reshape(shape), trough.reshape(shape), pc), axis=1)

        return feat

        # for all units
    def get_feat_by_unit(self, unit_no = None):
        &#34;&#34;&#34;
        Returns the spike-waveform features for a paricular unit.
        
        Parameters
        ----------
        unit_no : int
            Unit of interest
        
        Returns
        -------
        feat : ndarray
            Matrix of size (number_spike X number_features)
        
        &#34;&#34;&#34;
        
        
        if unit_no in self.get_unit_list():
            feat = self.get_feat()
            return feat[self.get_unit_tags() == unit_no, :]
        else:
            logging.error(&#39;Specified unit does not exist in the spike dataset&#39;)
            
    def get_wave_peaks(self):
        &#34;&#34;&#34;
        Returns the peaks of the spike-waveforms.
        
        Parameters
        ----------
        None        

        Returns
        -------
        peak : ndarray
            Spike waveform peaks in all the electrode channels (num_waves X num_channels)
        peak_loc : ndarray
            Index of peak locations
        &#34;&#34;&#34;
        
        wave = self.get_waveform()
        peak = np.zeros((self.get_total_spikes(), len(wave.keys())))
        peak_loc = np.zeros((self.get_total_spikes(), len(wave.keys())), dtype=int)
        for i, key in enumerate(wave.keys()):
            peak[:, i] = np.amax(wave[key], axis=1)
            peak_loc[:, i] = np.argmax(wave[key], axis=1)

        return peak, peak_loc

    def get_max_wave_chan(self):
        &#34;&#34;&#34;
        Returns the maximum of waveform peaks among the electrode groups.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        max_wave_val : ndarray
            Maximum value of the peaks of the waveforms
        max_wave_chan : ndarray
            Channel of the electrode group where a spike waveform is strongest
        peak_loc : ndarray
            Peak location in the channel with strongest waveform
        
        &#34;&#34;&#34;
        
        # Peak value at the highest channel, the highest channel, and the index of the peak
        peak, peak_loc = self.get_wave_peaks()
        max_wave_chan = np.argmax(peak, axis=1)
        max_wave_val = np.amax(peak, axis=1)
        return max_wave_val, max_wave_chan, peak_loc[np.arange(len(peak_loc)), max_wave_chan]

    def align_wave_peak(self, reach=300, factor=2):
        &#34;&#34;&#34;
        Align the waves by their peaks.
        
        Parameters
        ----------
        reach : int
            Maximum allowed time-shift in microsecond
        factors : int
            Resampling factor
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        if not self.UPSAMPLED:
            self.resample_wave(factor=factor)
        if not self.ALLIGNED:
            shift = round(reach/self.get_wave_timestamp()) # maximum 300microsecond allowed for shift
            wave = self.get_waveform() # NC waves are stroed in waves[&#39;ch1&#39;], waves[&#39;ch2&#39;] etc. ways
            maxInd = shift + self.get_max_wave_chan()[2]
            shift_ind = int(np.median(maxInd)) - maxInd
            shift_ind[np.abs(shift_ind) &gt; shift] = 0
            stacked_chan = np.empty((self.get_total_spikes(), self.get_samples_per_spike(), self.get_total_channels()))
            keys = []
            i = 0
            for key, val in wave.items():
                stacked_chan[:, :, i] = val
                keys.append(key)
                i += 1

            stacked_chan = np.lib.pad(stacked_chan, [(0, 0), (shift, shift), (0, 0)], &#39;edge&#39;) # Shows error in Jupyter, check again

            stacked_chan = np.array([np.roll(stacked_chan[i, :, :], shift_ind[i], axis=0)[shift: shift+ self.get_samples_per_spike()] for i in np.arange(shift_ind.size)])

            for i, key in enumerate(keys):
                wave[key] = stacked_chan[:, :, i]
            self._set_waveform(wave)
            self.ALLIGNED = True

#        stacked_chan = np.roll(stacked_chan, tuple(shift_ind), axis=tuple(np.ones(shift_ind.size)))

    def get_wave_min(self):
        &#34;&#34;&#34;
        Returns the minimum values of the spike-waveforms.
        
        Parameters
        ----------
        None

        Returns
        -------
        min_w : ndarray
            Minimum value of the  wavefforms
        min_loc : ndarray
            Index of minimum value
            
        &#34;&#34;&#34;
        
        wave = self.get_waveform()
        min_w = np.zeros((self.get_total_spikes(), len(wave.keys())))
        min_loc = np.zeros((self.get_total_spikes(), len(wave.keys())))
        for i, key in enumerate(wave.keys()):
            min_w[:, i] = np.amin(wave[key], axis=1)
            min_loc[:, i] = np.argmin(wave[key], axis=1)

        return min_w, min_loc

    def get_min_wave_chan(self):
        &#34;&#34;&#34;
        Returns the maximum of waveform peaks among the electrode groups.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        ndarray
            Minimum value of the waveform at channels with maximum peak value
        ndarray
            Index of minimum values
        
        &#34;&#34;&#34;
        # Peak value at the highest channel, the highest channel, and the index of the peak
        max_wave_chan = self.get_max_wave_chan()[1]
        trough, trough_loc = self.get_wave_min()
        return trough[np.arange(len(max_wave_chan)), max_wave_chan], \
                trough_loc[np.arange(len(max_wave_chan)), max_wave_chan]
        # use get_max_channel to determine

    def get_wave_pc(self, npc=2):
        &#34;&#34;&#34;
        Returns the Principle Components of the waveforms
        
        Parameters
        ----------
        npc : int
            Number of principle components from waveforms of each channel
        
        Returns
        -------
        pc : ndarray
            Principle components (num_waves X npc*num_channels)        
        &#34;&#34;&#34;
        wave = self.get_waveform()
        pc = np.array([])
        for key, w in wave.items():
            pca = PCA(n_components=5)
            w_new = pca.fit_transform(w)
            pc_var = pca.explained_variance_ratio_

            if npc and npc &lt; w_new.shape[1]:
                w_new = w_new[:, :npc]
            else:
                w_new = w_new[:, 0:(find(np.cumsum(pc_var) &gt;= 0.95, 1, &#39;first&#39;)[0]+1)]
            if not len(pc):
                pc = w_new
            else:
                pc = np.append(pc, w_new, axis=1)
        return pc

    def get_wavetime(self):
        &#34;&#34;&#34;
        Returns the timestamps of the waveforms, not the spiking-event timestamp
        
        Parameters
        ----------
        None
        
        Returns
        -------
            Timestamps of the spike-waveforms
            
        &#34;&#34;&#34;
        
        # calculate the wavetime from the sampling rate and number of sample, returns in microsecond
        nsamp = self.spike.get_samples_per_spike()
        timestamp = self.get_wave_timestamp()
        return np.arange(0, (nsamp)*timestamp, timestamp)

    def resample_wavetime(self, factor=2):
        &#34;&#34;&#34;
        Resamples the timestamps of spike-waveforms
        
        Parameters
        ----------
        factor : int
            Resampling factor
        
        Returns
        -------
            Resampled timestamps
            
        &#34;&#34;&#34;
        
        wavetime = self.get_wavetime()
        timestamp = self.get_wave_timestamp()
        
        return np.arange(0, wavetime[-1], timestamp/factor)
        # return resampled time

    def resample_wave(self, factor=2):
        &#34;&#34;&#34;
        Resamples spike waveforms
        
        Parameters
        ----------
        factor : int
            Resampling factor
        
        Returns
        -------
        wave : dict
            Upsampled waveforms
        uptime  ndarray
            Upsampled wave timestamps
            
        &#34;&#34;&#34;
        # resample wave using spline interpolation using the resampled_time,return wave
        if not self.UPSAMPLED:
            wavetime = self.get_wavetime()
            uptime = self.resample_wavetime(factor=factor)
            wave = self.get_waveform()
            for key, w in wave.items():
                f = sc.interpolate.interp1d(wavetime, w, axis=1, kind=&#39;quadratic&#39;)
                wave[key] = f(uptime)

            self.spike._set_sampling_rate(self.get_sampling_rate()*factor)
            self.spike._set_samples_per_spike(uptime.size)
            self.UPSAMPLED = True
            
            return wave, uptime
        
        else:
            logging.warning(&#39;You can upsample only once. Please reload data from source file for changing sampling factor!&#39;)

    def get_wave_energy(self):
        &#34;&#34;&#34;
        Energy of the spike waveforms, measured as the summation of the square of samples
        
        Parameters
        ----------
        None
        
        Returns
        -------
        energy : ndarray
            Energy of spikes (num_spike X num_channels)
        &#34;&#34;&#34;
        wave = self.get_waveform()
        energy = np.zeros((self.get_total_spikes(), len(wave.keys())))
        for i, key in enumerate(wave.keys()):
            energy[:, i] = np.sum(np.square(wave[key]), 1)/10**6 # taken the enrgy in mV2
        return energy

    def get_max_energy_chan(self):
        &#34;&#34;&#34;
        Returns the maximum energy of the spike waveforms
        
        Parameters
        ----------
        None
        
        Returns
        -------
        ndarray
            Maximum energy of the spikes
        &#34;&#34;&#34;
        
        energy = self.get_wave_energy()
        return np.argmax(energy, axis=1)

    def remove_null_chan(self):
        &#34;&#34;&#34;
        Removes the channel from the electrode group that has no spike in it
        
        Parameters
        ----------
        None
        
        Returns
        -------
        off_chan : int
            Channel number that has been removed
            
        &#34;&#34;&#34;
        
        wave = self.get_waveform()
        off_chan = []
        for key, w in wave.items():
            if np.abs(w).sum() == 0:
                off_chan.append(key)
        if off_chan:
            for key in off_chan:
                del wave[key]
            self._set_waveform(wave)
            self.NULL_CHAN_REMOVED = True
        
        return off_chan
        # simply detect in which channel everything is zero, which means it&#39;s a reference channel or nothing is recorded here

    def cluster_separation(self, unit_no=0):
        &#34;&#34;&#34;
        Quantitatively measures the separation of a specific unit from other clusters
        
        Parameters
        ----------
        unit_no : int
            Unit of interest. If &#39;0&#39;, pairwise comparison of all units are returned
        
        Returns
        -------
        bc : ndarray
            Bhattacharyya coefficient
        dh : ndarray
            Hellinger distance
            
        &#34;&#34;&#34;
        
        # if unit_no==0 all units, matrix output for pairwise comparison,
        # else maximum BC for the specified unit
        feat = self.get_feat()
        unit_list = self.get_unit_list()
        n_units = len(unit_list)

        if unit_no == 0:
            bc = np.zeros([n_units, n_units])
            dh = np.zeros([n_units, n_units])
            for c1 in np.arange(n_units):
                for c2 in np.arange(n_units):
                    X1 = feat[self.get_unit_tags() == unit_list[c1], :]
                    X2 = feat[self.get_unit_tags() == unit_list[c2], :]
                    bc[c1, c2] = bhatt(X1, X2)[0]
                    dh[c1, c2] = hellinger(X1, X2)
                    unit_list = self.get_unit_list()
        else:
            bc = np.zeros(n_units)
            dh = np.zeros(n_units)
            X1 = feat[self.get_unit_tags() == unit_no, :]
            for c2 in np.arange(n_units):
                if c2 == unit_no:
                    bc[c2] = 0
                    dh[c2] = 1
                else:
                    X2 = feat[self.get_unit_tags() == unit_list[c2], :]
                    bc[c2] = bhatt(X1, X2)[0]
                    dh[c2] = hellinger(X1, X2)
                idx = find(np.array(unit_list) != unit_no)

            return bc[idx], dh[idx]

    def cluster_similarity(self, nclust=None, unit_1=None, unit_2=None):
        &#34;&#34;&#34;
        Quantitatively measures the similarity or distance of cluster of one unit
        in a spike dataset to cluster of another unit in another dataset
        
        Parameters
        ----------
        nclust : Nclust
            NClust object whose unit is under comparison
        unit_1 : int
            Unit of current Nclust object
        unit_2 : int
            Unit of another NClust object  under comparison
        
        Returns
        -------
        
        bc : ndarray
            Bhattacharyya coefficient
        dh : ndarray
            Hellinger distance
            
        &#34;&#34;&#34;
        
        if isinstance(nclust, NClust):
            if unit_1 in self.get_unit_list() and unit_2 in nclust.get_unit_list():
                X1 = self.get_feat_by_unit(unit_no=unit_1)
                X2 = nclust.get_feat_by_unit(unit_no=unit_2)
                bc = bhatt(X1, X2)[0]
                dh = hellinger(X1, X2)
        return bc, dh</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="neurochat.nc_base.NBase" href="nc_base.html#neurochat.nc_base.NBase">NBase</a></li>
<li><a title="neurochat.nc_base.NAbstract" href="nc_base.html#neurochat.nc_base.NAbstract">NAbstract</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="neurochat.nc_clust.NClust.add_spike"><code class="name flex">
<span>def <span class="ident">add_spike</span></span>(<span>self, spike=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds new spike node to current NSpike() object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spike</code></strong> :&ensp;<code>NSpike</code></dt>
<dd>NSPike object. If None, new object is created</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>:obj:NSpike</code>
A new NSpike() object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_spike(self, spike=None, **kwargs):
    &#34;&#34;&#34;
    Adds new spike node to current NSpike() object
    
    Parameters
    ----------
    spike : NSpike
        NSPike object. If None, new object is created
    
    Returns
    -------
    `:obj:NSpike`
        A new NSpike() object

    &#34;&#34;&#34;
    
    return self.spike.add_spike(spike=spike, **kwargs)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.align_wave_peak"><code class="name flex">
<span>def <span class="ident">align_wave_peak</span></span>(<span>self, reach=300, factor=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Align the waves by their peaks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reach</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum allowed time-shift in microsecond</dd>
<dt><strong><code>factors</code></strong> :&ensp;<code>int</code></dt>
<dd>Resampling factor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def align_wave_peak(self, reach=300, factor=2):
    &#34;&#34;&#34;
    Align the waves by their peaks.
    
    Parameters
    ----------
    reach : int
        Maximum allowed time-shift in microsecond
    factors : int
        Resampling factor
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;
    
    if not self.UPSAMPLED:
        self.resample_wave(factor=factor)
    if not self.ALLIGNED:
        shift = round(reach/self.get_wave_timestamp()) # maximum 300microsecond allowed for shift
        wave = self.get_waveform() # NC waves are stroed in waves[&#39;ch1&#39;], waves[&#39;ch2&#39;] etc. ways
        maxInd = shift + self.get_max_wave_chan()[2]
        shift_ind = int(np.median(maxInd)) - maxInd
        shift_ind[np.abs(shift_ind) &gt; shift] = 0
        stacked_chan = np.empty((self.get_total_spikes(), self.get_samples_per_spike(), self.get_total_channels()))
        keys = []
        i = 0
        for key, val in wave.items():
            stacked_chan[:, :, i] = val
            keys.append(key)
            i += 1

        stacked_chan = np.lib.pad(stacked_chan, [(0, 0), (shift, shift), (0, 0)], &#39;edge&#39;) # Shows error in Jupyter, check again

        stacked_chan = np.array([np.roll(stacked_chan[i, :, :], shift_ind[i], axis=0)[shift: shift+ self.get_samples_per_spike()] for i in np.arange(shift_ind.size)])

        for i, key in enumerate(keys):
            wave[key] = stacked_chan[:, :, i]
        self._set_waveform(wave)
        self.ALLIGNED = True</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.burst"><code class="name flex">
<span>def <span class="ident">burst</span></span>(<span>self, burst_thresh=5, ibi_thresh=50)</span>
</code></dt>
<dd>
<section class="desc"><p>Burst analysis of spik-train</p>
<p>Delegates to NSpike().burst()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>burst_thresh</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum ISI between consecutive spikes in a burst</dd>
<dt><strong><code>ibi_thresh</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum inter-burst interval between two bursting groups of spikes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See also</h2>
<p><code>nc_spike.NSpike().burst</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def burst(self, burst_thresh=5, ibi_thresh=50):
    &#34;&#34;&#34;
    Burst analysis of spik-train
    
    Delegates to NSpike().burst()
    
    Parameters
    ----------
    burst_thresh : int
        Minimum ISI between consecutive spikes in a burst
        
    ibi_thresh : int
        Minimum inter-burst interval between two bursting groups of spikes

    Returns
    -------
    None

    See also
    --------
    nc_spike.NSpike().burst

    &#34;&#34;&#34;
    
    self.spike.burst(burst_thresh=burst_thresh, ibi_thresh=ibi_thresh)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.cluster_separation"><code class="name flex">
<span>def <span class="ident">cluster_separation</span></span>(<span>self, unit_no=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Quantitatively measures the separation of a specific unit from other clusters</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit of interest. If '0', pairwise comparison of all units are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Bhattacharyya coefficient</dd>
<dt><strong><code>dh</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Hellinger distance</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cluster_separation(self, unit_no=0):
    &#34;&#34;&#34;
    Quantitatively measures the separation of a specific unit from other clusters
    
    Parameters
    ----------
    unit_no : int
        Unit of interest. If &#39;0&#39;, pairwise comparison of all units are returned
    
    Returns
    -------
    bc : ndarray
        Bhattacharyya coefficient
    dh : ndarray
        Hellinger distance
        
    &#34;&#34;&#34;
    
    # if unit_no==0 all units, matrix output for pairwise comparison,
    # else maximum BC for the specified unit
    feat = self.get_feat()
    unit_list = self.get_unit_list()
    n_units = len(unit_list)

    if unit_no == 0:
        bc = np.zeros([n_units, n_units])
        dh = np.zeros([n_units, n_units])
        for c1 in np.arange(n_units):
            for c2 in np.arange(n_units):
                X1 = feat[self.get_unit_tags() == unit_list[c1], :]
                X2 = feat[self.get_unit_tags() == unit_list[c2], :]
                bc[c1, c2] = bhatt(X1, X2)[0]
                dh[c1, c2] = hellinger(X1, X2)
                unit_list = self.get_unit_list()
    else:
        bc = np.zeros(n_units)
        dh = np.zeros(n_units)
        X1 = feat[self.get_unit_tags() == unit_no, :]
        for c2 in np.arange(n_units):
            if c2 == unit_no:
                bc[c2] = 0
                dh[c2] = 1
            else:
                X2 = feat[self.get_unit_tags() == unit_list[c2], :]
                bc[c2] = bhatt(X1, X2)[0]
                dh[c2] = hellinger(X1, X2)
            idx = find(np.array(unit_list) != unit_no)

        return bc[idx], dh[idx]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.cluster_similarity"><code class="name flex">
<span>def <span class="ident">cluster_similarity</span></span>(<span>self, nclust=None, unit_1=None, unit_2=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Quantitatively measures the similarity or distance of cluster of one unit
in a spike dataset to cluster of another unit in another dataset</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nclust</code></strong> :&ensp;<code>Nclust</code></dt>
<dd>NClust object whose unit is under comparison</dd>
<dt><strong><code>unit_1</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit of current Nclust object</dd>
<dt><strong><code>unit_2</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit of another NClust object
under comparison</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Bhattacharyya coefficient</dd>
<dt><strong><code>dh</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Hellinger distance</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cluster_similarity(self, nclust=None, unit_1=None, unit_2=None):
    &#34;&#34;&#34;
    Quantitatively measures the similarity or distance of cluster of one unit
    in a spike dataset to cluster of another unit in another dataset
    
    Parameters
    ----------
    nclust : Nclust
        NClust object whose unit is under comparison
    unit_1 : int
        Unit of current Nclust object
    unit_2 : int
        Unit of another NClust object  under comparison
    
    Returns
    -------
    
    bc : ndarray
        Bhattacharyya coefficient
    dh : ndarray
        Hellinger distance
        
    &#34;&#34;&#34;
    
    if isinstance(nclust, NClust):
        if unit_1 in self.get_unit_list() and unit_2 in nclust.get_unit_list():
            X1 = self.get_feat_by_unit(unit_no=unit_1)
            X2 = nclust.get_feat_by_unit(unit_no=unit_2)
            bc = bhatt(X1, X2)[0]
            dh = hellinger(X1, X2)
    return bc, dh</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_channel_ids"><code class="name flex">
<span>def <span class="ident">get_channel_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the identities of individual channels</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Identities of individual channels</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_channel_ids(self):
    &#34;&#34;&#34;
    Returns the identities of individual channels
            
    Parameters
    ----------
    None

    Returns
    -------
    list
        Identities of individual channels 

    &#34;&#34;&#34;
    
    return self.spike.get_channel_ids()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_feat"><code class="name flex">
<span>def <span class="ident">get_feat</span></span>(<span>self, npc=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the spike-waveform features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nc</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of principle components in each channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feat</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix of size (number_spike X number_features)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">    def get_feat(self, npc = 2):
        &#34;&#34;&#34;
        Returns the spike-waveform features.
        
        Parameters
        ----------
        nc : int
            Number of principle components in each channel.
        
        Returns
        -------
        feat : ndarray
            Matrix of size (number_spike X number_features)
        
        &#34;&#34;&#34;
        
        if not self.NULL_CHAN_REMOVED:
            self.remove_null_chan()
        if not self.ALLIGNED:
            self.align_wave_peak()

        trough, trough_loc = self.get_min_wave_chan() # trough only in max_channel
        peak, peak_chan, peak_loc = self.get_max_wave_chan()
#        amp = np.abs(peak-trough)
        pc = self.get_wave_pc(npc=npc)
        shape = (self.get_total_spikes(), 1)
        feat = np.concatenate((peak.reshape(shape), trough.reshape(shape), pc), axis=1)

        return feat</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_feat_by_unit"><code class="name flex">
<span>def <span class="ident">get_feat_by_unit</span></span>(<span>self, unit_no=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the spike-waveform features for a paricular unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit of interest</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>feat</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix of size (number_spike X number_features)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_feat_by_unit(self, unit_no = None):
    &#34;&#34;&#34;
    Returns the spike-waveform features for a paricular unit.
    
    Parameters
    ----------
    unit_no : int
        Unit of interest
    
    Returns
    -------
    feat : ndarray
        Matrix of size (number_spike X number_features)
    
    &#34;&#34;&#34;
    
    
    if unit_no in self.get_unit_list():
        feat = self.get_feat()
        return feat[self.get_unit_tags() == unit_no, :]
    else:
        logging.error(&#39;Specified unit does not exist in the spike dataset&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_max_energy_chan"><code class="name flex">
<span>def <span class="ident">get_max_energy_chan</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the maximum energy of the spike waveforms</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Maximum energy of the spikes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_max_energy_chan(self):
    &#34;&#34;&#34;
    Returns the maximum energy of the spike waveforms
    
    Parameters
    ----------
    None
    
    Returns
    -------
    ndarray
        Maximum energy of the spikes
    &#34;&#34;&#34;
    
    energy = self.get_wave_energy()
    return np.argmax(energy, axis=1)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_max_wave_chan"><code class="name flex">
<span>def <span class="ident">get_max_wave_chan</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the maximum of waveform peaks among the electrode groups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>max_wave_val</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Maximum value of the peaks of the waveforms</dd>
<dt><strong><code>max_wave_chan</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Channel of the electrode group where a spike waveform is strongest</dd>
<dt><strong><code>peak_loc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Peak location in the channel with strongest waveform</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_max_wave_chan(self):
    &#34;&#34;&#34;
    Returns the maximum of waveform peaks among the electrode groups.
    
    Parameters
    ----------
    None
    
    Returns
    -------
    max_wave_val : ndarray
        Maximum value of the peaks of the waveforms
    max_wave_chan : ndarray
        Channel of the electrode group where a spike waveform is strongest
    peak_loc : ndarray
        Peak location in the channel with strongest waveform
    
    &#34;&#34;&#34;
    
    # Peak value at the highest channel, the highest channel, and the index of the peak
    peak, peak_loc = self.get_wave_peaks()
    max_wave_chan = np.argmax(peak, axis=1)
    max_wave_val = np.amax(peak, axis=1)
    return max_wave_val, max_wave_chan, peak_loc[np.arange(len(peak_loc)), max_wave_chan]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_min_wave_chan"><code class="name flex">
<span>def <span class="ident">get_min_wave_chan</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the maximum of waveform peaks among the electrode groups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Minimum value of the waveform at channels with maximum peak value</dd>
<dt><code>ndarray</code></dt>
<dd>Index of minimum values</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_min_wave_chan(self):
    &#34;&#34;&#34;
    Returns the maximum of waveform peaks among the electrode groups.
    
    Parameters
    ----------
    None
    
    Returns
    -------
    ndarray
        Minimum value of the waveform at channels with maximum peak value
    ndarray
        Index of minimum values
    
    &#34;&#34;&#34;
    # Peak value at the highest channel, the highest channel, and the index of the peak
    max_wave_chan = self.get_max_wave_chan()[1]
    trough, trough_loc = self.get_wave_min()
    return trough[np.arange(len(max_wave_chan)), max_wave_chan], \
            trough_loc[np.arange(len(max_wave_chan)), max_wave_chan]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_samples_per_spike"><code class="name flex">
<span>def <span class="ident">get_samples_per_spike</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the number of bytes to represent each timestamp in the binary file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of bytes to represent timestamps</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_samples_per_spike(self):
    &#34;&#34;&#34;
    Returns the number of bytes to represent each timestamp in the binary file
            
    Parameters
    ----------
    None

    Returns
    -------
    int
        Number of bytes to represent timestamps

    &#34;&#34;&#34;
    return self.spike.get_samples_per_spike()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_sampling_rate"><code class="name flex">
<span>def <span class="ident">get_sampling_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the sampling rate of spike waveforms</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Sampling rate for spike waveforms</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_sampling_rate(self):
    &#34;&#34;&#34;
    Returns the sampling rate of spike waveforms
            
    Parameters
    ----------
    None

    Returns
    -------
    int
        Sampling rate for spike waveforms

    &#34;&#34;&#34;
    
    return self.spike.get_sampling_rate()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_timebase"><code class="name flex">
<span>def <span class="ident">get_timebase</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the timebase for spike event timestamps</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Timebase for spike event timestamps</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_timebase(self):
    &#34;&#34;&#34;
    Returns the timebase for spike event timestamps
            
    Parameters
    ----------
    None

    Returns
    -------
    int
        Timebase for spike event timestamps

    &#34;&#34;&#34;
    
    return  self.spike.get_timebase()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_timestamp"><code class="name flex">
<span>def <span class="ident">get_timestamp</span></span>(<span>self, unit_no=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the timestamps of the spike-waveforms of specified unit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit whose timestamps are to be returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Timestamps of the spiking waveforms</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_timestamp(self, unit_no=None):    
    &#34;&#34;&#34;
    Returns the timestamps of the spike-waveforms of specified unit
    
    Parameters
    ----------
    unit_no : int
        Unit whose timestamps are to be returned
    
    Returns
    -------
    ndarray
        Timestamps of the spiking waveforms
        
    &#34;&#34;&#34;
    
    self.spike.get_timestamp(unit_no=unit_no)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_total_channels"><code class="name flex">
<span>def <span class="ident">get_total_channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns total number of electrode channels in the spike data file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Total number of electrode channels</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_total_channels(self):
    &#34;&#34;&#34;
    Returns total number of electrode channels in the spike data file
            
    Parameters
    ----------
    None

    Returns
    -------
    int
        Total number of electrode channels

    &#34;&#34;&#34;
    
    return self.spike.get_total_channels()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_total_spikes"><code class="name flex">
<span>def <span class="ident">get_total_spikes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns total number of spikes in the recording</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Total number of spikes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_total_spikes(self):
    &#34;&#34;&#34;
    Returns total number of spikes in the recording
            
    Parameters
    ----------
    None

    Returns
    -------
    int
        Total number of spikes

    &#34;&#34;&#34;
    
    return self.spike.get_total_spikes()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_unit_list"><code class="name flex">
<span>def <span class="ident">get_unit_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the list of units in a spike dataset</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of units</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_unit_list(self):
    &#34;&#34;&#34;
    Returns the list of units in a spike dataset
    
    Parameters
    ----------
    None
    
    Returns
    -------
    list
        List of units
    
    &#34;&#34;&#34;
    
    return self.spike.get_unit_list()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_unit_spikes_count"><code class="name flex">
<span>def <span class="ident">get_unit_spikes_count</span></span>(<span>self, unit_no=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the total number of spikes in a specified unit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit whose count is returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Total number of spikes in the unit</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_unit_spikes_count(self, unit_no=None):
    &#34;&#34;&#34;
    Returns the total number of spikes in a specified unit
    
    Parameters
    ----------
    unit_no : int
        Unit whose count is returned
    
    Returns
    -------
    int
        Total number of spikes in the unit
    
    &#34;&#34;&#34;
        
    return self.spike.get_unit_spikes_count(unit_no=unit_no)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_unit_tags"><code class="name flex">
<span>def <span class="ident">get_unit_tags</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns tags of the spiking waveforms from clustering</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_unit_tags(self):
    &#34;&#34;&#34;
    Returns tags of the spiking waveforms from clustering
    
    Parameters
    ----------
    None
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;
    
    return self.spike.get_unit_tags()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_unit_waves"><code class="name flex">
<span>def <span class="ident">get_unit_waves</span></span>(<span>self, unit_no=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns spike waveforms of a specific unit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit_no</code></strong> :&ensp;<code>int</code></dt>
<dd>Unit whose waveforms are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Spike wavefoorms in each channel of the electrode group</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_unit_waves(self, unit_no=None):
    &#34;&#34;&#34;
    Returns spike waveforms of a specific unit
    
    Parameters
    ----------
    unit_no : int
        Unit whose waveforms are returned
    
    Returns
    -------
    dict
        Spike wavefoorms in each channel of the electrode group 
    
    &#34;&#34;&#34;
    return self.spike.get_unit_waves(unit_no=unit_no)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_wave_energy"><code class="name flex">
<span>def <span class="ident">get_wave_energy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Energy of the spike waveforms, measured as the summation of the square of samples</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>energy</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Energy of spikes (num_spike X num_channels)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_wave_energy(self):
    &#34;&#34;&#34;
    Energy of the spike waveforms, measured as the summation of the square of samples
    
    Parameters
    ----------
    None
    
    Returns
    -------
    energy : ndarray
        Energy of spikes (num_spike X num_channels)
    &#34;&#34;&#34;
    wave = self.get_waveform()
    energy = np.zeros((self.get_total_spikes(), len(wave.keys())))
    for i, key in enumerate(wave.keys()):
        energy[:, i] = np.sum(np.square(wave[key]), 1)/10**6 # taken the enrgy in mV2
    return energy</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_wave_min"><code class="name flex">
<span>def <span class="ident">get_wave_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the minimum values of the spike-waveforms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>min_w</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Minimum value of the
wavefforms</dd>
<dt><strong><code>min_loc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Index of minimum value</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_wave_min(self):
    &#34;&#34;&#34;
    Returns the minimum values of the spike-waveforms.
    
    Parameters
    ----------
    None

    Returns
    -------
    min_w : ndarray
        Minimum value of the  wavefforms
    min_loc : ndarray
        Index of minimum value
        
    &#34;&#34;&#34;
    
    wave = self.get_waveform()
    min_w = np.zeros((self.get_total_spikes(), len(wave.keys())))
    min_loc = np.zeros((self.get_total_spikes(), len(wave.keys())))
    for i, key in enumerate(wave.keys()):
        min_w[:, i] = np.amin(wave[key], axis=1)
        min_loc[:, i] = np.argmin(wave[key], axis=1)

    return min_w, min_loc</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_wave_pc"><code class="name flex">
<span>def <span class="ident">get_wave_pc</span></span>(<span>self, npc=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the Principle Components of the waveforms</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>npc</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of principle components from waveforms of each channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Principle components (num_waves X npc*num_channels)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_wave_pc(self, npc=2):
    &#34;&#34;&#34;
    Returns the Principle Components of the waveforms
    
    Parameters
    ----------
    npc : int
        Number of principle components from waveforms of each channel
    
    Returns
    -------
    pc : ndarray
        Principle components (num_waves X npc*num_channels)        
    &#34;&#34;&#34;
    wave = self.get_waveform()
    pc = np.array([])
    for key, w in wave.items():
        pca = PCA(n_components=5)
        w_new = pca.fit_transform(w)
        pc_var = pca.explained_variance_ratio_

        if npc and npc &lt; w_new.shape[1]:
            w_new = w_new[:, :npc]
        else:
            w_new = w_new[:, 0:(find(np.cumsum(pc_var) &gt;= 0.95, 1, &#39;first&#39;)[0]+1)]
        if not len(pc):
            pc = w_new
        else:
            pc = np.append(pc, w_new, axis=1)
    return pc</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_wave_peaks"><code class="name flex">
<span>def <span class="ident">get_wave_peaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the peaks of the spike-waveforms.</p>
<h2 id="parameters">Parameters</h2>
<p>None
</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>peak</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Spike waveform peaks in all the electrode channels (num_waves X num_channels)</dd>
<dt><strong><code>peak_loc</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Index of peak locations</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_wave_peaks(self):
    &#34;&#34;&#34;
    Returns the peaks of the spike-waveforms.
    
    Parameters
    ----------
    None        

    Returns
    -------
    peak : ndarray
        Spike waveform peaks in all the electrode channels (num_waves X num_channels)
    peak_loc : ndarray
        Index of peak locations
    &#34;&#34;&#34;
    
    wave = self.get_waveform()
    peak = np.zeros((self.get_total_spikes(), len(wave.keys())))
    peak_loc = np.zeros((self.get_total_spikes(), len(wave.keys())), dtype=int)
    for i, key in enumerate(wave.keys()):
        peak[:, i] = np.amax(wave[key], axis=1)
        peak_loc[:, i] = np.argmax(wave[key], axis=1)

    return peak, peak_loc</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_wave_timestamp"><code class="name flex">
<span>def <span class="ident">get_wave_timestamp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the temporal resolution to
represent samples of spike-waves.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of bytes to represent timestamps</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_wave_timestamp(self):
    &#34;&#34;&#34;
    Returns the temporal resolution to  represent samples of spike-waves.
            
    Parameters
    ----------
    None

    Returns
    -------
    int
        Number of bytes to represent timestamps

    &#34;&#34;&#34;
    
    # resturn as microsecond
    fs = self.spike.get_sampling_rate()/10**6 # fs downsampled so that the time is given in microsecond
    return 1/fs</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_waveform"><code class="name flex">
<span>def <span class="ident">get_waveform</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the waveforms in the spike dataset</p>
<h2 id="parameters">Parameters</h2>
<p>None
</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Each key represents one channel of the electrode group, each value
represents the waveforms of the spikes in a matrix form (no_samples x no_spikes)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_waveform(self):
    &#34;&#34;&#34;
    Returns the waveforms in the spike dataset
    
    Parameters
    ----------
    None        

    Returns
    -------
    dict
        Each key represents one channel of the electrode group, each value
        represents the waveforms of the spikes in a matrix form (no_samples x no_spikes)
    
    &#34;&#34;&#34; 
    return self.spike.get_waveform()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.get_wavetime"><code class="name flex">
<span>def <span class="ident">get_wavetime</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the timestamps of the waveforms, not the spiking-event timestamp</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>Timestamps of the spike-waveforms
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_wavetime(self):
    &#34;&#34;&#34;
    Returns the timestamps of the waveforms, not the spiking-event timestamp
    
    Parameters
    ----------
    None
    
    Returns
    -------
        Timestamps of the spike-waveforms
        
    &#34;&#34;&#34;
    
    # calculate the wavetime from the sampling rate and number of sample, returns in microsecond
    nsamp = self.spike.get_samples_per_spike()
    timestamp = self.get_wave_timestamp()
    return np.arange(0, (nsamp)*timestamp, timestamp)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.isi"><code class="name flex">
<span>def <span class="ident">isi</span></span>(<span>self, bins='auto', bound=None, density=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calulates the ISI histogram of the spike train</p>
<p>Delegates to NSpike().isi()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bins</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>Number of ISI histogram bins. If 'auto', NumPy default is used</dd>
<dt><strong><code>bound</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the ISI histogram in msec</dd>
<dt><strong><code>density</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, normalized historagm is calcultaed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Graphical data of the analysis</dd>
</dl>
<h2 id="see-also">See also</h2>
<p><code>NSpike().isi()</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isi(self, bins=&#39;auto&#39;, bound=None, density=False):
    &#34;&#34;&#34;
    Calulates the ISI histogram of the spike train
    
    Delegates to NSpike().isi()
    
    Parameters
    ----------
    bins : str or int
        Number of ISI histogram bins. If &#39;auto&#39;, NumPy default is used
        
    bound : int
        Length of the ISI histogram in msec
    density : bool
        If true, normalized historagm is calcultaed

    Returns
    -------
    dict
        Graphical data of the analysis
    
    See also
    --------
    NSpike().isi()

    &#34;&#34;&#34;
    
    return self.spike.isi(bins=bins, bound=bound, density=density)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.isi_corr"><code class="name flex">
<span>def <span class="ident">isi_corr</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Analysis of ISI autocrrelation histogram</p>
<p>Delegates to NSpike().isi_auto_corr()</p>
<h2 id="parameters">Parameters</h2>
<p>**kwargs
Keyword arguments</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Graphical data of the analysis</dd>
</dl>
<h2 id="see-also">See also</h2>
<p><code>nc_spike.NSpike().isi_corr</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isi_corr(self, **kwargs):
    &#34;&#34;&#34;
    Analysis of ISI autocrrelation histogram
    
    Delegates to NSpike().isi_auto_corr()
    
    Parameters
    ----------            
    **kwargs
        Keyword arguments

    Returns
    -------
    dict
        Graphical data of the analysis

    See also
    --------
    nc_spike.NSpike().isi_corr

    &#34;&#34;&#34;
    
    return self.spike.isi_corr(**kwargs)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename=None, system=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads spike dataset from the file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the spike file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>system</code></dt>
<dd>Data format or recording system</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load(self, filename=None, system=None):
    &#34;&#34;&#34;
    Loads spike dataset from the file
    
    Parameters
    ----------
    filename: str
        Name of the spike file
    
    Returns
    -------
    system
        Data format or recording system
    
    &#34;&#34;&#34;
    self.spike.load(filename=filename, system=system)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.load_spike"><code class="name flex">
<span>def <span class="ident">load_spike</span></span>(<span>self, names=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads datasets of the spike nodes. Name of each node is used for obtaining the
filenames.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Names of the nodes to load. If None, current NSpike() object is loaded</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_spike(self, names=None):
    &#34;&#34;&#34;
    Loads datasets of the spike nodes. Name of each node is used for obtaining the
    filenames.
    
    Parameters
    ----------
    names : list of str
        Names of the nodes to load. If None, current NSpike() object is loaded
    
    Returns
    -------
    None

    &#34;&#34;&#34;
    self.spike.load_spike(names=names)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.psth"><code class="name flex">
<span>def <span class="ident">psth</span></span>(<span>self, event_stamp, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates peri-stimulus time histogram (PSTH)</p>
<p>Delegates to NSpike().psth()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event_stamp</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Event timestamps</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Graphical data of the analysis</dd>
</dl>
<h2 id="see-also">See also</h2>
<p><code>NSpike().psth()</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def psth(self, event_stamp, **kwargs):
    &#34;&#34;&#34;
    Calculates peri-stimulus time histogram (PSTH)
    
    Delegates to NSpike().psth()
    
    Parameters
    ----------
    event_stamp : ndarray
        Event timestamps
        
    **kwargs
        Keyword arguments

    Returns
    -------
    dict
        Graphical data of the analysis
        
    See also
    --------
    NSpike().psth()

    &#34;&#34;&#34;
    
    return self.spike.psth(event_stamp, **kwargs)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.remove_null_chan"><code class="name flex">
<span>def <span class="ident">remove_null_chan</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes the channel from the electrode group that has no spike in it</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>off_chan</code></strong> :&ensp;<code>int</code></dt>
<dd>Channel number that has been removed</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_null_chan(self):
    &#34;&#34;&#34;
    Removes the channel from the electrode group that has no spike in it
    
    Parameters
    ----------
    None
    
    Returns
    -------
    off_chan : int
        Channel number that has been removed
        
    &#34;&#34;&#34;
    
    wave = self.get_waveform()
    off_chan = []
    for key, w in wave.items():
        if np.abs(w).sum() == 0:
            off_chan.append(key)
    if off_chan:
        for key in off_chan:
            del wave[key]
        self._set_waveform(wave)
        self.NULL_CHAN_REMOVED = True
    
    return off_chan</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.resample_wave"><code class="name flex">
<span>def <span class="ident">resample_wave</span></span>(<span>self, factor=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Resamples spike waveforms</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>int</code></dt>
<dd>Resampling factor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>wave</code></strong> :&ensp;<code>dict</code></dt>
<dd>Upsampled waveforms</dd>
<dt><code>uptime</code>
<code>ndarray</code></dt>
<dd>Upsampled wave timestamps</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def resample_wave(self, factor=2):
    &#34;&#34;&#34;
    Resamples spike waveforms
    
    Parameters
    ----------
    factor : int
        Resampling factor
    
    Returns
    -------
    wave : dict
        Upsampled waveforms
    uptime  ndarray
        Upsampled wave timestamps
        
    &#34;&#34;&#34;
    # resample wave using spline interpolation using the resampled_time,return wave
    if not self.UPSAMPLED:
        wavetime = self.get_wavetime()
        uptime = self.resample_wavetime(factor=factor)
        wave = self.get_waveform()
        for key, w in wave.items():
            f = sc.interpolate.interp1d(wavetime, w, axis=1, kind=&#39;quadratic&#39;)
            wave[key] = f(uptime)

        self.spike._set_sampling_rate(self.get_sampling_rate()*factor)
        self.spike._set_samples_per_spike(uptime.size)
        self.UPSAMPLED = True
        
        return wave, uptime
    
    else:
        logging.warning(&#39;You can upsample only once. Please reload data from source file for changing sampling factor!&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.resample_wavetime"><code class="name flex">
<span>def <span class="ident">resample_wavetime</span></span>(<span>self, factor=2)</span>
</code></dt>
<dd>
<section class="desc"><p>Resamples the timestamps of spike-waveforms</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>int</code></dt>
<dd>Resampling factor</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>Resampled timestamps
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def resample_wavetime(self, factor=2):
    &#34;&#34;&#34;
    Resamples the timestamps of spike-waveforms
    
    Parameters
    ----------
    factor : int
        Resampling factor
    
    Returns
    -------
        Resampled timestamps
        
    &#34;&#34;&#34;
    
    wavetime = self.get_wavetime()
    timestamp = self.get_wave_timestamp()
    
    return np.arange(0, wavetime[-1], timestamp/factor)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.save_to_hdf5"><code class="name flex">
<span>def <span class="ident">save_to_hdf5</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Stores NSpike() object to HDF5 file</p>
<p>Delegates to NSPike().save_to_hdf5()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="also-see">Also see</h2>
<p>nc_hdf.Nhdf().save_spike()</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save_to_hdf5(self):
    &#34;&#34;&#34;
    Stores NSpike() object to HDF5 file
    
    Delegates to NSPike().save_to_hdf5()
    
    Parameters
    ----------
    None
    
    Returns
    -------
    None
    
    Also see
    --------
    nc_hdf.Nhdf().save_spike()
    
    &#34;&#34;&#34;
    
    self.spike.save_to_hdf5()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.set_unit_tags"><code class="name flex">
<span>def <span class="ident">set_unit_tags</span></span>(<span>self, new_tags=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns tags of the spiking waveforms from clustering</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new_tags</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array that contains the tags for spike-waveforms based on the cluster number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_unit_tags(self, new_tags=None):
    &#34;&#34;&#34;
    Returns tags of the spiking waveforms from clustering
    
    Parameters
    ----------
    new_tags : ndarray
        Array that contains the tags for spike-waveforms based on the cluster number
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;
    
    self.spike.set_unit_tags(new_tags)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_clust.NClust.wave_property"><code class="name flex">
<span>def <span class="ident">wave_property</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Claulates different waveform properties for currently set unit</p>
<p>Delegates to NSpike().wave_property()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Graphical data of the analysis</dd>
</dl>
<h2 id="see-also">See also</h2>
<p><code>NSpike().wave_property()</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wave_property(self):
    &#34;&#34;&#34;
    Claulates different waveform properties for currently set unit
    
    Delegates to NSpike().wave_property()
    
    Parameters
    ----------
    None

    Returns
    -------
    dict
        Graphical data of the analysis
    
    See also
    --------
    NSpike().wave_property()

    &#34;&#34;&#34;
    
    return self.spike.wave_property()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="neurochat.nc_base.NBase" href="nc_base.html#neurochat.nc_base.NBase">NBase</a></b></code>:
<ul class="hlist">
<li><code><a title="neurochat.nc_base.NBase.add_node" href="nc_base.html#neurochat.nc_base.NBase.add_node">add_node</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.change_names" href="nc_base.html#neurochat.nc_base.NBase.change_names">change_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.count_lfp" href="nc_base.html#neurochat.nc_base.NBase.count_lfp">count_lfp</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.count_spike" href="nc_base.html#neurochat.nc_base.NBase.count_spike">count_spike</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.del_lfp" href="nc_base.html#neurochat.nc_base.NBase.del_lfp">del_lfp</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.del_node" href="nc_base.html#neurochat.nc_base.NBase.del_node">del_node</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.del_spike" href="nc_base.html#neurochat.nc_base.NBase.del_spike">del_spike</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_comments" href="nc_base.html#neurochat.nc_base.NAbstract.get_comments">get_comments</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_data_source" href="nc_base.html#neurochat.nc_base.NAbstract.get_data_source">get_data_source</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_date" href="nc_base.html#neurochat.nc_base.NAbstract.get_date">get_date</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_duration" href="nc_base.html#neurochat.nc_base.NAbstract.get_duration">get_duration</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_experimenter" href="nc_base.html#neurochat.nc_base.NAbstract.get_experimenter">get_experimenter</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_file_version" href="nc_base.html#neurochat.nc_base.NAbstract.get_file_version">get_file_version</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_filename" href="nc_base.html#neurochat.nc_base.NAbstract.get_filename">get_filename</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_lfp" href="nc_base.html#neurochat.nc_base.NBase.get_lfp">get_lfp</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_lfp_names" href="nc_base.html#neurochat.nc_base.NBase.get_lfp_names">get_lfp_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_name" href="nc_base.html#neurochat.nc_base.NAbstract.get_name">get_name</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_node" href="nc_base.html#neurochat.nc_base.NBase.get_node">get_node</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_record_info" href="nc_base.html#neurochat.nc_base.NAbstract.get_record_info">get_record_info</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_results" href="nc_base.html#neurochat.nc_base.NAbstract.get_results">get_results</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_source_format" href="nc_base.html#neurochat.nc_base.NAbstract.get_source_format">get_source_format</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_spike" href="nc_base.html#neurochat.nc_base.NBase.get_spike">get_spike</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_spike_names" href="nc_base.html#neurochat.nc_base.NBase.get_spike_names">get_spike_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_system" href="nc_base.html#neurochat.nc_base.NAbstract.get_system">get_system</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_time" href="nc_base.html#neurochat.nc_base.NAbstract.get_time">get_time</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_type" href="nc_base.html#neurochat.nc_base.NAbstract.get_type">get_type</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.reset_results" href="nc_base.html#neurochat.nc_base.NAbstract.reset_results">reset_results</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_description" href="nc_base.html#neurochat.nc_base.NAbstract.set_description">set_description</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_filename" href="nc_base.html#neurochat.nc_base.NAbstract.set_filename">set_filename</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_lfp_file_names" href="nc_base.html#neurochat.nc_base.NBase.set_lfp_file_names">set_lfp_file_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_lfp_names" href="nc_base.html#neurochat.nc_base.NBase.set_lfp_names">set_lfp_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_name" href="nc_base.html#neurochat.nc_base.NAbstract.set_name">set_name</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_node_file_names" href="nc_base.html#neurochat.nc_base.NBase.set_node_file_names">set_node_file_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_record_info" href="nc_base.html#neurochat.nc_base.NAbstract.set_record_info">set_record_info</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_spike_file_names" href="nc_base.html#neurochat.nc_base.NBase.set_spike_file_names">set_spike_file_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_spike_names" href="nc_base.html#neurochat.nc_base.NBase.set_spike_names">set_spike_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_system" href="nc_base.html#neurochat.nc_base.NAbstract.set_system">set_system</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.update_result" href="nc_base.html#neurochat.nc_base.NAbstract.update_result">update_result</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neurochat" href="index.html">neurochat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="neurochat.nc_clust.NClust" href="#neurochat.nc_clust.NClust">NClust</a></code></h4>
<ul class="">
<li><code><a title="neurochat.nc_clust.NClust.add_spike" href="#neurochat.nc_clust.NClust.add_spike">add_spike</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.align_wave_peak" href="#neurochat.nc_clust.NClust.align_wave_peak">align_wave_peak</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.burst" href="#neurochat.nc_clust.NClust.burst">burst</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.cluster_separation" href="#neurochat.nc_clust.NClust.cluster_separation">cluster_separation</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.cluster_similarity" href="#neurochat.nc_clust.NClust.cluster_similarity">cluster_similarity</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_channel_ids" href="#neurochat.nc_clust.NClust.get_channel_ids">get_channel_ids</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_feat" href="#neurochat.nc_clust.NClust.get_feat">get_feat</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_feat_by_unit" href="#neurochat.nc_clust.NClust.get_feat_by_unit">get_feat_by_unit</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_max_energy_chan" href="#neurochat.nc_clust.NClust.get_max_energy_chan">get_max_energy_chan</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_max_wave_chan" href="#neurochat.nc_clust.NClust.get_max_wave_chan">get_max_wave_chan</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_min_wave_chan" href="#neurochat.nc_clust.NClust.get_min_wave_chan">get_min_wave_chan</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_samples_per_spike" href="#neurochat.nc_clust.NClust.get_samples_per_spike">get_samples_per_spike</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_sampling_rate" href="#neurochat.nc_clust.NClust.get_sampling_rate">get_sampling_rate</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_timebase" href="#neurochat.nc_clust.NClust.get_timebase">get_timebase</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_timestamp" href="#neurochat.nc_clust.NClust.get_timestamp">get_timestamp</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_total_channels" href="#neurochat.nc_clust.NClust.get_total_channels">get_total_channels</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_total_spikes" href="#neurochat.nc_clust.NClust.get_total_spikes">get_total_spikes</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_unit_list" href="#neurochat.nc_clust.NClust.get_unit_list">get_unit_list</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_unit_spikes_count" href="#neurochat.nc_clust.NClust.get_unit_spikes_count">get_unit_spikes_count</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_unit_tags" href="#neurochat.nc_clust.NClust.get_unit_tags">get_unit_tags</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_unit_waves" href="#neurochat.nc_clust.NClust.get_unit_waves">get_unit_waves</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_wave_energy" href="#neurochat.nc_clust.NClust.get_wave_energy">get_wave_energy</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_wave_min" href="#neurochat.nc_clust.NClust.get_wave_min">get_wave_min</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_wave_pc" href="#neurochat.nc_clust.NClust.get_wave_pc">get_wave_pc</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_wave_peaks" href="#neurochat.nc_clust.NClust.get_wave_peaks">get_wave_peaks</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_wave_timestamp" href="#neurochat.nc_clust.NClust.get_wave_timestamp">get_wave_timestamp</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_waveform" href="#neurochat.nc_clust.NClust.get_waveform">get_waveform</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.get_wavetime" href="#neurochat.nc_clust.NClust.get_wavetime">get_wavetime</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.isi" href="#neurochat.nc_clust.NClust.isi">isi</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.isi_corr" href="#neurochat.nc_clust.NClust.isi_corr">isi_corr</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.load" href="#neurochat.nc_clust.NClust.load">load</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.load_spike" href="#neurochat.nc_clust.NClust.load_spike">load_spike</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.psth" href="#neurochat.nc_clust.NClust.psth">psth</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.remove_null_chan" href="#neurochat.nc_clust.NClust.remove_null_chan">remove_null_chan</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.resample_wave" href="#neurochat.nc_clust.NClust.resample_wave">resample_wave</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.resample_wavetime" href="#neurochat.nc_clust.NClust.resample_wavetime">resample_wavetime</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.save_to_hdf5" href="#neurochat.nc_clust.NClust.save_to_hdf5">save_to_hdf5</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.set_unit_tags" href="#neurochat.nc_clust.NClust.set_unit_tags">set_unit_tags</a></code></li>
<li><code><a title="neurochat.nc_clust.NClust.wave_property" href="#neurochat.nc_clust.NClust.wave_property">wave_property</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>