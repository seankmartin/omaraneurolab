<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>neurochat.nc_base API documentation</title>
<meta name="description" content="This module implements two classes NAbstract and NBase those are inherited by
other data classes for detailed implementation. Methods and attributes â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neurochat.nc_base</code></h1>
</header>
<section id="section-intro">
<p>This module implements two classes NAbstract and NBase those are inherited by
other data classes for detailed implementation. Methods and attributes those are
likely to be common in other data types in NeuroChaT are implemented in these classes.</p>
<p>@author: Md Nurul Islam; islammn at tcd dot ie</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module implements two classes NAbstract and NBase those are inherited by 
other data classes for detailed implementation. Methods and attributes those are
likely to be common in other data types in NeuroChaT are implemented in these classes.

@author: Md Nurul Islam; islammn at tcd dot ie
&#34;&#34;&#34;
import inspect
import logging

from collections import OrderedDict as oDict


class NAbstract(object):
    &#34;&#34;&#34;
    Nabstract is the abstract class which includes number of attirbutes and methods commonly used by most other data types.

    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Instantiate the `NAbstract` class

        Parameters
        ---------
        **kwargs
            Keyword arguments

        &#34;&#34;&#34;

        self._filename = kwargs.get(&#39;filename&#39;, &#39;&#39;)
        self._system = kwargs.get(&#39;system&#39;, &#39;Axona&#39;)
        self._name = kwargs.get(&#39;name&#39;, &#39;c0&#39;)
        self._description = &#39;&#39;
        self._results = oDict()
        self._record_info = {&#39;File version&#39;: &#39;&#39;,
                             &#39;Date&#39;: &#39;&#39;,
                             &#39;Time&#39;: &#39;&#39;,
                             &#39;Experimenter&#39;: &#39;&#39;,
                             &#39;Comments&#39;: &#39;&#39;,
                             &#39;Duration&#39;: 0,
                             &#39;Format&#39;: &#39;Axona&#39;,
                             &#39;Source&#39;: self._filename}

        self.__type = &#39;abstract&#39;

    def get_type(self):
        &#34;&#34;&#34;Returns the type of data class, e.g., instance of Nabstract will return &#39;abstract&#39; as the type of the class.

        Parameters
        ----------
        None

        Returns
        -------
        str    
        &#34;&#34;&#34;
        return self.__type

    def set_filename(self, filename=None):
        &#34;&#34;&#34;Sets the file name of the data object

        Parameters
        ----------
        filename : str
            Name of the data file

        Returns
        -------
        None
        &#34;&#34;&#34;

        if filename is not None:
            self._filename = filename

    def get_filename(self):
        &#34;&#34;&#34;Returns the filename of the data class.

        Parameters
        ----------
        None

        Returns
        -------
        str    
        &#34;&#34;&#34;
        return self._filename

    def set_system(self, system=None):
        &#34;&#34;&#34;Sets the name of the recording system or the format of the data file.

        Parameters
        ----------
        system : str
            Recording system or data file format

        Returns
        -------
        None    
        &#34;&#34;&#34;

        if system is not None:
            self._system = system

    def get_system(self):
        &#34;&#34;&#34;Returns the name of the recording system or data format.

        Parameters
        ----------
        None

        Returns
        -------
        str    
        &#34;&#34;&#34;

        return self._system

    def set_name(self, name=&#39;&#39;):
        &#34;&#34;&#34;Sets a name for the class instance.

        Parameters
        ----------
        name : str

        Returns
        -------
        None    
        &#34;&#34;&#34;

        self._name = name

    def get_name(self):
        &#34;&#34;&#34;Gets the name of the object.

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._name

    def set_description(self, description=&#39;&#39;):
        &#34;&#34;&#34;Sets the general description about the data by the user.

        Parameters
        ----------
        description : str

        Returns
        -------
        None    
        &#34;&#34;&#34;

        self._description = description

    def save_to_hdf5(self, parent_dir):
        &#34;&#34;&#34;
        Implemented in subclasses
        &#34;&#34;&#34;
        pass  # implement for each type

    def load(self):
        &#34;&#34;&#34;
        Implemented in subclasses
        &#34;&#34;&#34;
        pass

    @classmethod
    def _new_instance(cls, obj=None, **kwargs):
        &#34;&#34;&#34;Creates a new instance from the class `cls`. If `obj` is None, a new
        instance of `cls` is returned.  If the `obj` is an 
        instance of `cls`, the same is returned. If `obj` itself is a class, 
        it supersedes the `cls` and returns an object of `obj` class.

        Parameters
        ----------
        cls
            Class of the new node
        obj
            Either an object of class `cls` or a Class to be instantiated

        Returns
        -------
            New node of specified Class instance

        &#34;&#34;&#34;

        if obj is None:
            new_obj = cls(**kwargs)
        elif isinstance(obj, cls):
            new_obj = obj
        elif inspect.isclass(obj):
            cls = obj
        new_obj = cls(**kwargs)

        return new_obj

    def get_results(self):
        &#34;&#34;&#34;Returns the analysis results

        Returns
        -------
        OrderedDict

        &#34;&#34;&#34;

        return self._results

    def update_result(self, new_result={}):
        &#34;&#34;&#34;Updates the results.

        Parameters
        ----------
        description : str

        Returns
        -------
        OrderedDict

        See Also
        --------
        get_results

        &#34;&#34;&#34;

        self._results.update(new_result)

    def reset_results(self):
        &#34;&#34;&#34;Resets the results to an empty OrderedDict.

        &#34;&#34;&#34;

        self._results = oDict()

    def _set_file_version(self, version=&#39;&#39;):
        &#34;&#34;&#34;Sets th file version as decoded from the native formats.

        Parameters
        ----------
        version : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;File version&#39;] = version

    def _set_date(self, date_str=&#39;&#39;):
        &#34;&#34;&#34;Sets the date of the experiment.

        Parameters
        ----------
        date_str : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Date&#39;] = date_str

    def _set_time(self, time=&#39;&#39;):
        &#34;&#34;&#34;Sets the time of the experiment.

        Parameters
        ----------
        time : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Time&#39;] = time

    def _set_experiemnter(self, experimenter=&#39;&#39;):
        &#34;&#34;&#34;Sets the name of the experimenter

        Parameters
        ----------
        experimenter : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Experimenter&#39;] = experimenter

    def _set_comments(self, comments=&#39;&#39;):
        &#34;&#34;&#34;Sets comments or notes of the experimenter

        Parameters
        ----------
        comments : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Comments&#39;] = comments

    def _set_duration(self, duration=&#39;&#39;):
        &#34;&#34;&#34;Sets the duration of the experiment

        Parameters
        ----------
        duration : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Duration&#39;] = duration

    def _set_source_format(self, system=&#39;Axona&#39;):
        &#34;&#34;&#34;Sets the recording format or the source-format of the data

        Parameters
        ----------
        system: str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Format&#39;] = system

    def _set_data_source(self, filename=None):
        &#34;&#34;&#34;Sets the source of the original data file

        Parameters
        ----------
        filename : str

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._record_info[&#39;Source&#39;] = filename

    def get_file_version(self):
        &#34;&#34;&#34;Gets the version of the data file

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;
        return self._record_info[&#39;File version&#39;]

    def get_date(self):
        &#34;&#34;&#34;Gets the recording date

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Date&#39;]

    def get_time(self):
        &#34;&#34;&#34;Gets the time of the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Time&#39;]

    def get_experimenter(self):
        &#34;&#34;&#34;Gets the name of the experimenter

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Experimenter&#39;]

    def get_comments(self):
        &#34;&#34;&#34;Gets the comments or notes about the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Comments&#39;]

    def get_duration(self):
        &#34;&#34;&#34;Gets the duration of the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;
        return self._record_info[&#39;Duration&#39;]

    def get_source_format(self):
        &#34;&#34;&#34;Gets the recording system or native data format

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Format&#39;]

    def get_data_source(self):
        &#34;&#34;&#34;Gets the source of the data

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Source&#39;]

    def set_record_info(self, new_info={}):
        &#34;&#34;&#34;Sets the recording information

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Sets one of the recording information in `(name, value)` pair
        &#34;&#34;&#34;

        self._record_info.update(new_info)

    def get_record_info(self, record_name=None):
        &#34;&#34;&#34;Gets the comments or notes about the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;
        if record_name is None:
            return self._record_info
        else:
            return self._record_info.get(record_name, None)


class NBase(NAbstract):
    &#34;&#34;&#34;
    Derived from NAbstract class, NBase implements additional functionalities 
    for managing multiple spike or LFP datasets.

    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Instantiate the `NBase` class

        Parameters
        ---------
        **kwargs
            Keyword arguments

        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._spikes = []
        self._spikes_by_name = oDict()
        self._lfp = []
        self._lfp_by_name = oDict()

        self._record_info = {&#39;File version&#39;: &#39;&#39;,
                             &#39;Date&#39;: &#39;&#39;,
                             &#39;Time&#39;: &#39;&#39;,
                             &#39;Experimenter&#39;: &#39;&#39;,
                             &#39;Comments&#39;: &#39;&#39;,
                             &#39;Duration&#39;: 0,
                             &#39;No of channels&#39;: 1,
                             &#39;Bytes per timestamp&#39;: 1,
                             &#39;Sampling rate&#39;: 1,
                             &#39;Bytes per sample&#39;: 1,
                             &#39;ADC Fullscale mv&#39;: 1,
                             &#39;Format&#39;: &#39;Axona&#39;,
                             &#39;Source&#39;: self._filename}
        self.__type = &#39;base&#39;

    def add_node(self, node, node_type=None, **kwargs):
        &#34;&#34;&#34;Adds a new dataset, called node to the spike and LFP dataset arrays

        Parameters
        ----------
        node
            Data node to be added
        node_type : str
            Type of the dataset described in each class attributes
        **kwargs
            Keywrod arguments

        Returns
        -------
        None
        &#34;&#34;&#34;

        name = node.get_name()
        _replace = kwargs.get(&#39;replace&#39;, False)

        if node_type is None:
            logging.error(&#39;Node type is not defined&#39;)
        elif node_type == &#39;spike&#39;:
            node_names = self.get_spike_names()
            nodes = self._spikes
            nodesByName = self._spikes_by_name
        elif node_type == &#39;lfp&#39;:
            node_names = self.get_lfp_names()
            nodes = self._lfp
            nodesByName = self._lfp_by_name

        if _replace:
            i = self.del_node(node)
        elif name in node_names:
            logging.warning(node_type + &#39; with name {0} already exists, &#39;.format(name) +
                            &#39;cannot add another one.\r\n&#39; +
                            &#39;Try renaming or set replace True&#39;)
        else:
            i = len(nodes)

        nodes.insert(i, node)
        nodesByName[name] = node

    def del_node(self, node):
        &#34;&#34;&#34;Deletes a node that represents spike or LFP dataset

        Parameters
        ----------
        node
            Data node to be deleted

        Returns
        -------
        int
            Index of deleted node
        &#34;&#34;&#34;
        i = None
        if node in self._spikes:
            i = self._spikes.index(node)
            self._spikes.remove(node)
            del self._spikes_by_name[node.get_name()]
        elif node in self._lfp:
            i = self._lfp.index(node)
            self._lfp.remove(node)
            del self._lfp_by_name[node.get_name()]
        return i

    def get_node(self, node_names, node_type=&#39;spike&#39;):
        &#34;&#34;&#34;Gets the nodes by name and dataset type

        Parameters
        ----------
        node_names : list
            List of the names of the data nodes to obtain
        node_type : str
            Type of the data node

        Returns
        -------
        list
            List of the data nodes 
        &#34;&#34;&#34;

        nodes = []
        not_nodes = []
        if node_type == &#39;spike&#39;:
            names = self.get_spike_names()
            nodes = self._spikes_by_name
        elif node_type == &#39;lfp&#39;:
            names = self.get_lfp_names()
            nodes = self._lfp_by_name
        for name in node_names:
            nodes.append(nodes[name]) if name in names\
                else not_nodes.append(name)
        if not_nodes:
            logging.warning(&#39;,&#39;.join(not_nodes) + &#39; does not exist&#39;)
        return nodes

    def get_spike(self, names=None):
        &#34;&#34;&#34;Gets the spike nodes by name

        Parameters
        ----------
        names : list
            List of the names of the spike nodes to obtain

        Returns
        -------
        list
            List of the spike nodes. Returns all the spike nodes if `names` is None 
        &#34;&#34;&#34;

        if names is None:
            spikes = self._spikes
        else:
            spikes = self.get_node(names, &#39;spike&#39;)
        return spikes

    def get_lfp(self, names=None):
        &#34;&#34;&#34;Gets the lfp nodes by name

        Parameters
        ----------
        names : list
            List of the names of the lfp nodes to obtain

        Returns
        -------
        list
            List of the lfp nodes. Returns all the lfp nodes if `names` is None 
        &#34;&#34;&#34;

        if names is None:
            lfp = self._lfp
        else:
            lfp = self.get_node(names, &#39;lfp&#39;)
        return lfp

    def del_spike(self, spike):
        &#34;&#34;&#34;Deletes a node that represents spike dataset

        Parameters
        ----------
        spike
            Spike node to be deleted by name or the object

        Returns
        -------
        i : int
            Index of the deleted node
        &#34;&#34;&#34;

        if isinstance(spike, str):
            name = spike
            spike = self.get_spike(name)
        i = self.del_node(spike)

        return i

    def del_lfp(self, lfp):
        &#34;&#34;&#34;Deletes a node that represents LFP dataset

        Parameters
        ----------
        lfp
            LFP node to be deleted by name or the object

        Returns
        -------
        int
            Index of the deleted node
        &#34;&#34;&#34;

        i = 0
        if isinstance(lfp, str):
            name = lfp
            lfp = self.get_lfp(name)
        i = self.del_node(lfp)

        return i

    def get_spike_names(self):
        &#34;&#34;&#34;Gets the names of all the spike nodes

        Parameters
        ----------
        None

        Returns
        -------
        list
            Names of the spike nodes
        &#34;&#34;&#34;

        return self._spikes_by_name.keys()

    def get_lfp_names(self):
        &#34;&#34;&#34;Gets the name of all the lfp nodes

        Parameters
        ----------
        None

        Returns
        -------
        list
            Names of the LFP nodes
        &#34;&#34;&#34;

        return self._lfp_by_name.keys()

    def change_names(self, old_names, new_names, node_type=&#39;spike&#39;):
        &#34;&#34;&#34;Changes the names of nodes. `old_names` should have the same length 
        as that of `new_length`

        Parameters
        ----------
        old_names : list of str
            List of the old names of nodes
        new_names : list of str
            List of the new names of nodes
        node_type
            Type of the data node

        Returns
        -------
        None
        &#34;&#34;&#34;

        if len(new_names) != len(old_names):
            logging.error(&#39;Input names are not equal in numbers!&#39;)
        elif len(set(new_names)) &lt; len(old_names):
            logging.error(&#39;Duplicate names are not allowed!&#39;)
        else:
            if node_type == &#39;spike&#39;:
                for i, name in enumerate(new_names):
                    node = self.get_spike(old_names[i])
                    node.set_name(name)
                    self._spikes_by_name[name] = self._spikes_by_name.pop(
                        old_names[i])

            elif node_type == &#39;lfp&#39;:
                for i, name in enumerate(new_names):
                    node = self.get_lfp(old_names[i])
                    node.set_name(name)
                    self._lfp_by_name[name] = self._spikes_by_name.pop(
                        old_names[i])

    def set_spike_names(self, names):
        &#34;&#34;&#34;Sets the names of the spike nodes. Old names are replaced

        Parameters
        ----------
        names : list of str
            List of new names of the spike nodes

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.change_names(self.get_spike_names(), names, &#39;lfp&#39;)

    def set_lfp_names(self, names):
        &#34;&#34;&#34;Sets the names of the lfp nodes. Old names are replaced.

        Parameters
        ----------
        names : list of str
            List of new names of the lfp nodes

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.change_names(self.get_lfp_names(), names, &#39;lfp&#39;)

    def set_node_file_names(self, node_names, filenames, node_type=&#39;spike&#39;):
        &#34;&#34;&#34;Sets the filenames for each data node. `node_names` must be of equal
        length to `filenames`

        Parameters
        ----------
        node_names : list of str
            Names of the nodes whose filenames are set
        filenames : list of str
            List of the filenames for each node
        node_type
            Type of the data node

        Returns
        -------
        None

        &#34;&#34;&#34;

        if len(node_names) != len(filenames):
            logging.error(&#39;No. of names does not match with no. of filenames&#39;)
        elif len(set(node_names)) != len(node_names):
            logging.error(&#39;Duplicate names are not allowed!&#39;)
        else:
            nodes = self.get_node(node_names, node_type)
            for node in nodes:
                node.set_filename(filenames(nodes.index(node)))

    def set_spike_file_names(self, spike_names, filenames):
        &#34;&#34;&#34;Sets the filenames for each data node. `spike_names` must be of equal
        length to `filenames`

        Parameters
        ----------
        spike_names : list of str
            Names of the spike nodes whose filenames are set
        filenames : list of str
            List of the filenames for each spike node

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.set_node_file_names(spike_names, filenames, &#39;spike&#39;)

    def set_lfp_file_names(self, lfp_names, filenames):
        &#34;&#34;&#34;Sets the filenames for each LFP data node. `lfp_names` must be of equal
        length to `filenames`

        Parameters
        ----------
        lfp_names : list of str
            Names of the lfp nodes whose filenames are set
        filenames : list of str
            List of the filenames for each lfp node

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.set_node_file_names(lfp_names, filenames, &#39;lfp&#39;)

    def count_spike(self):
        &#34;&#34;&#34;Counts the number of spike nodes

        Parameters
        ----------
        None

        Returns
        -------
        int
            Total number of spike nodes
        &#34;&#34;&#34;
        return len(self._spikes)

    def count_lfp(self):
        &#34;&#34;&#34;Counts the number of lfp nodes

        Parameters
        ----------
        None

        Returns
        -------
        int
            Total number of lfp nodes
        &#34;&#34;&#34;
        return len(self._lfp)

    def _add_node(self, cls, node, node_type, **kwargs):
        &#34;&#34;&#34;Add a node of instance of class `cls` from `node` in the list of 
        `node_type`. Existing nodes can be replaced by input `replace= True` 

        Parameters
        ----------
        cls
            Class of node to be added
        node
            Either an object of `cls`or or a Class. If None, new instance of `cls`
            is added to the node list and returned
        node_type : str
            Type of the data node


        Returns
        -------

            Newly added data node

        See also
        --------
        add_node

        &#34;&#34;&#34;

        new_node = self._new_instance(node, **kwargs)
        self.add_node(new_node, node_type,
                      replace=kwargs.get(&#39;replace&#39;, False))

        return new_node

    def _get_instance(self, cls, node, node_type):
        &#34;&#34;&#34;Create a node of instance of class `cls` from `node` in the list of 
        `node_type`

        Parameters
        ----------
        cls
            Class of node to be added
        node
            Either an object of `cls`or or a Class. If None, new instance of `cls`
            is returned
        node_type : str
            Type of the data node

        Returns
        -------

            Newly added data node

        See also
        --------
        add_node

        &#34;&#34;&#34;
        if isinstance(node, cls):
            new_node = node
        else:
            if node_type == &#39;lfp&#39;:
                _get_node_names = self.get_lfp_names
                _get_node = self.get_lfp
            if node_type == &#39;spike&#39;:
                _get_node_names = self.get_spike_names
                _get_node = self.get_spike
            if node in _get_node_names():
                new_node = _get_node(node)

        return new_node</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="neurochat.nc_base.NAbstract"><code class="flex name class">
<span>class <span class="ident">NAbstract</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Nabstract is the abstract class which includes number of attirbutes and methods commonly used by most other data types.</p>
<p>Instantiate the <a title="neurochat.nc_base.NAbstract" href="#neurochat.nc_base.NAbstract"><code>NAbstract</code></a> class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NAbstract(object):
    &#34;&#34;&#34;
    Nabstract is the abstract class which includes number of attirbutes and methods commonly used by most other data types.

    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Instantiate the `NAbstract` class

        Parameters
        ---------
        **kwargs
            Keyword arguments

        &#34;&#34;&#34;

        self._filename = kwargs.get(&#39;filename&#39;, &#39;&#39;)
        self._system = kwargs.get(&#39;system&#39;, &#39;Axona&#39;)
        self._name = kwargs.get(&#39;name&#39;, &#39;c0&#39;)
        self._description = &#39;&#39;
        self._results = oDict()
        self._record_info = {&#39;File version&#39;: &#39;&#39;,
                             &#39;Date&#39;: &#39;&#39;,
                             &#39;Time&#39;: &#39;&#39;,
                             &#39;Experimenter&#39;: &#39;&#39;,
                             &#39;Comments&#39;: &#39;&#39;,
                             &#39;Duration&#39;: 0,
                             &#39;Format&#39;: &#39;Axona&#39;,
                             &#39;Source&#39;: self._filename}

        self.__type = &#39;abstract&#39;

    def get_type(self):
        &#34;&#34;&#34;Returns the type of data class, e.g., instance of Nabstract will return &#39;abstract&#39; as the type of the class.

        Parameters
        ----------
        None

        Returns
        -------
        str    
        &#34;&#34;&#34;
        return self.__type

    def set_filename(self, filename=None):
        &#34;&#34;&#34;Sets the file name of the data object

        Parameters
        ----------
        filename : str
            Name of the data file

        Returns
        -------
        None
        &#34;&#34;&#34;

        if filename is not None:
            self._filename = filename

    def get_filename(self):
        &#34;&#34;&#34;Returns the filename of the data class.

        Parameters
        ----------
        None

        Returns
        -------
        str    
        &#34;&#34;&#34;
        return self._filename

    def set_system(self, system=None):
        &#34;&#34;&#34;Sets the name of the recording system or the format of the data file.

        Parameters
        ----------
        system : str
            Recording system or data file format

        Returns
        -------
        None    
        &#34;&#34;&#34;

        if system is not None:
            self._system = system

    def get_system(self):
        &#34;&#34;&#34;Returns the name of the recording system or data format.

        Parameters
        ----------
        None

        Returns
        -------
        str    
        &#34;&#34;&#34;

        return self._system

    def set_name(self, name=&#39;&#39;):
        &#34;&#34;&#34;Sets a name for the class instance.

        Parameters
        ----------
        name : str

        Returns
        -------
        None    
        &#34;&#34;&#34;

        self._name = name

    def get_name(self):
        &#34;&#34;&#34;Gets the name of the object.

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._name

    def set_description(self, description=&#39;&#39;):
        &#34;&#34;&#34;Sets the general description about the data by the user.

        Parameters
        ----------
        description : str

        Returns
        -------
        None    
        &#34;&#34;&#34;

        self._description = description

    def save_to_hdf5(self, parent_dir):
        &#34;&#34;&#34;
        Implemented in subclasses
        &#34;&#34;&#34;
        pass  # implement for each type

    def load(self):
        &#34;&#34;&#34;
        Implemented in subclasses
        &#34;&#34;&#34;
        pass

    @classmethod
    def _new_instance(cls, obj=None, **kwargs):
        &#34;&#34;&#34;Creates a new instance from the class `cls`. If `obj` is None, a new
        instance of `cls` is returned.  If the `obj` is an 
        instance of `cls`, the same is returned. If `obj` itself is a class, 
        it supersedes the `cls` and returns an object of `obj` class.

        Parameters
        ----------
        cls
            Class of the new node
        obj
            Either an object of class `cls` or a Class to be instantiated

        Returns
        -------
            New node of specified Class instance

        &#34;&#34;&#34;

        if obj is None:
            new_obj = cls(**kwargs)
        elif isinstance(obj, cls):
            new_obj = obj
        elif inspect.isclass(obj):
            cls = obj
        new_obj = cls(**kwargs)

        return new_obj

    def get_results(self):
        &#34;&#34;&#34;Returns the analysis results

        Returns
        -------
        OrderedDict

        &#34;&#34;&#34;

        return self._results

    def update_result(self, new_result={}):
        &#34;&#34;&#34;Updates the results.

        Parameters
        ----------
        description : str

        Returns
        -------
        OrderedDict

        See Also
        --------
        get_results

        &#34;&#34;&#34;

        self._results.update(new_result)

    def reset_results(self):
        &#34;&#34;&#34;Resets the results to an empty OrderedDict.

        &#34;&#34;&#34;

        self._results = oDict()

    def _set_file_version(self, version=&#39;&#39;):
        &#34;&#34;&#34;Sets th file version as decoded from the native formats.

        Parameters
        ----------
        version : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;File version&#39;] = version

    def _set_date(self, date_str=&#39;&#39;):
        &#34;&#34;&#34;Sets the date of the experiment.

        Parameters
        ----------
        date_str : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Date&#39;] = date_str

    def _set_time(self, time=&#39;&#39;):
        &#34;&#34;&#34;Sets the time of the experiment.

        Parameters
        ----------
        time : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Time&#39;] = time

    def _set_experiemnter(self, experimenter=&#39;&#39;):
        &#34;&#34;&#34;Sets the name of the experimenter

        Parameters
        ----------
        experimenter : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Experimenter&#39;] = experimenter

    def _set_comments(self, comments=&#39;&#39;):
        &#34;&#34;&#34;Sets comments or notes of the experimenter

        Parameters
        ----------
        comments : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Comments&#39;] = comments

    def _set_duration(self, duration=&#39;&#39;):
        &#34;&#34;&#34;Sets the duration of the experiment

        Parameters
        ----------
        duration : str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Duration&#39;] = duration

    def _set_source_format(self, system=&#39;Axona&#39;):
        &#34;&#34;&#34;Sets the recording format or the source-format of the data

        Parameters
        ----------
        system: str

        Returns
        -------
        None
        &#34;&#34;&#34;

        self._record_info[&#39;Format&#39;] = system

    def _set_data_source(self, filename=None):
        &#34;&#34;&#34;Sets the source of the original data file

        Parameters
        ----------
        filename : str

        Returns
        -------
        None
        &#34;&#34;&#34;
        self._record_info[&#39;Source&#39;] = filename

    def get_file_version(self):
        &#34;&#34;&#34;Gets the version of the data file

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;
        return self._record_info[&#39;File version&#39;]

    def get_date(self):
        &#34;&#34;&#34;Gets the recording date

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Date&#39;]

    def get_time(self):
        &#34;&#34;&#34;Gets the time of the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Time&#39;]

    def get_experimenter(self):
        &#34;&#34;&#34;Gets the name of the experimenter

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Experimenter&#39;]

    def get_comments(self):
        &#34;&#34;&#34;Gets the comments or notes about the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Comments&#39;]

    def get_duration(self):
        &#34;&#34;&#34;Gets the duration of the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;
        return self._record_info[&#39;Duration&#39;]

    def get_source_format(self):
        &#34;&#34;&#34;Gets the recording system or native data format

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Format&#39;]

    def get_data_source(self):
        &#34;&#34;&#34;Gets the source of the data

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;

        return self._record_info[&#39;Source&#39;]

    def set_record_info(self, new_info={}):
        &#34;&#34;&#34;Sets the recording information

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Sets one of the recording information in `(name, value)` pair
        &#34;&#34;&#34;

        self._record_info.update(new_info)

    def get_record_info(self, record_name=None):
        &#34;&#34;&#34;Gets the comments or notes about the experiment

        Parameters
        ----------
        None

        Returns
        -------
        str
        &#34;&#34;&#34;
        if record_name is None:
            return self._record_info
        else:
            return self._record_info.get(record_name, None)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="neurochat.nc_base.NBase" href="#neurochat.nc_base.NBase">NBase</a></li>
<li><a title="neurochat.nc_spatial.NSpatial" href="nc_spatial.html#neurochat.nc_spatial.NSpatial">NSpatial</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="neurochat.nc_base.NAbstract.get_comments"><code class="name flex">
<span>def <span class="ident">get_comments</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the comments or notes about the experiment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_comments(self):
    &#34;&#34;&#34;Gets the comments or notes about the experiment

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._record_info[&#39;Comments&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_data_source"><code class="name flex">
<span>def <span class="ident">get_data_source</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the source of the data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_data_source(self):
    &#34;&#34;&#34;Gets the source of the data

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._record_info[&#39;Source&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_date"><code class="name flex">
<span>def <span class="ident">get_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the recording date</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_date(self):
    &#34;&#34;&#34;Gets the recording date

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._record_info[&#39;Date&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_duration"><code class="name flex">
<span>def <span class="ident">get_duration</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the duration of the experiment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_duration(self):
    &#34;&#34;&#34;Gets the duration of the experiment

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;
    return self._record_info[&#39;Duration&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_experimenter"><code class="name flex">
<span>def <span class="ident">get_experimenter</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the name of the experimenter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_experimenter(self):
    &#34;&#34;&#34;Gets the name of the experimenter

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._record_info[&#39;Experimenter&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_file_version"><code class="name flex">
<span>def <span class="ident">get_file_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the version of the data file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_file_version(self):
    &#34;&#34;&#34;Gets the version of the data file

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;
    return self._record_info[&#39;File version&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_filename"><code class="name flex">
<span>def <span class="ident">get_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the filename of the data class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_filename(self):
    &#34;&#34;&#34;Returns the filename of the data class.

    Parameters
    ----------
    None

    Returns
    -------
    str    
    &#34;&#34;&#34;
    return self._filename</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the name of the object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_name(self):
    &#34;&#34;&#34;Gets the name of the object.

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._name</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_record_info"><code class="name flex">
<span>def <span class="ident">get_record_info</span></span>(<span>self, record_name=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the comments or notes about the experiment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_record_info(self, record_name=None):
    &#34;&#34;&#34;Gets the comments or notes about the experiment

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;
    if record_name is None:
        return self._record_info
    else:
        return self._record_info.get(record_name, None)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_results"><code class="name flex">
<span>def <span class="ident">get_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the analysis results</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>OrderedDict</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_results(self):
    &#34;&#34;&#34;Returns the analysis results

    Returns
    -------
    OrderedDict

    &#34;&#34;&#34;

    return self._results</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_source_format"><code class="name flex">
<span>def <span class="ident">get_source_format</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the recording system or native data format</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_source_format(self):
    &#34;&#34;&#34;Gets the recording system or native data format

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._record_info[&#39;Format&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_system"><code class="name flex">
<span>def <span class="ident">get_system</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the name of the recording system or data format.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_system(self):
    &#34;&#34;&#34;Returns the name of the recording system or data format.

    Parameters
    ----------
    None

    Returns
    -------
    str    
    &#34;&#34;&#34;

    return self._system</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_time"><code class="name flex">
<span>def <span class="ident">get_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the time of the experiment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_time(self):
    &#34;&#34;&#34;Gets the time of the experiment

    Parameters
    ----------
    None

    Returns
    -------
    str
    &#34;&#34;&#34;

    return self._record_info[&#39;Time&#39;]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.get_type"><code class="name flex">
<span>def <span class="ident">get_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the type of data class, e.g., instance of Nabstract will return 'abstract' as the type of the class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_type(self):
    &#34;&#34;&#34;Returns the type of data class, e.g., instance of Nabstract will return &#39;abstract&#39; as the type of the class.

    Parameters
    ----------
    None

    Returns
    -------
    str    
    &#34;&#34;&#34;
    return self.__type</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Implemented in subclasses</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load(self):
    &#34;&#34;&#34;
    Implemented in subclasses
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.reset_results"><code class="name flex">
<span>def <span class="ident">reset_results</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Resets the results to an empty OrderedDict.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def reset_results(self):
    &#34;&#34;&#34;Resets the results to an empty OrderedDict.

    &#34;&#34;&#34;

    self._results = oDict()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.save_to_hdf5"><code class="name flex">
<span>def <span class="ident">save_to_hdf5</span></span>(<span>self, parent_dir)</span>
</code></dt>
<dd>
<section class="desc"><p>Implemented in subclasses</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save_to_hdf5(self, parent_dir):
    &#34;&#34;&#34;
    Implemented in subclasses
    &#34;&#34;&#34;
    pass  # implement for each type</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.set_description"><code class="name flex">
<span>def <span class="ident">set_description</span></span>(<span>self, description='')</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the general description about the data by the user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_description(self, description=&#39;&#39;):
    &#34;&#34;&#34;Sets the general description about the data by the user.

    Parameters
    ----------
    description : str

    Returns
    -------
    None    
    &#34;&#34;&#34;

    self._description = description</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.set_filename"><code class="name flex">
<span>def <span class="ident">set_filename</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the file name of the data object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the data file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_filename(self, filename=None):
    &#34;&#34;&#34;Sets the file name of the data object

    Parameters
    ----------
    filename : str
        Name of the data file

    Returns
    -------
    None
    &#34;&#34;&#34;

    if filename is not None:
        self._filename = filename</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name='')</span>
</code></dt>
<dd>
<section class="desc"><p>Sets a name for the class instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_name(self, name=&#39;&#39;):
    &#34;&#34;&#34;Sets a name for the class instance.

    Parameters
    ----------
    name : str

    Returns
    -------
    None    
    &#34;&#34;&#34;

    self._name = name</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.set_record_info"><code class="name flex">
<span>def <span class="ident">set_record_info</span></span>(<span>self, new_info={})</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the recording information</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Sets one of the recording information in <code>(name, value)</code> pair</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_record_info(self, new_info={}):
    &#34;&#34;&#34;Sets the recording information

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Sets one of the recording information in `(name, value)` pair
    &#34;&#34;&#34;

    self._record_info.update(new_info)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.set_system"><code class="name flex">
<span>def <span class="ident">set_system</span></span>(<span>self, system=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the name of the recording system or the format of the data file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code>str</code></dt>
<dd>Recording system or data file format</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_system(self, system=None):
    &#34;&#34;&#34;Sets the name of the recording system or the format of the data file.

    Parameters
    ----------
    system : str
        Recording system or data file format

    Returns
    -------
    None    
    &#34;&#34;&#34;

    if system is not None:
        self._system = system</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NAbstract.update_result"><code class="name flex">
<span>def <span class="ident">update_result</span></span>(<span>self, new_result={})</span>
</code></dt>
<dd>
<section class="desc"><p>Updates the results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>OrderedDict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>get_results</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_result(self, new_result={}):
    &#34;&#34;&#34;Updates the results.

    Parameters
    ----------
    description : str

    Returns
    -------
    OrderedDict

    See Also
    --------
    get_results

    &#34;&#34;&#34;

    self._results.update(new_result)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="neurochat.nc_base.NBase"><code class="flex name class">
<span>class <span class="ident">NBase</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Derived from NAbstract class, NBase implements additional functionalities
for managing multiple spike or LFP datasets.</p>
<p>Instantiate the <a title="neurochat.nc_base.NBase" href="#neurochat.nc_base.NBase"><code>NBase</code></a> class</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NBase(NAbstract):
    &#34;&#34;&#34;
    Derived from NAbstract class, NBase implements additional functionalities 
    for managing multiple spike or LFP datasets.

    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        Instantiate the `NBase` class

        Parameters
        ---------
        **kwargs
            Keyword arguments

        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._spikes = []
        self._spikes_by_name = oDict()
        self._lfp = []
        self._lfp_by_name = oDict()

        self._record_info = {&#39;File version&#39;: &#39;&#39;,
                             &#39;Date&#39;: &#39;&#39;,
                             &#39;Time&#39;: &#39;&#39;,
                             &#39;Experimenter&#39;: &#39;&#39;,
                             &#39;Comments&#39;: &#39;&#39;,
                             &#39;Duration&#39;: 0,
                             &#39;No of channels&#39;: 1,
                             &#39;Bytes per timestamp&#39;: 1,
                             &#39;Sampling rate&#39;: 1,
                             &#39;Bytes per sample&#39;: 1,
                             &#39;ADC Fullscale mv&#39;: 1,
                             &#39;Format&#39;: &#39;Axona&#39;,
                             &#39;Source&#39;: self._filename}
        self.__type = &#39;base&#39;

    def add_node(self, node, node_type=None, **kwargs):
        &#34;&#34;&#34;Adds a new dataset, called node to the spike and LFP dataset arrays

        Parameters
        ----------
        node
            Data node to be added
        node_type : str
            Type of the dataset described in each class attributes
        **kwargs
            Keywrod arguments

        Returns
        -------
        None
        &#34;&#34;&#34;

        name = node.get_name()
        _replace = kwargs.get(&#39;replace&#39;, False)

        if node_type is None:
            logging.error(&#39;Node type is not defined&#39;)
        elif node_type == &#39;spike&#39;:
            node_names = self.get_spike_names()
            nodes = self._spikes
            nodesByName = self._spikes_by_name
        elif node_type == &#39;lfp&#39;:
            node_names = self.get_lfp_names()
            nodes = self._lfp
            nodesByName = self._lfp_by_name

        if _replace:
            i = self.del_node(node)
        elif name in node_names:
            logging.warning(node_type + &#39; with name {0} already exists, &#39;.format(name) +
                            &#39;cannot add another one.\r\n&#39; +
                            &#39;Try renaming or set replace True&#39;)
        else:
            i = len(nodes)

        nodes.insert(i, node)
        nodesByName[name] = node

    def del_node(self, node):
        &#34;&#34;&#34;Deletes a node that represents spike or LFP dataset

        Parameters
        ----------
        node
            Data node to be deleted

        Returns
        -------
        int
            Index of deleted node
        &#34;&#34;&#34;
        i = None
        if node in self._spikes:
            i = self._spikes.index(node)
            self._spikes.remove(node)
            del self._spikes_by_name[node.get_name()]
        elif node in self._lfp:
            i = self._lfp.index(node)
            self._lfp.remove(node)
            del self._lfp_by_name[node.get_name()]
        return i

    def get_node(self, node_names, node_type=&#39;spike&#39;):
        &#34;&#34;&#34;Gets the nodes by name and dataset type

        Parameters
        ----------
        node_names : list
            List of the names of the data nodes to obtain
        node_type : str
            Type of the data node

        Returns
        -------
        list
            List of the data nodes 
        &#34;&#34;&#34;

        nodes = []
        not_nodes = []
        if node_type == &#39;spike&#39;:
            names = self.get_spike_names()
            nodes = self._spikes_by_name
        elif node_type == &#39;lfp&#39;:
            names = self.get_lfp_names()
            nodes = self._lfp_by_name
        for name in node_names:
            nodes.append(nodes[name]) if name in names\
                else not_nodes.append(name)
        if not_nodes:
            logging.warning(&#39;,&#39;.join(not_nodes) + &#39; does not exist&#39;)
        return nodes

    def get_spike(self, names=None):
        &#34;&#34;&#34;Gets the spike nodes by name

        Parameters
        ----------
        names : list
            List of the names of the spike nodes to obtain

        Returns
        -------
        list
            List of the spike nodes. Returns all the spike nodes if `names` is None 
        &#34;&#34;&#34;

        if names is None:
            spikes = self._spikes
        else:
            spikes = self.get_node(names, &#39;spike&#39;)
        return spikes

    def get_lfp(self, names=None):
        &#34;&#34;&#34;Gets the lfp nodes by name

        Parameters
        ----------
        names : list
            List of the names of the lfp nodes to obtain

        Returns
        -------
        list
            List of the lfp nodes. Returns all the lfp nodes if `names` is None 
        &#34;&#34;&#34;

        if names is None:
            lfp = self._lfp
        else:
            lfp = self.get_node(names, &#39;lfp&#39;)
        return lfp

    def del_spike(self, spike):
        &#34;&#34;&#34;Deletes a node that represents spike dataset

        Parameters
        ----------
        spike
            Spike node to be deleted by name or the object

        Returns
        -------
        i : int
            Index of the deleted node
        &#34;&#34;&#34;

        if isinstance(spike, str):
            name = spike
            spike = self.get_spike(name)
        i = self.del_node(spike)

        return i

    def del_lfp(self, lfp):
        &#34;&#34;&#34;Deletes a node that represents LFP dataset

        Parameters
        ----------
        lfp
            LFP node to be deleted by name or the object

        Returns
        -------
        int
            Index of the deleted node
        &#34;&#34;&#34;

        i = 0
        if isinstance(lfp, str):
            name = lfp
            lfp = self.get_lfp(name)
        i = self.del_node(lfp)

        return i

    def get_spike_names(self):
        &#34;&#34;&#34;Gets the names of all the spike nodes

        Parameters
        ----------
        None

        Returns
        -------
        list
            Names of the spike nodes
        &#34;&#34;&#34;

        return self._spikes_by_name.keys()

    def get_lfp_names(self):
        &#34;&#34;&#34;Gets the name of all the lfp nodes

        Parameters
        ----------
        None

        Returns
        -------
        list
            Names of the LFP nodes
        &#34;&#34;&#34;

        return self._lfp_by_name.keys()

    def change_names(self, old_names, new_names, node_type=&#39;spike&#39;):
        &#34;&#34;&#34;Changes the names of nodes. `old_names` should have the same length 
        as that of `new_length`

        Parameters
        ----------
        old_names : list of str
            List of the old names of nodes
        new_names : list of str
            List of the new names of nodes
        node_type
            Type of the data node

        Returns
        -------
        None
        &#34;&#34;&#34;

        if len(new_names) != len(old_names):
            logging.error(&#39;Input names are not equal in numbers!&#39;)
        elif len(set(new_names)) &lt; len(old_names):
            logging.error(&#39;Duplicate names are not allowed!&#39;)
        else:
            if node_type == &#39;spike&#39;:
                for i, name in enumerate(new_names):
                    node = self.get_spike(old_names[i])
                    node.set_name(name)
                    self._spikes_by_name[name] = self._spikes_by_name.pop(
                        old_names[i])

            elif node_type == &#39;lfp&#39;:
                for i, name in enumerate(new_names):
                    node = self.get_lfp(old_names[i])
                    node.set_name(name)
                    self._lfp_by_name[name] = self._spikes_by_name.pop(
                        old_names[i])

    def set_spike_names(self, names):
        &#34;&#34;&#34;Sets the names of the spike nodes. Old names are replaced

        Parameters
        ----------
        names : list of str
            List of new names of the spike nodes

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.change_names(self.get_spike_names(), names, &#39;lfp&#39;)

    def set_lfp_names(self, names):
        &#34;&#34;&#34;Sets the names of the lfp nodes. Old names are replaced.

        Parameters
        ----------
        names : list of str
            List of new names of the lfp nodes

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.change_names(self.get_lfp_names(), names, &#39;lfp&#39;)

    def set_node_file_names(self, node_names, filenames, node_type=&#39;spike&#39;):
        &#34;&#34;&#34;Sets the filenames for each data node. `node_names` must be of equal
        length to `filenames`

        Parameters
        ----------
        node_names : list of str
            Names of the nodes whose filenames are set
        filenames : list of str
            List of the filenames for each node
        node_type
            Type of the data node

        Returns
        -------
        None

        &#34;&#34;&#34;

        if len(node_names) != len(filenames):
            logging.error(&#39;No. of names does not match with no. of filenames&#39;)
        elif len(set(node_names)) != len(node_names):
            logging.error(&#39;Duplicate names are not allowed!&#39;)
        else:
            nodes = self.get_node(node_names, node_type)
            for node in nodes:
                node.set_filename(filenames(nodes.index(node)))

    def set_spike_file_names(self, spike_names, filenames):
        &#34;&#34;&#34;Sets the filenames for each data node. `spike_names` must be of equal
        length to `filenames`

        Parameters
        ----------
        spike_names : list of str
            Names of the spike nodes whose filenames are set
        filenames : list of str
            List of the filenames for each spike node

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.set_node_file_names(spike_names, filenames, &#39;spike&#39;)

    def set_lfp_file_names(self, lfp_names, filenames):
        &#34;&#34;&#34;Sets the filenames for each LFP data node. `lfp_names` must be of equal
        length to `filenames`

        Parameters
        ----------
        lfp_names : list of str
            Names of the lfp nodes whose filenames are set
        filenames : list of str
            List of the filenames for each lfp node

        Returns
        -------
        None

        &#34;&#34;&#34;

        self.set_node_file_names(lfp_names, filenames, &#39;lfp&#39;)

    def count_spike(self):
        &#34;&#34;&#34;Counts the number of spike nodes

        Parameters
        ----------
        None

        Returns
        -------
        int
            Total number of spike nodes
        &#34;&#34;&#34;
        return len(self._spikes)

    def count_lfp(self):
        &#34;&#34;&#34;Counts the number of lfp nodes

        Parameters
        ----------
        None

        Returns
        -------
        int
            Total number of lfp nodes
        &#34;&#34;&#34;
        return len(self._lfp)

    def _add_node(self, cls, node, node_type, **kwargs):
        &#34;&#34;&#34;Add a node of instance of class `cls` from `node` in the list of 
        `node_type`. Existing nodes can be replaced by input `replace= True` 

        Parameters
        ----------
        cls
            Class of node to be added
        node
            Either an object of `cls`or or a Class. If None, new instance of `cls`
            is added to the node list and returned
        node_type : str
            Type of the data node


        Returns
        -------

            Newly added data node

        See also
        --------
        add_node

        &#34;&#34;&#34;

        new_node = self._new_instance(node, **kwargs)
        self.add_node(new_node, node_type,
                      replace=kwargs.get(&#39;replace&#39;, False))

        return new_node

    def _get_instance(self, cls, node, node_type):
        &#34;&#34;&#34;Create a node of instance of class `cls` from `node` in the list of 
        `node_type`

        Parameters
        ----------
        cls
            Class of node to be added
        node
            Either an object of `cls`or or a Class. If None, new instance of `cls`
            is returned
        node_type : str
            Type of the data node

        Returns
        -------

            Newly added data node

        See also
        --------
        add_node

        &#34;&#34;&#34;
        if isinstance(node, cls):
            new_node = node
        else:
            if node_type == &#39;lfp&#39;:
                _get_node_names = self.get_lfp_names
                _get_node = self.get_lfp
            if node_type == &#39;spike&#39;:
                _get_node_names = self.get_spike_names
                _get_node = self.get_spike
            if node in _get_node_names():
                new_node = _get_node(node)

        return new_node</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="neurochat.nc_base.NAbstract" href="#neurochat.nc_base.NAbstract">NAbstract</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="neurochat.nc_spike.NSpike" href="nc_spike.html#neurochat.nc_spike.NSpike">NSpike</a></li>
<li><a title="neurochat.nc_clust.NClust" href="nc_clust.html#neurochat.nc_clust.NClust">NClust</a></li>
<li><a title="neurochat.nc_lfp.NLfp" href="nc_lfp.html#neurochat.nc_lfp.NLfp">NLfp</a></li>
<li><a title="neurochat.nc_event.NEvent" href="nc_event.html#neurochat.nc_event.NEvent">NEvent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="neurochat.nc_base.NBase.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node, node_type=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a new dataset, called node to the spike and LFP dataset arrays</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>Data node to be added</dd>
<dt><strong><code>node_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the dataset described in each class attributes</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keywrod arguments</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, node, node_type=None, **kwargs):
    &#34;&#34;&#34;Adds a new dataset, called node to the spike and LFP dataset arrays

    Parameters
    ----------
    node
        Data node to be added
    node_type : str
        Type of the dataset described in each class attributes
    **kwargs
        Keywrod arguments

    Returns
    -------
    None
    &#34;&#34;&#34;

    name = node.get_name()
    _replace = kwargs.get(&#39;replace&#39;, False)

    if node_type is None:
        logging.error(&#39;Node type is not defined&#39;)
    elif node_type == &#39;spike&#39;:
        node_names = self.get_spike_names()
        nodes = self._spikes
        nodesByName = self._spikes_by_name
    elif node_type == &#39;lfp&#39;:
        node_names = self.get_lfp_names()
        nodes = self._lfp
        nodesByName = self._lfp_by_name

    if _replace:
        i = self.del_node(node)
    elif name in node_names:
        logging.warning(node_type + &#39; with name {0} already exists, &#39;.format(name) +
                        &#39;cannot add another one.\r\n&#39; +
                        &#39;Try renaming or set replace True&#39;)
    else:
        i = len(nodes)

    nodes.insert(i, node)
    nodesByName[name] = node</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.change_names"><code class="name flex">
<span>def <span class="ident">change_names</span></span>(<span>self, old_names, new_names, node_type='spike')</span>
</code></dt>
<dd>
<section class="desc"><p>Changes the names of nodes. <code>old_names</code> should have the same length
as that of <code>new_length</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>old_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of the old names of nodes</dd>
<dt><strong><code>new_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of the new names of nodes</dd>
<dt><strong><code>node_type</code></strong></dt>
<dd>Type of the data node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def change_names(self, old_names, new_names, node_type=&#39;spike&#39;):
    &#34;&#34;&#34;Changes the names of nodes. `old_names` should have the same length 
    as that of `new_length`

    Parameters
    ----------
    old_names : list of str
        List of the old names of nodes
    new_names : list of str
        List of the new names of nodes
    node_type
        Type of the data node

    Returns
    -------
    None
    &#34;&#34;&#34;

    if len(new_names) != len(old_names):
        logging.error(&#39;Input names are not equal in numbers!&#39;)
    elif len(set(new_names)) &lt; len(old_names):
        logging.error(&#39;Duplicate names are not allowed!&#39;)
    else:
        if node_type == &#39;spike&#39;:
            for i, name in enumerate(new_names):
                node = self.get_spike(old_names[i])
                node.set_name(name)
                self._spikes_by_name[name] = self._spikes_by_name.pop(
                    old_names[i])

        elif node_type == &#39;lfp&#39;:
            for i, name in enumerate(new_names):
                node = self.get_lfp(old_names[i])
                node.set_name(name)
                self._lfp_by_name[name] = self._spikes_by_name.pop(
                    old_names[i])</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.count_lfp"><code class="name flex">
<span>def <span class="ident">count_lfp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Counts the number of lfp nodes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Total number of lfp nodes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def count_lfp(self):
    &#34;&#34;&#34;Counts the number of lfp nodes

    Parameters
    ----------
    None

    Returns
    -------
    int
        Total number of lfp nodes
    &#34;&#34;&#34;
    return len(self._lfp)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.count_spike"><code class="name flex">
<span>def <span class="ident">count_spike</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Counts the number of spike nodes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Total number of spike nodes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def count_spike(self):
    &#34;&#34;&#34;Counts the number of spike nodes

    Parameters
    ----------
    None

    Returns
    -------
    int
        Total number of spike nodes
    &#34;&#34;&#34;
    return len(self._spikes)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.del_lfp"><code class="name flex">
<span>def <span class="ident">del_lfp</span></span>(<span>self, lfp)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a node that represents LFP dataset</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lfp</code></strong></dt>
<dd>LFP node to be deleted by name or the object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Index of the deleted node</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def del_lfp(self, lfp):
    &#34;&#34;&#34;Deletes a node that represents LFP dataset

    Parameters
    ----------
    lfp
        LFP node to be deleted by name or the object

    Returns
    -------
    int
        Index of the deleted node
    &#34;&#34;&#34;

    i = 0
    if isinstance(lfp, str):
        name = lfp
        lfp = self.get_lfp(name)
    i = self.del_node(lfp)

    return i</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.del_node"><code class="name flex">
<span>def <span class="ident">del_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a node that represents spike or LFP dataset</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>Data node to be deleted</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Index of deleted node</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def del_node(self, node):
    &#34;&#34;&#34;Deletes a node that represents spike or LFP dataset

    Parameters
    ----------
    node
        Data node to be deleted

    Returns
    -------
    int
        Index of deleted node
    &#34;&#34;&#34;
    i = None
    if node in self._spikes:
        i = self._spikes.index(node)
        self._spikes.remove(node)
        del self._spikes_by_name[node.get_name()]
    elif node in self._lfp:
        i = self._lfp.index(node)
        self._lfp.remove(node)
        del self._lfp_by_name[node.get_name()]
    return i</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.del_spike"><code class="name flex">
<span>def <span class="ident">del_spike</span></span>(<span>self, spike)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a node that represents spike dataset</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spike</code></strong></dt>
<dd>Spike node to be deleted by name or the object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the deleted node</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def del_spike(self, spike):
    &#34;&#34;&#34;Deletes a node that represents spike dataset

    Parameters
    ----------
    spike
        Spike node to be deleted by name or the object

    Returns
    -------
    i : int
        Index of the deleted node
    &#34;&#34;&#34;

    if isinstance(spike, str):
        name = spike
        spike = self.get_spike(name)
    i = self.del_node(spike)

    return i</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.get_lfp"><code class="name flex">
<span>def <span class="ident">get_lfp</span></span>(<span>self, names=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the lfp nodes by name</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the names of the lfp nodes to obtain</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of the lfp nodes. Returns all the lfp nodes if <code>names</code> is None</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_lfp(self, names=None):
    &#34;&#34;&#34;Gets the lfp nodes by name

    Parameters
    ----------
    names : list
        List of the names of the lfp nodes to obtain

    Returns
    -------
    list
        List of the lfp nodes. Returns all the lfp nodes if `names` is None 
    &#34;&#34;&#34;

    if names is None:
        lfp = self._lfp
    else:
        lfp = self.get_node(names, &#39;lfp&#39;)
    return lfp</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.get_lfp_names"><code class="name flex">
<span>def <span class="ident">get_lfp_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the name of all the lfp nodes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Names of the LFP nodes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_lfp_names(self):
    &#34;&#34;&#34;Gets the name of all the lfp nodes

    Parameters
    ----------
    None

    Returns
    -------
    list
        Names of the LFP nodes
    &#34;&#34;&#34;

    return self._lfp_by_name.keys()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>self, node_names, node_type='spike')</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the nodes by name and dataset type</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the names of the data nodes to obtain</dd>
<dt><strong><code>node_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the data node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of the data nodes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_node(self, node_names, node_type=&#39;spike&#39;):
    &#34;&#34;&#34;Gets the nodes by name and dataset type

    Parameters
    ----------
    node_names : list
        List of the names of the data nodes to obtain
    node_type : str
        Type of the data node

    Returns
    -------
    list
        List of the data nodes 
    &#34;&#34;&#34;

    nodes = []
    not_nodes = []
    if node_type == &#39;spike&#39;:
        names = self.get_spike_names()
        nodes = self._spikes_by_name
    elif node_type == &#39;lfp&#39;:
        names = self.get_lfp_names()
        nodes = self._lfp_by_name
    for name in node_names:
        nodes.append(nodes[name]) if name in names\
            else not_nodes.append(name)
    if not_nodes:
        logging.warning(&#39;,&#39;.join(not_nodes) + &#39; does not exist&#39;)
    return nodes</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.get_spike"><code class="name flex">
<span>def <span class="ident">get_spike</span></span>(<span>self, names=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the spike nodes by name</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the names of the spike nodes to obtain</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of the spike nodes. Returns all the spike nodes if <code>names</code> is None</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_spike(self, names=None):
    &#34;&#34;&#34;Gets the spike nodes by name

    Parameters
    ----------
    names : list
        List of the names of the spike nodes to obtain

    Returns
    -------
    list
        List of the spike nodes. Returns all the spike nodes if `names` is None 
    &#34;&#34;&#34;

    if names is None:
        spikes = self._spikes
    else:
        spikes = self.get_node(names, &#39;spike&#39;)
    return spikes</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.get_spike_names"><code class="name flex">
<span>def <span class="ident">get_spike_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the names of all the spike nodes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Names of the spike nodes</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_spike_names(self):
    &#34;&#34;&#34;Gets the names of all the spike nodes

    Parameters
    ----------
    None

    Returns
    -------
    list
        Names of the spike nodes
    &#34;&#34;&#34;

    return self._spikes_by_name.keys()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.set_lfp_file_names"><code class="name flex">
<span>def <span class="ident">set_lfp_file_names</span></span>(<span>self, lfp_names, filenames)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the filenames for each LFP data node. <code>lfp_names</code> must be of equal
length to <code>filenames</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lfp_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Names of the lfp nodes whose filenames are set</dd>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of the filenames for each lfp node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_lfp_file_names(self, lfp_names, filenames):
    &#34;&#34;&#34;Sets the filenames for each LFP data node. `lfp_names` must be of equal
    length to `filenames`

    Parameters
    ----------
    lfp_names : list of str
        Names of the lfp nodes whose filenames are set
    filenames : list of str
        List of the filenames for each lfp node

    Returns
    -------
    None

    &#34;&#34;&#34;

    self.set_node_file_names(lfp_names, filenames, &#39;lfp&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.set_lfp_names"><code class="name flex">
<span>def <span class="ident">set_lfp_names</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the names of the lfp nodes. Old names are replaced.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of new names of the lfp nodes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_lfp_names(self, names):
    &#34;&#34;&#34;Sets the names of the lfp nodes. Old names are replaced.

    Parameters
    ----------
    names : list of str
        List of new names of the lfp nodes

    Returns
    -------
    None

    &#34;&#34;&#34;

    self.change_names(self.get_lfp_names(), names, &#39;lfp&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.set_node_file_names"><code class="name flex">
<span>def <span class="ident">set_node_file_names</span></span>(<span>self, node_names, filenames, node_type='spike')</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the filenames for each data node. <code>node_names</code> must be of equal
length to <code>filenames</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Names of the nodes whose filenames are set</dd>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of the filenames for each node</dd>
<dt><strong><code>node_type</code></strong></dt>
<dd>Type of the data node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_node_file_names(self, node_names, filenames, node_type=&#39;spike&#39;):
    &#34;&#34;&#34;Sets the filenames for each data node. `node_names` must be of equal
    length to `filenames`

    Parameters
    ----------
    node_names : list of str
        Names of the nodes whose filenames are set
    filenames : list of str
        List of the filenames for each node
    node_type
        Type of the data node

    Returns
    -------
    None

    &#34;&#34;&#34;

    if len(node_names) != len(filenames):
        logging.error(&#39;No. of names does not match with no. of filenames&#39;)
    elif len(set(node_names)) != len(node_names):
        logging.error(&#39;Duplicate names are not allowed!&#39;)
    else:
        nodes = self.get_node(node_names, node_type)
        for node in nodes:
            node.set_filename(filenames(nodes.index(node)))</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.set_spike_file_names"><code class="name flex">
<span>def <span class="ident">set_spike_file_names</span></span>(<span>self, spike_names, filenames)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the filenames for each data node. <code>spike_names</code> must be of equal
length to <code>filenames</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spike_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Names of the spike nodes whose filenames are set</dd>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of the filenames for each spike node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_spike_file_names(self, spike_names, filenames):
    &#34;&#34;&#34;Sets the filenames for each data node. `spike_names` must be of equal
    length to `filenames`

    Parameters
    ----------
    spike_names : list of str
        Names of the spike nodes whose filenames are set
    filenames : list of str
        List of the filenames for each spike node

    Returns
    -------
    None

    &#34;&#34;&#34;

    self.set_node_file_names(spike_names, filenames, &#39;spike&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_base.NBase.set_spike_names"><code class="name flex">
<span>def <span class="ident">set_spike_names</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the names of the spike nodes. Old names are replaced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of new names of the spike nodes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_spike_names(self, names):
    &#34;&#34;&#34;Sets the names of the spike nodes. Old names are replaced

    Parameters
    ----------
    names : list of str
        List of new names of the spike nodes

    Returns
    -------
    None

    &#34;&#34;&#34;

    self.change_names(self.get_spike_names(), names, &#39;lfp&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="neurochat.nc_base.NAbstract" href="#neurochat.nc_base.NAbstract">NAbstract</a></b></code>:
<ul class="hlist">
<li><code><a title="neurochat.nc_base.NAbstract.get_comments" href="#neurochat.nc_base.NAbstract.get_comments">get_comments</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_data_source" href="#neurochat.nc_base.NAbstract.get_data_source">get_data_source</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_date" href="#neurochat.nc_base.NAbstract.get_date">get_date</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_duration" href="#neurochat.nc_base.NAbstract.get_duration">get_duration</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_experimenter" href="#neurochat.nc_base.NAbstract.get_experimenter">get_experimenter</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_file_version" href="#neurochat.nc_base.NAbstract.get_file_version">get_file_version</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_filename" href="#neurochat.nc_base.NAbstract.get_filename">get_filename</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_name" href="#neurochat.nc_base.NAbstract.get_name">get_name</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_record_info" href="#neurochat.nc_base.NAbstract.get_record_info">get_record_info</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_results" href="#neurochat.nc_base.NAbstract.get_results">get_results</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_source_format" href="#neurochat.nc_base.NAbstract.get_source_format">get_source_format</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_system" href="#neurochat.nc_base.NAbstract.get_system">get_system</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_time" href="#neurochat.nc_base.NAbstract.get_time">get_time</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_type" href="#neurochat.nc_base.NAbstract.get_type">get_type</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.load" href="#neurochat.nc_base.NAbstract.load">load</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.reset_results" href="#neurochat.nc_base.NAbstract.reset_results">reset_results</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.save_to_hdf5" href="#neurochat.nc_base.NAbstract.save_to_hdf5">save_to_hdf5</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_description" href="#neurochat.nc_base.NAbstract.set_description">set_description</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_filename" href="#neurochat.nc_base.NAbstract.set_filename">set_filename</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_name" href="#neurochat.nc_base.NAbstract.set_name">set_name</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_record_info" href="#neurochat.nc_base.NAbstract.set_record_info">set_record_info</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_system" href="#neurochat.nc_base.NAbstract.set_system">set_system</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.update_result" href="#neurochat.nc_base.NAbstract.update_result">update_result</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neurochat" href="index.html">neurochat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="neurochat.nc_base.NAbstract" href="#neurochat.nc_base.NAbstract">NAbstract</a></code></h4>
<ul class="two-column">
<li><code><a title="neurochat.nc_base.NAbstract.get_comments" href="#neurochat.nc_base.NAbstract.get_comments">get_comments</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_data_source" href="#neurochat.nc_base.NAbstract.get_data_source">get_data_source</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_date" href="#neurochat.nc_base.NAbstract.get_date">get_date</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_duration" href="#neurochat.nc_base.NAbstract.get_duration">get_duration</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_experimenter" href="#neurochat.nc_base.NAbstract.get_experimenter">get_experimenter</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_file_version" href="#neurochat.nc_base.NAbstract.get_file_version">get_file_version</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_filename" href="#neurochat.nc_base.NAbstract.get_filename">get_filename</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_name" href="#neurochat.nc_base.NAbstract.get_name">get_name</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_record_info" href="#neurochat.nc_base.NAbstract.get_record_info">get_record_info</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_results" href="#neurochat.nc_base.NAbstract.get_results">get_results</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_source_format" href="#neurochat.nc_base.NAbstract.get_source_format">get_source_format</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_system" href="#neurochat.nc_base.NAbstract.get_system">get_system</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_time" href="#neurochat.nc_base.NAbstract.get_time">get_time</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.get_type" href="#neurochat.nc_base.NAbstract.get_type">get_type</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.load" href="#neurochat.nc_base.NAbstract.load">load</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.reset_results" href="#neurochat.nc_base.NAbstract.reset_results">reset_results</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.save_to_hdf5" href="#neurochat.nc_base.NAbstract.save_to_hdf5">save_to_hdf5</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_description" href="#neurochat.nc_base.NAbstract.set_description">set_description</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_filename" href="#neurochat.nc_base.NAbstract.set_filename">set_filename</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_name" href="#neurochat.nc_base.NAbstract.set_name">set_name</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_record_info" href="#neurochat.nc_base.NAbstract.set_record_info">set_record_info</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.set_system" href="#neurochat.nc_base.NAbstract.set_system">set_system</a></code></li>
<li><code><a title="neurochat.nc_base.NAbstract.update_result" href="#neurochat.nc_base.NAbstract.update_result">update_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="neurochat.nc_base.NBase" href="#neurochat.nc_base.NBase">NBase</a></code></h4>
<ul class="">
<li><code><a title="neurochat.nc_base.NBase.add_node" href="#neurochat.nc_base.NBase.add_node">add_node</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.change_names" href="#neurochat.nc_base.NBase.change_names">change_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.count_lfp" href="#neurochat.nc_base.NBase.count_lfp">count_lfp</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.count_spike" href="#neurochat.nc_base.NBase.count_spike">count_spike</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.del_lfp" href="#neurochat.nc_base.NBase.del_lfp">del_lfp</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.del_node" href="#neurochat.nc_base.NBase.del_node">del_node</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.del_spike" href="#neurochat.nc_base.NBase.del_spike">del_spike</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_lfp" href="#neurochat.nc_base.NBase.get_lfp">get_lfp</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_lfp_names" href="#neurochat.nc_base.NBase.get_lfp_names">get_lfp_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_node" href="#neurochat.nc_base.NBase.get_node">get_node</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_spike" href="#neurochat.nc_base.NBase.get_spike">get_spike</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.get_spike_names" href="#neurochat.nc_base.NBase.get_spike_names">get_spike_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_lfp_file_names" href="#neurochat.nc_base.NBase.set_lfp_file_names">set_lfp_file_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_lfp_names" href="#neurochat.nc_base.NBase.set_lfp_names">set_lfp_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_node_file_names" href="#neurochat.nc_base.NBase.set_node_file_names">set_node_file_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_spike_file_names" href="#neurochat.nc_base.NBase.set_spike_file_names">set_spike_file_names</a></code></li>
<li><code><a title="neurochat.nc_base.NBase.set_spike_names" href="#neurochat.nc_base.NBase.set_spike_names">set_spike_names</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>