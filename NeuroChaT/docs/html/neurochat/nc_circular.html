<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>neurochat.nc_circular API documentation</title>
<meta name="description" content="This module implements CircStat Class for NeuroChaT software â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neurochat.nc_circular</code></h1>
</header>
<section id="section-intro">
<p>This module implements CircStat Class for NeuroChaT software</p>
<p>@author: Md Nurul Islam; islammn at tcd dot ie</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module implements CircStat Class for NeuroChaT software

@author: Md Nurul Islam; islammn at tcd dot ie

&#34;&#34;&#34;

import logging
from collections import OrderedDict as oDict

import numpy as np

from neurochat.nc_utils import find


class CircStat(object):
    &#34;&#34;&#34;
    This class is the placeholder for the circular data and provides functionalities
    for calculating circular statistics.

    &#34;&#34;&#34;

    def __init__(self, **kwargs):  # Currently supports &#39;deg&#39;. Will be extended for &#39;rad&#39;
        self._rho = kwargs.get(&#39;rho&#39;, None)
        self._theta = kwargs.get(&#39;theta&#39;, None)
        self._result = oDict()

    def set_rho(self, rho=None):
        &#34;&#34;&#34;
        Sets the radial coordinates (rho) of the circular data

        Parameters
        ----------
        rho : ndarray
            Radial coordinates of the circular data

        Returns
        -------
        None

        &#34;&#34;&#34;

        if rho is not None:
            self._rho = rho

    def get_rho(self):
        &#34;&#34;&#34;
        Returns the radial coordinates (rho) of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            Radial coordinates of the circular data

        &#34;&#34;&#34;

        return self._rho

    def set_theta(self, theta=None):
        &#34;&#34;&#34;
        Sets the angular coordinates (theta) of the circular data in degrees.

        Parameters
        ----------
        theta : ndarray
            Angular coordinates of the circular data

        Returns
        -------
        None

        &#34;&#34;&#34;

        if theta is not None:
            self._theta = theta

    def get_theta(self):
        &#34;&#34;&#34;
        Returns the angular coordinates (theta) of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            Angular coordinates of the circular data

        &#34;&#34;&#34;

        return self._theta

    def get_mean_std(self):
        &#34;&#34;&#34;
        Returns the circular mean, standard deviation and resultant vector length of the data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Dictionary of mean, standard deviation and resultant vector length etc.

        &#34;&#34;&#34;

        if self._rho is None or not len(self._rho):
            self._rho = np.ones(self._theta.shape)
        return self._calc_mean_std()

    def _calc_mean_std(self):
        &#34;&#34;&#34;
        Returns the circular mean, standard deviation and resultant vector length of the data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Dictionary of mean, standard deviation and resultant vector length etc.

        &#34;&#34;&#34;

        result = {}
        if self._rho.shape[0] == self._theta.shape[0]:
            xm = np.sum(np.multiply(
                self._rho, np.cos(self._theta * np.pi / 180)))
            ym = np.sum(np.multiply(
                self._rho, np.sin(self._theta * np.pi / 180)))
            meanTheta = np.arctan2(ym, xm) * 180 / np.pi
            if meanTheta &lt; 0:
                meanTheta = meanTheta + 360
            meanRho = np.sqrt(xm**2 + ym**2)
            result[&#39;meanTheta&#39;] = meanTheta
            result[&#39;meanRho&#39;] = meanRho
            result[&#39;totalObs&#39;] = np.sum(self._rho)
            result[&#39;resultant&#39;] = meanRho / result[&#39;totalObs&#39;]
            try:
                x = -2 * np.log(result[&#39;resultant&#39;])
                if x &lt; 0:
                    result[&#39;stdRho&#39;] = 0
                else:
                    result[&#39;stdRho&#39;] = np.sqrt(x)
            except:
                result[&#39;stdRho&#39;] = 0  # This except to proetct -ve inside sqrt

        else:
            logging.warning(&#39;Size of rho and theta must be equal&#39;)

        return result

    def get_rayl_stat(self):
        &#34;&#34;&#34;
        Returns the Rayleigh Z statistics of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Rayleigh Z statistics

        &#34;&#34;&#34;

        return self._rayl_stat()

    def _rayl_stat(self):
        &#34;&#34;&#34;
        Returns the Rayleigh Z statistics of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Rayleigh Z statistics

        &#34;&#34;&#34;

        result = {}
        N = self._result[&#39;totalObs&#39;]
        Rn = self._result[&#39;resultant&#39;] * N
        result[&#39;RaylZ&#39;] = Rn**2 / N
        result[&#39;RaylP&#39;] = np.exp(
            np.sqrt(1 + 4 * N + 4 * (N**2 - Rn**2)) - (1 + 2 * N))

        return result

    def get_vonmises_stat(self):
        &#34;&#34;&#34;
        Returns the von Mises concentration parameter kappa

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Returns the von Mises concentration parameter kappa

        &#34;&#34;&#34;

        return self._vonmises_stat()

    def _vonmises_stat(self):
        &#34;&#34;&#34;
        Returns the von Mises concentration parameter kappa

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Returns the von Mises concentration parameter kappa

        &#34;&#34;&#34;

        result = {}
        R = self._result[&#39;resultant&#39;]
        N = self._result[&#39;totalObs&#39;]

        if R &lt; 0.53:
            kappa = 2 * R + R**3 + 5 * (R**5) / 6
        elif R &lt;= 0.53 and R &lt; 0.85:
            kappa = -0.4 + 1.39 * R + 0.43 / (1 - R)
        else:
            kappa = 1 / (R**3 - 4 * R**2 + 3 * R)

        if N &lt; 15 and N &gt; 1:
            kappa = max(kappa - 2 * (N * kappa)**-1,
                        0) if kappa &lt; 2 else kappa * (N - 1)**3 / (N**3 + N)

        result[&#39;vonMisesK&#39;] = kappa
        return result

    def calc_stat(self):
        &#34;&#34;&#34;
        Calculates and returns all the circular statistics parameters

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Returns the von Mises concentration parameter kappa

        &#34;&#34;&#34;

        result = self._calc_mean_std()
        self._update_result(result)
        result = self._rayl_stat()
        self._update_result(result)
        result = self._vonmises_stat()
        self._update_result(result)

        return self.get_result()

    @staticmethod
    # Example, x = [270, 340, 350, 20, 40], y = [270, 340, 350, 380, 400] etc.
    def circ_regroup(x):
        &#34;&#34;&#34;
        Circular regrouping of the angles. It unwraps the angular coordinates.
        For example, if the input array is x = np.ndarray([270, 340, 350, 20, 40]),
        the output will be y = [270, 340, 350, 380, 400] etc.

        Parameters
        ----------
        x : ndarray
            Array containg the angular coordinates

        Returns
        -------
        y : ndarray
            Regrouped or unwrapped angular coordinates

        &#34;&#34;&#34;

        y = np.copy(x)
        if any(np.logical_and(x &gt;= 0, x &lt;= 90)) and any(np.logical_and(x &gt;= 180, x &lt;= 360)):
            y[np.logical_and(x &gt;= 0, x &lt;= 90)] = x[np.logical_and(
                x &gt;= 0, x &lt;= 90)] + 360

        return y

    def circ_histogram(self, bins=5):
        &#34;&#34;&#34;
        Calculates the circular histogram of the angular coordinates 

        Parameters
        ----------
        bins : int
            Angular binsize for the circular histogram

        Returns
        -------
        count : ndarray
            Histogram bin count
        ind : ndarray
            Indices of the bins to which each value in input array belongs. Similar to
            the return values of the numpy.digitize function.
        bins : ndarray
            Histogram bins

        &#34;&#34;&#34;

        if isinstance(bins, int):
            bins = np.arange(0, 360, bins)

        nbins = bins.shape[0]
        count = np.zeros(bins.shape)
        ind = np.zeros(self._theta.shape, dtype=int)
        for i in np.arange(nbins):
            if i &lt; nbins - 1:
                ind[np.logical_and(self._theta &gt;= bins[i],
                                   self._theta &lt; bins[i + 1])] = i
                count[i] = np.sum(np.logical_and(
                    self._theta &gt;= bins[i], self._theta &lt; bins[i + 1]))

            elif i == nbins - 1:
                ind[np.logical_or(self._theta &gt;= bins[i],
                                  self._theta &lt; bins[0])] = i
                count[i] = np.sum(np.logical_or(
                    self._theta &gt;= bins[i], self._theta &lt; bins[0]))

        return count, ind, bins

    def circ_smooth(self, filttype=&#39;b&#39;, filtsize=5):
        &#34;&#34;&#34;
        Calculates the circular average of theta with each sample replaced by the circular 
        mean of length &#39;filtsize&#39; and weights determined by the type of filter.

        Parameters
        ----------
        filttype : str
            Type of smoothing filter. &#39;b&#39; for Box filter, &#39;g&#39; for Gaussian filter
        filtsize : int
            Length of the averaging filter

        Returns
        -------
        smooth_theta : ndarray
            Theta values after the smoothing

        &#34;&#34;&#34;

        if filttype == &#39;g&#39;:
            halfwid = np.round(3 * filtsize)
            xx = np.arange(-halfwid, halfwid + 1, 1)
            filt = np.exp(-(xx**2) / (2 * filtsize**2)) / \
                (np.sqrt(2 * np.pi) * filtsize)
        elif filttype == &#39;b&#39;:
            filt = np.ones(filtsize, ) / filtsize

        cs = CircStat()

        smooth_theta = np.zeros(self._theta.shape)
        N = self._theta.shape[0]
        L = filt.shape[0]
        l = int(np.floor(L / 2))
        for i in np.arange(l):
            cs.set_rho(filt[l - i:])
            cs.set_theta(self.circ_regroup(self._theta[:L - l + i]))
            csResult = cs.get_mean_std()
            smooth_theta[i] = csResult[&#39;meanTheta&#39;]
        for i in np.arange(l, N - l, 1):
            cs.set_rho(filt)
            cs.set_theta(self.circ_regroup(self._theta[i - l:i + l + 1]))
            csResult = cs.get_mean_std()
            smooth_theta[i] = csResult[&#39;meanTheta&#39;]
        for i in np.arange(N - l, N):
            cs.set_theta(self.circ_regroup(self._theta[i - l:]))
            cs.set_rho(filt[:len(self._theta[i - l:])])
            csResult = cs.get_mean_std()
            smooth_theta[i] = csResult[&#39;meanTheta&#39;]

        return smooth_theta

    def circ_scatter(self, bins=2, step=0.05, rmax=None):
        &#34;&#34;&#34;
        Prepares data for circular scatter plot. For each theta in a bin, the radius
        is increased by &#39;step&#39; size capped at &#39;rmax&#39;.

        Parameters
        ----------
        bins : int
            Angular binsize for the circular scatter
        step : float
            Stepsize to increase the radius for each count of theta
        rmax : float
            Maximum value for the radius

        Returns
        -------
        radius : ndarray
            Radius for the theta values. For each new theta in a bin, the radius
            is increased by &#39;step&#39; size.
        theta : ndarray
            Binned theta samples

        &#34;&#34;&#34;
        # Prepares the data for scatter plot.
        count, ind, bins = self.circ_histogram(bins=2)
        radius = np.ones(ind.shape)
        theta = np.zeros(ind.shape)
        for i, b in enumerate(bins):
            rad = (
                np.ones(find(ind == i).shape) +
                np.array(
                    list(step * j for j, loc in enumerate(find(ind == i)))
                )
            )
            if rmax:
                rad[rad &gt; rmax] = rmax
            radius[ind == i] = rad
            theta[ind == i] = b

        return radius, theta

    def _update_result(self, new_result={}):
        &#34;&#34;&#34;
        Updates the statistical results withe a new one.

        Parameters
        ----------
        new_results : dict
            Dictionary of the circular statistics analyses

        Returns
        -------
        None

        &#34;&#34;&#34;

        self._result.update(new_result)

    def get_result(self):
        &#34;&#34;&#34;
        Resturns the results of the circular statistics analyses

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Results of the circular statistics analyses

        &#34;&#34;&#34;
        return self._result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="neurochat.nc_circular.CircStat"><code class="flex name class">
<span>class <span class="ident">CircStat</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This class is the placeholder for the circular data and provides functionalities
for calculating circular statistics.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CircStat(object):
    &#34;&#34;&#34;
    This class is the placeholder for the circular data and provides functionalities
    for calculating circular statistics.

    &#34;&#34;&#34;

    def __init__(self, **kwargs):  # Currently supports &#39;deg&#39;. Will be extended for &#39;rad&#39;
        self._rho = kwargs.get(&#39;rho&#39;, None)
        self._theta = kwargs.get(&#39;theta&#39;, None)
        self._result = oDict()

    def set_rho(self, rho=None):
        &#34;&#34;&#34;
        Sets the radial coordinates (rho) of the circular data

        Parameters
        ----------
        rho : ndarray
            Radial coordinates of the circular data

        Returns
        -------
        None

        &#34;&#34;&#34;

        if rho is not None:
            self._rho = rho

    def get_rho(self):
        &#34;&#34;&#34;
        Returns the radial coordinates (rho) of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            Radial coordinates of the circular data

        &#34;&#34;&#34;

        return self._rho

    def set_theta(self, theta=None):
        &#34;&#34;&#34;
        Sets the angular coordinates (theta) of the circular data in degrees.

        Parameters
        ----------
        theta : ndarray
            Angular coordinates of the circular data

        Returns
        -------
        None

        &#34;&#34;&#34;

        if theta is not None:
            self._theta = theta

    def get_theta(self):
        &#34;&#34;&#34;
        Returns the angular coordinates (theta) of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            Angular coordinates of the circular data

        &#34;&#34;&#34;

        return self._theta

    def get_mean_std(self):
        &#34;&#34;&#34;
        Returns the circular mean, standard deviation and resultant vector length of the data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Dictionary of mean, standard deviation and resultant vector length etc.

        &#34;&#34;&#34;

        if self._rho is None or not len(self._rho):
            self._rho = np.ones(self._theta.shape)
        return self._calc_mean_std()

    def _calc_mean_std(self):
        &#34;&#34;&#34;
        Returns the circular mean, standard deviation and resultant vector length of the data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Dictionary of mean, standard deviation and resultant vector length etc.

        &#34;&#34;&#34;

        result = {}
        if self._rho.shape[0] == self._theta.shape[0]:
            xm = np.sum(np.multiply(
                self._rho, np.cos(self._theta * np.pi / 180)))
            ym = np.sum(np.multiply(
                self._rho, np.sin(self._theta * np.pi / 180)))
            meanTheta = np.arctan2(ym, xm) * 180 / np.pi
            if meanTheta &lt; 0:
                meanTheta = meanTheta + 360
            meanRho = np.sqrt(xm**2 + ym**2)
            result[&#39;meanTheta&#39;] = meanTheta
            result[&#39;meanRho&#39;] = meanRho
            result[&#39;totalObs&#39;] = np.sum(self._rho)
            result[&#39;resultant&#39;] = meanRho / result[&#39;totalObs&#39;]
            try:
                x = -2 * np.log(result[&#39;resultant&#39;])
                if x &lt; 0:
                    result[&#39;stdRho&#39;] = 0
                else:
                    result[&#39;stdRho&#39;] = np.sqrt(x)
            except:
                result[&#39;stdRho&#39;] = 0  # This except to proetct -ve inside sqrt

        else:
            logging.warning(&#39;Size of rho and theta must be equal&#39;)

        return result

    def get_rayl_stat(self):
        &#34;&#34;&#34;
        Returns the Rayleigh Z statistics of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Rayleigh Z statistics

        &#34;&#34;&#34;

        return self._rayl_stat()

    def _rayl_stat(self):
        &#34;&#34;&#34;
        Returns the Rayleigh Z statistics of the circular data

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Rayleigh Z statistics

        &#34;&#34;&#34;

        result = {}
        N = self._result[&#39;totalObs&#39;]
        Rn = self._result[&#39;resultant&#39;] * N
        result[&#39;RaylZ&#39;] = Rn**2 / N
        result[&#39;RaylP&#39;] = np.exp(
            np.sqrt(1 + 4 * N + 4 * (N**2 - Rn**2)) - (1 + 2 * N))

        return result

    def get_vonmises_stat(self):
        &#34;&#34;&#34;
        Returns the von Mises concentration parameter kappa

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Returns the von Mises concentration parameter kappa

        &#34;&#34;&#34;

        return self._vonmises_stat()

    def _vonmises_stat(self):
        &#34;&#34;&#34;
        Returns the von Mises concentration parameter kappa

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Returns the von Mises concentration parameter kappa

        &#34;&#34;&#34;

        result = {}
        R = self._result[&#39;resultant&#39;]
        N = self._result[&#39;totalObs&#39;]

        if R &lt; 0.53:
            kappa = 2 * R + R**3 + 5 * (R**5) / 6
        elif R &lt;= 0.53 and R &lt; 0.85:
            kappa = -0.4 + 1.39 * R + 0.43 / (1 - R)
        else:
            kappa = 1 / (R**3 - 4 * R**2 + 3 * R)

        if N &lt; 15 and N &gt; 1:
            kappa = max(kappa - 2 * (N * kappa)**-1,
                        0) if kappa &lt; 2 else kappa * (N - 1)**3 / (N**3 + N)

        result[&#39;vonMisesK&#39;] = kappa
        return result

    def calc_stat(self):
        &#34;&#34;&#34;
        Calculates and returns all the circular statistics parameters

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Returns the von Mises concentration parameter kappa

        &#34;&#34;&#34;

        result = self._calc_mean_std()
        self._update_result(result)
        result = self._rayl_stat()
        self._update_result(result)
        result = self._vonmises_stat()
        self._update_result(result)

        return self.get_result()

    @staticmethod
    # Example, x = [270, 340, 350, 20, 40], y = [270, 340, 350, 380, 400] etc.
    def circ_regroup(x):
        &#34;&#34;&#34;
        Circular regrouping of the angles. It unwraps the angular coordinates.
        For example, if the input array is x = np.ndarray([270, 340, 350, 20, 40]),
        the output will be y = [270, 340, 350, 380, 400] etc.

        Parameters
        ----------
        x : ndarray
            Array containg the angular coordinates

        Returns
        -------
        y : ndarray
            Regrouped or unwrapped angular coordinates

        &#34;&#34;&#34;

        y = np.copy(x)
        if any(np.logical_and(x &gt;= 0, x &lt;= 90)) and any(np.logical_and(x &gt;= 180, x &lt;= 360)):
            y[np.logical_and(x &gt;= 0, x &lt;= 90)] = x[np.logical_and(
                x &gt;= 0, x &lt;= 90)] + 360

        return y

    def circ_histogram(self, bins=5):
        &#34;&#34;&#34;
        Calculates the circular histogram of the angular coordinates 

        Parameters
        ----------
        bins : int
            Angular binsize for the circular histogram

        Returns
        -------
        count : ndarray
            Histogram bin count
        ind : ndarray
            Indices of the bins to which each value in input array belongs. Similar to
            the return values of the numpy.digitize function.
        bins : ndarray
            Histogram bins

        &#34;&#34;&#34;

        if isinstance(bins, int):
            bins = np.arange(0, 360, bins)

        nbins = bins.shape[0]
        count = np.zeros(bins.shape)
        ind = np.zeros(self._theta.shape, dtype=int)
        for i in np.arange(nbins):
            if i &lt; nbins - 1:
                ind[np.logical_and(self._theta &gt;= bins[i],
                                   self._theta &lt; bins[i + 1])] = i
                count[i] = np.sum(np.logical_and(
                    self._theta &gt;= bins[i], self._theta &lt; bins[i + 1]))

            elif i == nbins - 1:
                ind[np.logical_or(self._theta &gt;= bins[i],
                                  self._theta &lt; bins[0])] = i
                count[i] = np.sum(np.logical_or(
                    self._theta &gt;= bins[i], self._theta &lt; bins[0]))

        return count, ind, bins

    def circ_smooth(self, filttype=&#39;b&#39;, filtsize=5):
        &#34;&#34;&#34;
        Calculates the circular average of theta with each sample replaced by the circular 
        mean of length &#39;filtsize&#39; and weights determined by the type of filter.

        Parameters
        ----------
        filttype : str
            Type of smoothing filter. &#39;b&#39; for Box filter, &#39;g&#39; for Gaussian filter
        filtsize : int
            Length of the averaging filter

        Returns
        -------
        smooth_theta : ndarray
            Theta values after the smoothing

        &#34;&#34;&#34;

        if filttype == &#39;g&#39;:
            halfwid = np.round(3 * filtsize)
            xx = np.arange(-halfwid, halfwid + 1, 1)
            filt = np.exp(-(xx**2) / (2 * filtsize**2)) / \
                (np.sqrt(2 * np.pi) * filtsize)
        elif filttype == &#39;b&#39;:
            filt = np.ones(filtsize, ) / filtsize

        cs = CircStat()

        smooth_theta = np.zeros(self._theta.shape)
        N = self._theta.shape[0]
        L = filt.shape[0]
        l = int(np.floor(L / 2))
        for i in np.arange(l):
            cs.set_rho(filt[l - i:])
            cs.set_theta(self.circ_regroup(self._theta[:L - l + i]))
            csResult = cs.get_mean_std()
            smooth_theta[i] = csResult[&#39;meanTheta&#39;]
        for i in np.arange(l, N - l, 1):
            cs.set_rho(filt)
            cs.set_theta(self.circ_regroup(self._theta[i - l:i + l + 1]))
            csResult = cs.get_mean_std()
            smooth_theta[i] = csResult[&#39;meanTheta&#39;]
        for i in np.arange(N - l, N):
            cs.set_theta(self.circ_regroup(self._theta[i - l:]))
            cs.set_rho(filt[:len(self._theta[i - l:])])
            csResult = cs.get_mean_std()
            smooth_theta[i] = csResult[&#39;meanTheta&#39;]

        return smooth_theta

    def circ_scatter(self, bins=2, step=0.05, rmax=None):
        &#34;&#34;&#34;
        Prepares data for circular scatter plot. For each theta in a bin, the radius
        is increased by &#39;step&#39; size capped at &#39;rmax&#39;.

        Parameters
        ----------
        bins : int
            Angular binsize for the circular scatter
        step : float
            Stepsize to increase the radius for each count of theta
        rmax : float
            Maximum value for the radius

        Returns
        -------
        radius : ndarray
            Radius for the theta values. For each new theta in a bin, the radius
            is increased by &#39;step&#39; size.
        theta : ndarray
            Binned theta samples

        &#34;&#34;&#34;
        # Prepares the data for scatter plot.
        count, ind, bins = self.circ_histogram(bins=2)
        radius = np.ones(ind.shape)
        theta = np.zeros(ind.shape)
        for i, b in enumerate(bins):
            rad = (
                np.ones(find(ind == i).shape) +
                np.array(
                    list(step * j for j, loc in enumerate(find(ind == i)))
                )
            )
            if rmax:
                rad[rad &gt; rmax] = rmax
            radius[ind == i] = rad
            theta[ind == i] = b

        return radius, theta

    def _update_result(self, new_result={}):
        &#34;&#34;&#34;
        Updates the statistical results withe a new one.

        Parameters
        ----------
        new_results : dict
            Dictionary of the circular statistics analyses

        Returns
        -------
        None

        &#34;&#34;&#34;

        self._result.update(new_result)

    def get_result(self):
        &#34;&#34;&#34;
        Resturns the results of the circular statistics analyses

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Results of the circular statistics analyses

        &#34;&#34;&#34;
        return self._result</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="neurochat.nc_circular.CircStat.circ_regroup"><code class="name flex">
<span>def <span class="ident">circ_regroup</span></span>(<span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Circular regrouping of the angles. It unwraps the angular coordinates.
For example, if the input array is x = np.ndarray([270, 340, 350, 20, 40]),
the output will be y = [270, 340, 350, 380, 400] etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array containg the angular coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Regrouped or unwrapped angular coordinates</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
# Example, x = [270, 340, 350, 20, 40], y = [270, 340, 350, 380, 400] etc.
def circ_regroup(x):
    &#34;&#34;&#34;
    Circular regrouping of the angles. It unwraps the angular coordinates.
    For example, if the input array is x = np.ndarray([270, 340, 350, 20, 40]),
    the output will be y = [270, 340, 350, 380, 400] etc.

    Parameters
    ----------
    x : ndarray
        Array containg the angular coordinates

    Returns
    -------
    y : ndarray
        Regrouped or unwrapped angular coordinates

    &#34;&#34;&#34;

    y = np.copy(x)
    if any(np.logical_and(x &gt;= 0, x &lt;= 90)) and any(np.logical_and(x &gt;= 180, x &lt;= 360)):
        y[np.logical_and(x &gt;= 0, x &lt;= 90)] = x[np.logical_and(
            x &gt;= 0, x &lt;= 90)] + 360

    return y</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="neurochat.nc_circular.CircStat.calc_stat"><code class="name flex">
<span>def <span class="ident">calc_stat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates and returns all the circular statistics parameters</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Returns the von Mises concentration parameter kappa</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def calc_stat(self):
    &#34;&#34;&#34;
    Calculates and returns all the circular statistics parameters

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Returns the von Mises concentration parameter kappa

    &#34;&#34;&#34;

    result = self._calc_mean_std()
    self._update_result(result)
    result = self._rayl_stat()
    self._update_result(result)
    result = self._vonmises_stat()
    self._update_result(result)

    return self.get_result()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.circ_histogram"><code class="name flex">
<span>def <span class="ident">circ_histogram</span></span>(<span>self, bins=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the circular histogram of the angular coordinates </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bins</code></strong> :&ensp;<code>int</code></dt>
<dd>Angular binsize for the circular histogram</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>count</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Histogram bin count</dd>
<dt><strong><code>ind</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Indices of the bins to which each value in input array belongs. Similar to
the return values of the numpy.digitize function.</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Histogram bins</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def circ_histogram(self, bins=5):
    &#34;&#34;&#34;
    Calculates the circular histogram of the angular coordinates 

    Parameters
    ----------
    bins : int
        Angular binsize for the circular histogram

    Returns
    -------
    count : ndarray
        Histogram bin count
    ind : ndarray
        Indices of the bins to which each value in input array belongs. Similar to
        the return values of the numpy.digitize function.
    bins : ndarray
        Histogram bins

    &#34;&#34;&#34;

    if isinstance(bins, int):
        bins = np.arange(0, 360, bins)

    nbins = bins.shape[0]
    count = np.zeros(bins.shape)
    ind = np.zeros(self._theta.shape, dtype=int)
    for i in np.arange(nbins):
        if i &lt; nbins - 1:
            ind[np.logical_and(self._theta &gt;= bins[i],
                               self._theta &lt; bins[i + 1])] = i
            count[i] = np.sum(np.logical_and(
                self._theta &gt;= bins[i], self._theta &lt; bins[i + 1]))

        elif i == nbins - 1:
            ind[np.logical_or(self._theta &gt;= bins[i],
                              self._theta &lt; bins[0])] = i
            count[i] = np.sum(np.logical_or(
                self._theta &gt;= bins[i], self._theta &lt; bins[0]))

    return count, ind, bins</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.circ_scatter"><code class="name flex">
<span>def <span class="ident">circ_scatter</span></span>(<span>self, bins=2, step=0.05, rmax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Prepares data for circular scatter plot. For each theta in a bin, the radius
is increased by 'step' size capped at 'rmax'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bins</code></strong> :&ensp;<code>int</code></dt>
<dd>Angular binsize for the circular scatter</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>float</code></dt>
<dd>Stepsize to increase the radius for each count of theta</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum value for the radius</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>radius</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Radius for the theta values. For each new theta in a bin, the radius
is increased by 'step' size.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Binned theta samples</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def circ_scatter(self, bins=2, step=0.05, rmax=None):
    &#34;&#34;&#34;
    Prepares data for circular scatter plot. For each theta in a bin, the radius
    is increased by &#39;step&#39; size capped at &#39;rmax&#39;.

    Parameters
    ----------
    bins : int
        Angular binsize for the circular scatter
    step : float
        Stepsize to increase the radius for each count of theta
    rmax : float
        Maximum value for the radius

    Returns
    -------
    radius : ndarray
        Radius for the theta values. For each new theta in a bin, the radius
        is increased by &#39;step&#39; size.
    theta : ndarray
        Binned theta samples

    &#34;&#34;&#34;
    # Prepares the data for scatter plot.
    count, ind, bins = self.circ_histogram(bins=2)
    radius = np.ones(ind.shape)
    theta = np.zeros(ind.shape)
    for i, b in enumerate(bins):
        rad = (
            np.ones(find(ind == i).shape) +
            np.array(
                list(step * j for j, loc in enumerate(find(ind == i)))
            )
        )
        if rmax:
            rad[rad &gt; rmax] = rmax
        radius[ind == i] = rad
        theta[ind == i] = b

    return radius, theta</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.circ_smooth"><code class="name flex">
<span>def <span class="ident">circ_smooth</span></span>(<span>self, filttype='b', filtsize=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the circular average of theta with each sample replaced by the circular
mean of length 'filtsize' and weights determined by the type of filter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filttype</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of smoothing filter. 'b' for Box filter, 'g' for Gaussian filter</dd>
<dt><strong><code>filtsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the averaging filter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>smooth_theta</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Theta values after the smoothing</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def circ_smooth(self, filttype=&#39;b&#39;, filtsize=5):
    &#34;&#34;&#34;
    Calculates the circular average of theta with each sample replaced by the circular 
    mean of length &#39;filtsize&#39; and weights determined by the type of filter.

    Parameters
    ----------
    filttype : str
        Type of smoothing filter. &#39;b&#39; for Box filter, &#39;g&#39; for Gaussian filter
    filtsize : int
        Length of the averaging filter

    Returns
    -------
    smooth_theta : ndarray
        Theta values after the smoothing

    &#34;&#34;&#34;

    if filttype == &#39;g&#39;:
        halfwid = np.round(3 * filtsize)
        xx = np.arange(-halfwid, halfwid + 1, 1)
        filt = np.exp(-(xx**2) / (2 * filtsize**2)) / \
            (np.sqrt(2 * np.pi) * filtsize)
    elif filttype == &#39;b&#39;:
        filt = np.ones(filtsize, ) / filtsize

    cs = CircStat()

    smooth_theta = np.zeros(self._theta.shape)
    N = self._theta.shape[0]
    L = filt.shape[0]
    l = int(np.floor(L / 2))
    for i in np.arange(l):
        cs.set_rho(filt[l - i:])
        cs.set_theta(self.circ_regroup(self._theta[:L - l + i]))
        csResult = cs.get_mean_std()
        smooth_theta[i] = csResult[&#39;meanTheta&#39;]
    for i in np.arange(l, N - l, 1):
        cs.set_rho(filt)
        cs.set_theta(self.circ_regroup(self._theta[i - l:i + l + 1]))
        csResult = cs.get_mean_std()
        smooth_theta[i] = csResult[&#39;meanTheta&#39;]
    for i in np.arange(N - l, N):
        cs.set_theta(self.circ_regroup(self._theta[i - l:]))
        cs.set_rho(filt[:len(self._theta[i - l:])])
        csResult = cs.get_mean_std()
        smooth_theta[i] = csResult[&#39;meanTheta&#39;]

    return smooth_theta</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.get_mean_std"><code class="name flex">
<span>def <span class="ident">get_mean_std</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the circular mean, standard deviation and resultant vector length of the data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of mean, standard deviation and resultant vector length etc.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_mean_std(self):
    &#34;&#34;&#34;
    Returns the circular mean, standard deviation and resultant vector length of the data

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Dictionary of mean, standard deviation and resultant vector length etc.

    &#34;&#34;&#34;

    if self._rho is None or not len(self._rho):
        self._rho = np.ones(self._theta.shape)
    return self._calc_mean_std()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.get_rayl_stat"><code class="name flex">
<span>def <span class="ident">get_rayl_stat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the Rayleigh Z statistics of the circular data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Rayleigh Z statistics</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_rayl_stat(self):
    &#34;&#34;&#34;
    Returns the Rayleigh Z statistics of the circular data

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Rayleigh Z statistics

    &#34;&#34;&#34;

    return self._rayl_stat()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.get_result"><code class="name flex">
<span>def <span class="ident">get_result</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Resturns the results of the circular statistics analyses</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Results of the circular statistics analyses</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_result(self):
    &#34;&#34;&#34;
    Resturns the results of the circular statistics analyses

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Results of the circular statistics analyses

    &#34;&#34;&#34;
    return self._result</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.get_rho"><code class="name flex">
<span>def <span class="ident">get_rho</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the radial coordinates (rho) of the circular data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Radial coordinates of the circular data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_rho(self):
    &#34;&#34;&#34;
    Returns the radial coordinates (rho) of the circular data

    Parameters
    ----------
    None

    Returns
    -------
    ndarray
        Radial coordinates of the circular data

    &#34;&#34;&#34;

    return self._rho</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.get_theta"><code class="name flex">
<span>def <span class="ident">get_theta</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the angular coordinates (theta) of the circular data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Angular coordinates of the circular data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_theta(self):
    &#34;&#34;&#34;
    Returns the angular coordinates (theta) of the circular data

    Parameters
    ----------
    None

    Returns
    -------
    ndarray
        Angular coordinates of the circular data

    &#34;&#34;&#34;

    return self._theta</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.get_vonmises_stat"><code class="name flex">
<span>def <span class="ident">get_vonmises_stat</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the von Mises concentration parameter kappa</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Returns the von Mises concentration parameter kappa</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_vonmises_stat(self):
    &#34;&#34;&#34;
    Returns the von Mises concentration parameter kappa

    Parameters
    ----------
    None

    Returns
    -------
    dict
        Returns the von Mises concentration parameter kappa

    &#34;&#34;&#34;

    return self._vonmises_stat()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.set_rho"><code class="name flex">
<span>def <span class="ident">set_rho</span></span>(<span>self, rho=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the radial coordinates (rho) of the circular data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rho</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Radial coordinates of the circular data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_rho(self, rho=None):
    &#34;&#34;&#34;
    Sets the radial coordinates (rho) of the circular data

    Parameters
    ----------
    rho : ndarray
        Radial coordinates of the circular data

    Returns
    -------
    None

    &#34;&#34;&#34;

    if rho is not None:
        self._rho = rho</code></pre>
</details>
</dd>
<dt id="neurochat.nc_circular.CircStat.set_theta"><code class="name flex">
<span>def <span class="ident">set_theta</span></span>(<span>self, theta=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the angular coordinates (theta) of the circular data in degrees.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Angular coordinates of the circular data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_theta(self, theta=None):
    &#34;&#34;&#34;
    Sets the angular coordinates (theta) of the circular data in degrees.

    Parameters
    ----------
    theta : ndarray
        Angular coordinates of the circular data

    Returns
    -------
    None

    &#34;&#34;&#34;

    if theta is not None:
        self._theta = theta</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neurochat" href="index.html">neurochat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="neurochat.nc_circular.CircStat" href="#neurochat.nc_circular.CircStat">CircStat</a></code></h4>
<ul class="two-column">
<li><code><a title="neurochat.nc_circular.CircStat.calc_stat" href="#neurochat.nc_circular.CircStat.calc_stat">calc_stat</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.circ_histogram" href="#neurochat.nc_circular.CircStat.circ_histogram">circ_histogram</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.circ_regroup" href="#neurochat.nc_circular.CircStat.circ_regroup">circ_regroup</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.circ_scatter" href="#neurochat.nc_circular.CircStat.circ_scatter">circ_scatter</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.circ_smooth" href="#neurochat.nc_circular.CircStat.circ_smooth">circ_smooth</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.get_mean_std" href="#neurochat.nc_circular.CircStat.get_mean_std">get_mean_std</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.get_rayl_stat" href="#neurochat.nc_circular.CircStat.get_rayl_stat">get_rayl_stat</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.get_result" href="#neurochat.nc_circular.CircStat.get_result">get_result</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.get_rho" href="#neurochat.nc_circular.CircStat.get_rho">get_rho</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.get_theta" href="#neurochat.nc_circular.CircStat.get_theta">get_theta</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.get_vonmises_stat" href="#neurochat.nc_circular.CircStat.get_vonmises_stat">get_vonmises_stat</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.set_rho" href="#neurochat.nc_circular.CircStat.set_rho">set_rho</a></code></li>
<li><code><a title="neurochat.nc_circular.CircStat.set_theta" href="#neurochat.nc_circular.CircStat.set_theta">set_theta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>