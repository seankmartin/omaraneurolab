<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>neurochat.nc_plot API documentation</title>
<meta name="description" content="This module implements plotting functions for NeuroChaT analyses â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neurochat.nc_plot</code></h1>
</header>
<section id="section-intro">
<p>This module implements plotting functions for NeuroChaT analyses.</p>
<p>@author: Md Nurul Islam; islammn at tcd dot ie</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module implements plotting functions for NeuroChaT analyses.

@author: Md Nurul Islam; islammn at tcd dot ie
&#34;&#34;&#34;

import itertools
import math
import logging
import gc

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcol
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.lines import Line2D
from matplotlib.patches import Arc
import matplotlib.ticker as ticker
import matplotlib.gridspec as gridspec

from neurochat.nc_utils import find, angle_between_points, get_axona_colours

BLUE = &#39;#1f77b4&#39;
RED = &#39;#d62728&#39;

def scatterplot_matrix(_data, names=[], **kwargs):
    &#34;&#34;&#34;Plots a scatterplot matrix of subplots.  Each row of &#34;_data&#34; is plotted
    against other rows, resulting in a nrows by nrows grid of subplots with the
    diagonal subplots labeled with &#34;names&#34;.  Additional keyword arguments are
    passed on to matplotlib&#39;s &#34;plot&#34; command. Returns the matplotlib figure
    object containg the subplot grid.&#34;&#34;&#34;
    numvars, _ = _data.shape
    fig, axs = plt.subplots(nrows=numvars, ncols=numvars, figsize=(8, 8))
    fig.subplots_adjust(hspace=0.05, wspace=0.05)

    for ax in axs.flat:
        # Hide all ticks and labels
        ax.xaxis.set_visible(False)
        ax.yaxis.set_visible(False)

        # Set up ticks only on one side for the &#34;edge&#34; subplots...
        if ax.is_first_col():
            ax.yaxis.set_ticks_position(&#39;left&#39;)
        if ax.is_last_col():
            ax.yaxis.set_ticks_position(&#39;right&#39;)
        if ax.is_first_row():
            ax.xaxis.set_ticks_position(&#39;top&#39;)
        if ax.is_last_row():
            ax.xaxis.set_ticks_position(&#39;bottom&#39;)

    # Plot the _data.
    for i, j in zip(*np.triu_indices_from(axs, k=1)):
        for x, y in [(i, j), (j, i)]:
            axs[y, x].scatter(_data[x], _data[y], **kwargs)

    # Label the diagonal subplots...
    if len(names) == numvars:
        for i, label in enumerate(names):
            axs[i, i].annotate(label, (0.5, 0.5), xycoords=&#39;axes fraction&#39;,\
               ha=&#39;center&#39;, va=&#39;center&#39;)

    # Turn on the proper x or y axes ticks.
    for i, j in zip(range(numvars), itertools.cycle((-1, 0))):
        axs[j, i].xaxis.set_visible(True)
        axs[i, j].yaxis.set_visible(True)

def set_backend(backend):
    &#34;&#34;&#34;
    Sets the  backend of Matplotlib

    Parameters
    ----------
    backend : str
        The new backend for Matplotlib

    Returns
    -------
    None

    See also
    --------
    matplotlib.pyplot.switch_backend()

    &#34;&#34;&#34;

    if backend:
        plt.switch_backend(backend)

def wave_property(wave_data, plots=[2, 2]):
    &#34;&#34;&#34;
    Plots mean +/-std of waveforms in electrode groups

    Parameters
    ----------
    wave_data : dict
        Graphical data from the Waveform analysis
    plots : list
        Subplot shape. [2, 2] for tetrode setup

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Matlab figure object

    &#34;&#34;&#34;

    # Wave property analysis
    fig1, ax = plt.subplots(plots[0], plots[1])
    ax = ax.flatten()
    # Plot waves
    for i in np.arange(len(ax)):
        ax[i].plot(wave_data[&#39;Mean wave&#39;][:, i], color=&#39;black&#39;, linewidth=2.0)
        ax[i].plot(wave_data[&#39;Mean wave&#39;][:, i]+wave_data[&#39;Std wave&#39;][:, i],\
          color=&#39;green&#39;, linestyle=&#39;dashed&#39;)
        ax[i].plot(wave_data[&#39;Mean wave&#39;][:, i]-wave_data[&#39;Std wave&#39;][:, i],\
          color=&#39;green&#39;, linestyle=&#39;dashed&#39;)

    return fig1

def largest_waveform(wave_data, ax=None):
    &#34;&#34;&#34;
    Plot the largest waveform in electrode groups.

    Parameters
    ----------
    wave_data : dict
        Graphical data form the Waveform analysis
    ax : matplotlib.axes.Axes
        Optional axes to plot to
    Returns
    -------
    matplotlib.pyplot.Figure
        The figure plotted to, or None if an axes is provided
    &#34;&#34;&#34;
    ax, fig = _make_ax_if_none(ax)

    mean_wave = wave_data[&#39;Mean wave&#39;][:, wave_data[&#34;Max channel&#34;]]
    std_wave = wave_data[&#39;Std wave&#39;][:, wave_data[&#34;Max channel&#34;]]
    ax.plot(mean_wave, color=&#39;black&#39;, linewidth=2.0)
    ax.plot(mean_wave+std_wave, color=&#39;green&#39;, linestyle=&#39;dashed&#39;)
    ax.plot(mean_wave-std_wave, color=&#39;green&#39;, linestyle=&#39;dashed&#39;)

    return fig

def isi(isi_data, axes=[None, None, None], **kwargs):
    &#34;&#34;&#34;
    Plots Interspike interval histogram and scatter plots of interval-before
    vs interval-after.

    Parameters
    ----------
    isi_data : dict
        Graphical data from the ISI analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Histogram of ISI
    fig2 : matplotlib.pyplot.Figure
        Scatter plot of ISI-before vs ISI-after in loglog scale
    fig3 : matplotlib.pyplot.Figure
        2D histogram of the ISI-before vs ISI-after in log-log scale

    &#34;&#34;&#34;

    # Plot ISI
    # histogram
    title = kwargs.get(&#34;title1&#34;, &#39;Distribution of inter-spike interval&#39;)
    xlabel = kwargs.get(&#34;xlabel1&#34;, &#39;ISI (ms)&#39;)
    ylabel = kwargs.get(&#34;ylabel1&#34;, &#39;Spike count&#39;)
    ax, fig1 = _make_ax_if_none(axes[0])
    ax.bar(isi_data[&#39;isiBins&#39;], isi_data[&#39;isiHist&#39;], color=&#39;darkblue&#39;, \
           edgecolor=&#39;darkblue&#39;, rasterized=True)
    ax.plot([5, 5,], [0, isi_data[&#39;maxCount&#39;]], linestyle=&#39;dashed&#39;,\
            linewidth=2, color=&#39;red&#39;)
    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    max_axis = isi_data[&#39;isiBins&#39;].max()
    max_axisLog = np.ceil(np.log10(max_axis))

    ## ISI scatterplot
    ax, fig2 = _make_ax_if_none(axes[1])
    ax.loglog(isi_data[&#39;isiBefore&#39;], isi_data[&#39;isiAfter&#39;], axes=ax, \
            linestyle=&#39; &#39;, marker=&#39;o&#39;, markersize=1, \
            markeredgecolor=&#39;k&#39;, markerfacecolor=None, rasterized=True)
#    ax.autoscale(enable= True, axis= &#39;both&#39;, tight= True)
    ax.plot(ax.get_xlim(), [5, 5], linestyle=&#39;dashed&#39;, linewidth=2, color=&#39;red&#39;)
    ax.set_aspect(1)
    #    ax.set_xlabel(&#39;Interval before (ms)&#39;)
    ax.set_ylabel(&#39;Interval after (ms)&#39;)
    ax.set_xlabel(&#39;Interval before (ms)&#39;)
    ax.set_title(&#39;Distribution of ISI \n (before and after spike)&#39;)

    #
    logBins = np.logspace(0, max_axisLog, max_axisLog*70)
    joint_count, xedges, yedges = np.histogram2d(isi_data[&#39;isiBefore&#39;],\
                                isi_data[&#39;isiAfter&#39;], bins=logBins)

    # Scatter colored
    _extent = [xedges[0], xedges[-2], yedges[0], yedges[-2]]

#        ax = fig2.add_subplot(212, aspect= &#39;equal&#39;)
    ax, fig3 = _make_ax_if_none(axes[2])
    c_map = plt.cm.jet
    c_map.set_under(&#39;white&#39;)
    ax.pcolormesh(xedges[0:-1], yedges[0:-1], joint_count,\
                  cmap=c_map, vmin=1, rasterized=True)
    ax.plot(ax.get_xlim(), [5, 5], linestyle=&#39;dashed&#39;, linewidth=2, color=&#39;red&#39;)
    plt.axis(_extent)
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;Interval before (ms)&#39;)
    ax.set_ylabel(&#39;Interval after (ms)&#39;)
    ax.set_title(&#39;Distribution of ISI \n (before and after spike)&#39;)

    return fig1, fig2, fig3

def isi_corr(isi_corr_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots ISI correlation.

    Parameters
    ----------
    isi_corr_data : dict
        Graphical data from the ISI correlation
    ax : matplotlib.axes.Axes
        Optional axes object to plot to.
    kwargs :
        title : str

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        ISI correlation histogram

    &#34;&#34;&#34;
    isi_time = abs(isi_corr_data[&#39;isiCorrBins&#39;].min())
    default_title = (
        &#39;Autocorrelation Histogram \n ({}ms)&#39;.format(str(isi_time)))
    title = kwargs.get(&#34;title&#34;, default_title)
    xlabel = kwargs.get(&#34;xlabel&#34;, &#34;Time (ms)&#34;)
    ylabel = kwargs.get(&#34;ylabel&#34;, &#34;Counts&#34;)
    plot_theta = kwargs.get(&#34;plot_theta&#34;, False)

    ax, fig = _make_ax_if_none(ax)

    show_edges = False
    line_width = 1 if show_edges else 0
    all_bins = isi_corr_data[&#39;isiAllCorrBins&#39;]

    widths = [
        abs(all_bins[i+1] - all_bins[i]) for i in range(len(all_bins) - 1)]
    bin_centres = [
        (all_bins[i+1] + all_bins[i]) / 2 for i in range(len(all_bins) - 1)]
    ax.bar(bin_centres, isi_corr_data[&#39;isiCorr&#39;],
           width=widths, linewidth=line_width, color=&#39;darkblue&#39;,
           edgecolor=&#39;black&#39;, rasterized=True, align=&#39;center&#39;, antialiased=True)
    ax.tick_params(width=1.5)

    if plot_theta:
        ax.plot(bin_centres, isi_corr_data[&#39;corrFit&#39;], linewidth=2, color=&#39;red&#39;)

    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)

    return fig

def theta_cell(plot_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots theta-modulated cell and theta-skipping cell analysis data

    Parameters
    ----------
    plot_data : dict
        Graphical data from the theta-modulated cell
    ax : matplotlib.axes.Axes
        Optional axes object to plot to.
    kwargs :
        title : str

    Returns
    -------
    matplotlib.pyplot.Figure
        ISI correlation histogram superimposed with fitted sinusoidal curve.

    &#34;&#34;&#34;
    return isi_corr(plot_data, ax=ax, plot_theta=True, **kwargs)

def lfp_spectrum(plot_data):
    &#34;&#34;&#34;
    Plots LFP spectrum analysis data

    Parameters
    ----------
    plot_data : dict
        Graphical data from the ISI correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Line plot of LFP spectrum using Welch&#39;s method

    &#34;&#34;&#34;


    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(plot_data[&#39;f&#39;], plot_data[&#39;Pxx&#39;], linewidth=2)
    ax.set_xlabel(&#39;Frequency (Hz)&#39;)
    ax.set_ylabel(&#39;PSD&#39;)
    _extent = [0, plot_data[&#39;f&#39;].max(), 0, plot_data[&#39;Pxx&#39;].max()]
    plt.axis(_extent)

    return fig1

def lfp_spectrum_tr(plot_data):
    &#34;&#34;&#34;
    Plots time-resolved LFP spectrum analysis data

    Parameters
    ----------
    plot_data : dict
        Graphical data from the ISI correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        3D plot of short-term FFT of the LFP signal

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(plot_data[&#39;t&#39;], plot_data[&#39;f&#39;], plot_data[&#39;Sxx&#39;], cmap=c_map)
    _extent = [0, plot_data[&#39;t&#39;].max(), 0, plot_data[&#39;f&#39;].max()]
    plt.axis(_extent)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig1.colorbar(pcm)

    return fig1

def plv(plv_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of Phase-locking value (PLV)

    Parameters
    ----------
    plv_data : dict
        Graphical data from the PLV analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Plot of spike-triggered average (STA)
    fig2 : matplotlib.pyplot.Figure
        Plot of FFT of STA (fSTA), average power spectrum of spike-triggered LFP signals (STP),
        spike-field coherence and PLV in four subplots

    &#34;&#34;&#34;

    f = plv_data[&#39;f&#39;]
    t = plv_data[&#39;t&#39;]
    STA = plv_data[&#39;STA&#39;]
    fSTA = plv_data[&#39;fSTA&#39;]
    STP = plv_data[&#39;STP&#39;]
    SFC = plv_data[&#39;SFC&#39;]
    PLV = plv_data[&#39;PLV&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(t, STA, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Spike-triggered average (STA)&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;STA (uV)&#39;)

    fig2 = plt.figure()
    ax = fig2.add_subplot(221)
    ax.plot(f, fSTA, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;fft of STA&#39;)

    ax = fig2.add_subplot(222)
    ax.plot(f, STP, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;STP&#39;)

    ax = fig2.add_subplot(223)
    ax.plot(f, SFC, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;SFC&#39;)

    ax = fig2.add_subplot(224)
    ax.plot(f, PLV, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;PLV&#39;)

    for ax in fig2.axes:
        ax.set_xlabel(&#39;Frequency (Hz)&#39;)

    fig2.suptitle(&#39;Frequency analysis of spike-triggered lfp metrics&#39;)

    plt.subplots_adjust(wspace=0.3, hspace=0.35)
    return fig1, fig2

def plv_tr(plv_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of time-resolved Phase-locking value (PLV)

    Parameters
    ----------
    plv_data : dict
        Graphical data from the time-resolved PLV analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Plot of fSTA
    fig2 : matplotlib.pyplot.Figure
        Plot of STP
    fig3 : matplotlib.pyplot.Figure
        Plot of SFC

    &#34;&#34;&#34;

    offset = plv_data[&#39;offset&#39;]
    f = plv_data[&#39;f&#39;]
    fSTA = plv_data[&#39;fSTA&#39;]
#        STP= plv_data[&#39;STP&#39;]
    SFC = plv_data[&#39;SFC&#39;]
    PLV = plv_data[&#39;PLV&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(offset, f, fSTA, cmap=c_map, rasterized=True)
    plt.title(&#39;Time-resolved fSTA&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig1.colorbar(pcm)

    fig2 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(offset, f, SFC, cmap=c_map, rasterized=True)
    plt.title(&#39;Time-resolved SFC&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig2.colorbar(pcm)

    fig3 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(offset, f, PLV, cmap=c_map, rasterized=True)
    plt.title(&#39;Time-resolved PLV&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig3.colorbar(pcm)

    return fig1, fig2, fig3

def plv_bs(plv_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of bootstrapped Phase-locking value (PLV)

    Parameters
    ----------
    plv_data : dict
        Graphical data from the time-resolved PLV analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Plot of fSTA
    fig2 : matplotlib.pyplot.Figure
        Plot of STP
    fig3 : matplotlib.pyplot.Figure
        Plot of SFC

    &#34;&#34;&#34;
    f = plv_data[&#39;f&#39;]
    t = plv_data[&#39;t&#39;]
    STAm = plv_data[&#39;STAm&#39;]
    fSTAm = plv_data[&#39;fSTAm&#39;]
    STPm = plv_data[&#39;STPm&#39;]
    SFCm = plv_data[&#39;SFCm&#39;]
    PLVm = plv_data[&#39;PLVm&#39;]

    STAe = plv_data[&#39;STAe&#39;]
    fSTAe = plv_data[&#39;fSTAe&#39;]
    STPe = plv_data[&#39;STPe&#39;]
    SFCe = plv_data[&#39;SFCe&#39;]
    PLVe = plv_data[&#39;PLVe&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(t, STAm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;o&#39;, \
                 markerfacecolor=&#39;darkblue&#39;, markeredgecolor=&#39;none&#39;)
    ax.fill_between(t, STAm- STAe, STAm+ STAe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Spike-triggered average (STA)&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;STA (uV)&#39;)

    fig2 = plt.figure()
    ax = fig2.add_subplot(221)
    ax.plot(f, fSTAm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, fSTAm- fSTAe, fSTAm+ fSTAe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;fft of STA&#39;)

    ax = fig2.add_subplot(222)
    ax.plot(f, STPm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, STPm- STPe, STPm+ STPe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;STP&#39;)

    ax = fig2.add_subplot(223)
    ax.plot(f, SFCm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, SFCm- SFCe, SFCm+ SFCe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;SFC&#39;)

    ax = fig2.add_subplot(224)
    ax.plot(f, PLVm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, PLVm- PLVe, PLVm+ PLVe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;PLV&#39;)

    for ax in fig2.axes:
        ax.set_xlabel(&#39;Frequency (Hz)&#39;)

    fig2.suptitle(&#39;Frequency analysis of spike-triggered lfp metrics (bootstrap)&#39;)
    plt.subplots_adjust(wspace=0.3, hspace=0.35)
    return fig1, fig2

def spike_phase(phase_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of spike-LFP phase locking

    Parameters
    ----------
    phase_data : dict
        Graphical data from the spike-LFP phase locking analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Phase histogram
    fig2 : matplotlib.pyplot.Figure
        Phase distribution in circular plot
    fig3 : matplotlib.pyplot.Figure
        Phase-raster in one subplot, phase histogram in another

    &#34;&#34;&#34;
    phBins = phase_data[&#39;phBins&#39;]
    phCount = phase_data[&#39;phCount&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    ax.bar(np.append(phBins, phBins+ 360), np.append(phCount, phCount), \
           color=&#39;slateblue&#39;, width=np.diff(phBins).mean(),\
           alpha=0.6, align=&#39;center&#39;, rasterized=True)
    ax.plot(np.append(phBins, phBins+ 360), 0.5*np.max(phCount)*(np.cos(np.append(phBins, phBins+ 360)*np.pi/180)+ 1), \
            color=&#39;red&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;LFP phase distribution (red= reference cosine line)&#39;)
    ax.set_xlabel(&#39;Degrees&#39;)
    ax.set_ylabel(&#39;Spike count&#39;)

    fig2 = plt.figure()
    ax = plt.gca(polar=True)
    ax.bar(phBins*np.pi/180, phCount, width=3*np.pi/180, color=&#39;blue&#39;,\
           alpha=0.6, bottom=np.max(phase_data[&#39;phCount&#39;])/2, rasterized=True)
    ax.plot([0, phase_data[&#39;meanTheta&#39;]], [0, 1.5*np.max(phCount)], \
            linewidth=3, color=&#39;red&#39;, marker=&#39;.&#39;)
    plt.title(&#39;LFP phase distribution (red= mean direction)&#39;)

    fig3 = plt.figure()
    ax = fig3.add_subplot(211)
    #cdict= {&#39;blue&#39;: (0, 0, 1),
    #       &#39;white&#39;: (0, 0, 0)}
    #c_map = mcol.LinearSegmentedColormap(&#39;my_colormap&#39;, cdict, 256)
    ax.pcolormesh(phase_data[&#39;rasterbins&#39;], np.arange(0, phase_data[&#39;raster&#39;].shape[0]), \
                  phase_data[&#39;raster&#39;], cmap=plt.cm.binary, rasterized=True)
    
    # Alternative idea for plotting, not currently working. 
    # rasters = phase_data[&#39;raster&#39;]
    # bin_length = np.mean(np.diff(phase_data[&#39;raster&#39;], 0))

    # for idx, row in enumerate(rasters):
    #      rasters[idx] = [
    #          j_idx*(bin_length) +0.5*bin_length if j == 1 else 0 for 
    #             j_idx, j in enumerate(row)]
    # ax.eventplot(rasters)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.title(&#39;Phase raster&#39;)
    ax.set_ylabel(&#39;Time&#39;)

    ax = fig3.add_subplot(212)
    ax.bar(phBins, phCount, color=&#39;slateblue&#39;, \
           width=np.diff(phBins).mean(), alpha=0.6, align=&#39;center&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Phase(deg)&#39;)
    ax.set_ylabel(&#39;Spike count&#39;)

    return fig1, fig2, fig3

def speed(speed_data):
    &#34;&#34;&#34;
    Plots the speed of the animal vs spike rate

    Parameters
    ----------
    speed_data : dict
        Graphical data from the unit firing to speed correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Scatter plot of speed vs spike-rate superimposed with fitted rate

    &#34;&#34;&#34;

    ## Speed analysis
    fig1 = plt.figure()
    ax = plt.gca()
    ax.scatter(speed_data[&#39;bins&#39;], speed_data[&#39;rate&#39;], c=BLUE, zorder=1)
    ax.plot(speed_data[&#39;bins&#39;], speed_data[&#39;fitRate&#39;], color=RED, linewidth=1.5, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Speed vs Spiking Rate&#39;)
    ax.set_xlabel(&#39;Speed (cm/sec)&#39;)
    ax.set_ylabel(&#39;Spikes/sec&#39;)

    return fig1

def angular_velocity(angVel_data):
    &#34;&#34;&#34;
    Plots the angular head velocity of the animal vs spike rate

    Parameters
    ----------
    angVel_data : dict
        Graphical data from the unit firing to angular head velocity correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Scatter plot of angular velocity vs spike-rate superimposed with fitted rate

    &#34;&#34;&#34;

    ## Angular velocity analysis
    fig1 = plt.figure()
    ax = plt.gca()
    ax.scatter(angVel_data[&#39;leftBins&#39;], angVel_data[&#39;leftRate&#39;], c=BLUE, zorder=1)
    ax.plot(angVel_data[&#39;leftBins&#39;], angVel_data[&#39;leftFitRate&#39;], color=RED, linewidth=1.5, zorder=2)
    ax.scatter(angVel_data[&#39;rightBins&#39;], angVel_data[&#39;rightRate&#39;], c=BLUE, zorder=1)
    ax.plot(angVel_data[&#39;rightBins&#39;], angVel_data[&#39;rightFitRate&#39;], color=RED, linewidth=1.5, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Angular Velocity vs Spiking Rate&#39;)
    ax.set_xlabel(&#39;Angular velocity (deg/sec)&#39;)
    ax.set_ylabel(&#39;Spikes/sec&#39;)

    return fig1

def multiple_regression(mra_data):
    &#34;&#34;&#34;
    Plots the replay_data of multiple regression analysis.

    Parameters
    ----------
    mra_data : dict
        Graphical data from multiple regression analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Bar plot of multiple regression replay_data

    &#34;&#34;&#34;

    varOrder = [&#39;Total&#39;, &#39;Loc&#39;, &#39;HD&#39;, &#39;Speed&#39;, &#39;Ang Vel&#39;, &#39;Dist Border&#39;]
    fig1 = plt.figure()
    ax = plt.gca()
    ax.bar(np.arange(6), mra_data[&#39;meanRsq&#39;], color=&#39;royalblue&#39;, align=&#39;center&#39;)
    ax.errorbar(np.arange(6), mra_data[&#39;meanRsq&#39;], fmt=&#39;ro&#39;,\
                yerr=mra_data[&#39;stdRsq&#39;], ecolor=&#39;k&#39;, elinewidth=3)
    ax.set_title(&#39;Multiple regression scores&#39;)
    ax.set_ylabel(&#39;$R^2$&#39;)
    plt.xticks(np.arange(6), varOrder)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)

    return fig1

def hd_rate(hd_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plot head direction vs spike rate.

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-direction correlation
    ax : matplotlib.axes.Axes
        Polar Axes object. If specified, the figure is plotted in this axes.
    kwargs :

    Returns
    -------
    ax : matplotlib.axes.Axes
        Axes of the polar plot of head-direction vs spike-rate.

    &#34;&#34;&#34;
    title = kwargs.get(&#34;title&#34;, &#34;Head directional firing rate&#34;)
    if not ax:
        plt.figure()
        ax = plt.gca(polar=True)

    bins = np.append(hd_data[&#39;bins&#39;], hd_data[&#39;bins&#39;][0])
    rate = np.append(hd_data[&#39;smoothRate&#39;], hd_data[&#39;smoothRate&#39;][0])
    ax.plot(np.radians(bins), rate, color=BLUE)

    ax.set_title(title)
    ax.set_rticks([hd_data[&#39;hdRate&#39;].max()])

    return ax

def hd_spike(hd_data, ax=None):
    &#34;&#34;&#34;
    Plots the head-direction of the animal at the time of spiking-events in polar scatter plot.

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-direction correlation
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.

    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the polar plot of head-direction during spiking events.

    &#34;&#34;&#34;

    if not ax:
        plt.figure()
        ax = plt.gca(polar=True)

    ax.scatter(np.radians(hd_data[&#39;scatter_bins&#39;]), hd_data[&#39;scatter_radius&#39;], \
             s=1, c=RED, alpha=0.75, edgecolors=&#39;none&#39;, rasterized=True)
    ax.set_rticks([])
    ax.spines[&#39;polar&#39;].set_visible(False)

    return ax

def hd_firing(hd_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of head directional correlation to spike-rate

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-directional correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Polar plot of head-direction during spiking-events
    fig2 : matplotlib.pyplot.Figure
        Polar plot of head-direction vs spike-rate. Predicted firing rate is also plotted.

    &#34;&#34;&#34;

    fig1 = plt.figure()
    hd_spike(hd_data, ax=plt.gca(polar=True))

    fig2 = plt.figure()
    ax2 = hd_rate(hd_data, ax=plt.gca(polar=True))
    bins = np.append(hd_data[&#39;bins&#39;], hd_data[&#39;bins&#39;][0])
    predRate = np.append(hd_data[&#39;hdPred&#39;], hd_data[&#39;hdPred&#39;][0])
    ax2.plot(np.radians(bins), predRate, color=&#39;green&#39;)
    ax2.set_rticks([hd_data[&#39;hdRate&#39;].max(), hd_data[&#39;hdPred&#39;].max()])

    return fig1, fig2

def hd_rate_ccw(hd_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of head directional correlation to spike-rate
    but split into counterclockwise and clockwise head-movements.

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-direction correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Polar plot of head-direction vs spike-rate in  clockwise and counterclockwise
        head movements

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca(polar=True)
    ax.plot(np.radians(hd_data[&#39;bins&#39;]), hd_data[&#39;hdRateCW&#39;], color=BLUE)
    ax.plot(np.radians(hd_data[&#39;bins&#39;]), hd_data[&#39;hdRateCCW&#39;], color=RED)
    ax.set_title(&#39;Counter/clockwise firing rate&#39;)
    ax.set_rticks([hd_data[&#39;hdRateCW&#39;].max(), hd_data[&#39;hdRateCCW&#39;].max()])

    return fig1

def hd_shuffle(hd_shuffle_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional shuffling analysis

    Parameters
    ----------
    hd_shuffle_data : dict
        Graphical data from head-directional shuffling anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distribution of Rayleigh Z statistics
    fig2 : matplotlib.pyplot.Figure
        Distribution of Von Mises concentration parameter Kapppa

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    ax.bar(hd_shuffle_data[&#39;raylZEdges&#39;], hd_shuffle_data[&#39;raylZCount&#39;],\
           color=&#39;slateblue&#39;, alpha=0.6,\
           width=np.diff(hd_shuffle_data[&#39;raylZEdges&#39;]).mean(), rasterized=True)
    ax.plot([hd_shuffle_data[&#39;raylZPer95&#39;], hd_shuffle_data[&#39;raylZPer95&#39;]], \
            [0, hd_shuffle_data[&#39;raylZCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Rayleigh Z distribution for shuffled spikes (red= 95th percentile)&#39;)
    ax.set_xlabel(&#39;Rayleigh Z score&#39;)
    ax.set_ylabel(&#39;Count&#39;)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.bar(hd_shuffle_data[&#39;vonMisesKEdges&#39;], hd_shuffle_data[&#39;vonMisesKCount&#39;],\
           color=&#39;slateblue&#39;, alpha=0.6, \
           width=np.diff(hd_shuffle_data[&#39;vonMisesKEdges&#39;]).mean(), rasterized=True)
    ax.plot([hd_shuffle_data[&#39;vonMisesKPer95&#39;], hd_shuffle_data[&#39;vonMisesKPer95&#39;]], \
            [0, hd_shuffle_data[&#39;vonMisesKCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;von Mises kappa distribution for shuffled spikes \n (red= 95th percentile)&#39;)
    ax.set_xlabel(&#39;von Mises kappa&#39;)
    ax.set_ylabel(&#39;Count&#39;)

    return fig1, fig2

def hd_spike_time_lapse(hd_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional time-lapse analysis

    Parameters
    ----------
    hd_data : dict
        Graphical data from head-directional time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed spike-plots

    &#34;&#34;&#34;


    keys = [key[1] for key in list(enumerate(hd_data.keys()))]
    fig = []
    axs = []
    keys = list(hd_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, subplot_kw=dict(projection=&#39;polar&#39;))
        plt.subplots_adjust(top=0.9, hspace=0.55)
        fig.append(f)
        axs.extend(list(ax.flatten()))
        
    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            nice_key = _nice_lapse_key(key)
            ax = hd_spike(hd_data[key], ax=ax)
            ax.set_title(nice_key, y=1, fontsize=10)
        else:
            ax.set_visible(False)
    return fig

def hd_rate_time_lapse(hd_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional time-lapse analysis

    Parameters
    ----------
    hd_data : dict
        Graphical data from head-directional time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed head-drectional firing rate plot

    &#34;&#34;&#34;

    keys = [key[1] for key in list(enumerate(hd_data.keys()))]
    fig = []
    axs = []
    keys = list(hd_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, subplot_kw=dict(projection=&#39;polar&#39;))
        plt.subplots_adjust(top=0.9, hspace=0.55)
        fig.append(f)
        axs.extend(list(ax.flatten()))
        
    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            nice_key = _nice_lapse_key(key)
            ax = hd_rate(hd_data[key], ax=ax)
            ax.set_title(nice_key, y=1, fontsize=10)
        else:
            ax.set_visible(False)
    return fig

def _nice_lapse_key(key):
    parts = key.split(&#34;To&#34;)
    end = parts[1][-3:] if parts[1][-3:].lower() == &#34;end&#34; else (
        parts[1][0] + &#34; &#34; + parts[1][-3:])
    nice_key = parts[0] + &#34; to &#34; + end
    return nice_key

def hd_time_shift(hd_shift_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional time-shift analysis

    Parameters
    ----------
    hd_shift_data : dict
        Graphical data from head-directional time-shift anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Skaggs information content of head directional firing in shifted time of spiking events
    fig2 : matplotlib.pyplot.Figure
        Peak firing rate of head directional firing in shifted time of spiking events
    fig3 : matplotlib.pyplot.Figure
        Skaggs information content of head directional firing in shifted time of spiking events
    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;skaggs&#39;],\
            marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_ylabel(&#39;Skaggs IC&#39;)
    ax.set_title(&#39;Skaggs IC of hd firing in shifted time of spiking events&#39;)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;peakRate&#39;],\
            marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_ylabel(&#39;Peak firing rate (spikes/sec)&#39;)
    ax.set_title(&#39;Peak FR of hd firing in shifted time of spiking events&#39;)

    fig3 = plt.figure()
    ax = plt.gca()
    ax.scatter(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;delta&#39;], c=RED, zorder=3)
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;deltaFit&#39;], color=BLUE, linewidth=1.5, zorder=1)
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], np.zeros(hd_shift_data[&#39;shiftTime&#39;].size), color=&#39;k&#39;, linestyle=&#39;--&#39;, linewidth=1.5, zorder=2)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_ylabel(&#39;Delta (degree)&#39;)
    ax.set_title(&#39;Delta of hd firing in shifted time of spiking events&#39;)

    return fig1, fig2, fig3

def loc_spike(place_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots the location of spiking-events (spike-plot) along with the trace of animal in the enviroment.

    Parameters
    ----------
    place_data : dict
        Graphical data from the correlation of unit firing to location of the animal
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.

    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the spike-plot

    &#34;&#34;&#34;
    # default_point_size = max(
    #     place_data[&#39;yedges&#39;].max() - place_data[&#39;yedges&#39;].min(),
    #     place_data[&#39;xedges&#39;].max() - place_data[&#39;xedges&#39;].min()
    # ) / 10
    default_point_size = 2

    color = kwargs.get(&#34;color&#34;, RED)
    point_size = kwargs.get(&#34;point_size&#34;, default_point_size)
    # spatial firing map
    if not ax:
        plt.figure()
        ax = plt.gca()

    ax.plot(place_data[&#39;posX&#39;], place_data[&#39;posY&#39;], color=&#39;black&#39;, zorder=1)
    ax.scatter(place_data[&#39;spikeLoc&#39;][0], place_data[&#39;spikeLoc&#39;][1], \
               s=point_size, marker=&#39;o&#39;, color=color, zorder=2)
    ax.set_ylim([0, place_data[&#39;yedges&#39;].max()])
    ax.set_xlim([0, place_data[&#39;xedges&#39;].max()])
    #asp = np.diff(ax.get_xlim())[0] / np.diff(ax.get_ylim())[0]
    #ax.set_aspect(asp)
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    return ax

def loc_rate(place_data, ax=None, smooth=True, **kwargs):
    &#34;&#34;&#34;
    Plots location vs spike rate

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to locational correlation
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.
    kwargs :
        colormap : str
            viridis is used if not specified
            &#34;default&#34; uses the standard red green intensity colours
            but these are bad for colorblindness.
        style : str
            What kind of map to plot - can be
            &#34;contour&#34;, &#34;digitized&#34; or &#34;interpolated&#34;
        levels : int
            Number of contour regions.
    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the firing rate map

    &#34;&#34;&#34;
    colormap = kwargs.get(&#34;colormap&#34;, &#34;viridis&#34;)
    style = kwargs.get(&#34;style&#34;, &#34;contour&#34;)
    levels = kwargs.get(&#34;levels&#34;, 5)
    splits = None

    if colormap is &#34;default&#34;:
        clist = [(0.0, 0.0, 1.0),\
                (0.0, 1.0, 0.5),\
                (0.9, 1.0, 0.0),\
                (1.0, 0.75, 0.0),\
                (0.9, 0.0, 0.0)]
        colormap = mcol.ListedColormap(clist)

    ax, fig = _make_ax_if_none(ax)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#39;right&#39;, size=&#39;3%&#39;, pad=0.05)
    if smooth:
        fmap = place_data[&#39;smoothMap&#39;]
    else:
        fmap = place_data[&#39;firingMap&#39;]

    if style == &#34;digitized&#34;:
        res = ax.pcolormesh(
            place_data[&#39;xedges&#39;], place_data[&#39;yedges&#39;],
            np.ma.array(fmap, mask=np.isnan(fmap)),
            cmap=colormap, rasterized=True)

    elif style == &#34;interpolated&#34;:
        extent = (
            0, place_data[&#39;xedges&#39;].max(),
            0, place_data[&#39;yedges&#39;].max())
        tp = fmap[:-1, :-1]
        res = ax.imshow(
            tp, cmap=colormap,
            extent=extent, interpolation=&#34;bicubic&#34;,
            origin=&#34;lower&#34;)

    elif style == &#34;contour&#34;:
        dx = np.mean(np.diff(place_data[&#39;xedges&#39;]))
        dy = np.mean(np.diff(place_data[&#39;yedges&#39;]))
        pad_map = np.pad(fmap[:-1, :-1], ((1, 1), (1, 1)), &#34;edge&#34;)
        vmin, vmax = np.nanmin(pad_map), np.nanmax(pad_map)
        if vmin != vmax:
            splits = np.linspace(vmin, vmax, levels+1)
        else:
            splits = np.array([vmin, vmin*2])
        x_edges = np.append(
            place_data[&#34;xedges&#34;] - dx/2,
            place_data[&#34;xedges&#34;][-1] + dx/2)
        y_edges = np.append(
            place_data[&#34;yedges&#34;] - dy/2,
            place_data[&#34;yedges&#34;][-1] + dy/2)
        res = ax.contourf(
            x_edges, y_edges,
            np.ma.array(pad_map, mask=np.isnan(pad_map)),
            levels=splits, cmap=colormap, corner_mask=True)

        # This produces it with no padding
        # res = ax.contourf(
        #     place_data[&#39;xedges&#39;][:-1] + dx / 2.,
        #     place_data[&#39;yedges&#39;][:-1] + dy / 2.,
        #     np.ma.array(fmap[:-1, :-1], mask=np.isnan(fmap[:-1, :-1])),
        #     levels=15, cmap=colormap, corner_mask=True)

    else:
        logging.error(&#34;Unrecognised style passed to loc_rate&#34;)
        return

    ax.set_ylim([0, place_data[&#39;yedges&#39;].max()])
    ax.set_xlim([0, place_data[&#39;xedges&#39;].max()])
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    cbar = plt.colorbar(res, cax=cax, orientation=&#39;vertical&#39;, use_gridspec=True)
    # cbar.ax.set_ticks(levels)
    # cbar.ax.set_yticklabels(np.around(levels, decimals=1))
    if splits is not None:
        split_text = np.around(splits, decimals=1)
        cbar.ax.set_yticklabels(split_text)

    return ax

def loc_firing(place_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of locational correlation to spike-rate

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to head-directional correlation

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        Spike-plot and firing rate map in two subplots respectively

    &#34;&#34;&#34;
    fig = plt.figure()

    ax = loc_spike(place_data, ax=fig.add_subplot(121))
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)

    ax = loc_rate(place_data, ax=fig.add_subplot(122))
    ax.set_xlabel(&#39;cm&#39;)
    #ax.set_ylabel(&#39;YLoc&#39;)
#    fig.colorbar(cax)
    fig.set_tight_layout(True)
    return fig

# Created by Sean Martin: 14/02/2019
def loc_firing_and_place(place_data, smooth=True):
    &#34;&#34;&#34;
    Plots the analysis replay_data of locational correlation to spike-rate
    with a place map

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to head-directional correlation

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        Spike-plot and firing rate map and place field in three subplots respectively

    &#34;&#34;&#34;
    fig = plt.figure()

    ax1 = loc_spike(place_data, ax=fig.add_subplot(131))
    ax1.set_xlabel(&#39;cm&#39;)
    ax1.set_ylabel(&#39;cm&#39;)

    ax2 = loc_rate(place_data, ax=fig.add_subplot(132, sharey=ax1), smooth=smooth)
    ax2.set_xlabel(&#39;cm&#39;)

    ax3 = loc_place_field(place_data, ax=fig.add_subplot(133, sharey=ax1))
    ax3.set_xlabel(&#39;cm&#39;)

    fig.set_tight_layout(True)
    plt.subplots_adjust(wspace=0.25)
    return fig

# Created by Sean Martin: 13/02/2019
def loc_place_field(place_data, ax=None):
    &#34;&#34;&#34;
    Plots the location of the place field(s) of the unit.

    Parameters
    ----------
    place_data : dict
        Graphical data from the correlation of unit firing to location of the animal
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.

    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the spike-plot

    &#34;&#34;&#34;

    # spatial place field
    ax, _ = _make_ax_if_none(ax)
    clist = [(0.0, 0.0, 1.0),\
            (0.0, 1.0, 0.5),\
            (0.9, 1.0, 0.0),\
            (1.0, 0.75, 0.0),\
            (0.9, 0.0, 0.0)]
    c_map = mcol.ListedColormap(clist)

    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#39;right&#39;, size=&#39;3%&#39;, pad=0.05)
    mask = (place_data[&#39;placeField&#39;] == 0)
    pmap= ax.pcolormesh(place_data[&#39;xedges&#39;], place_data[&#39;yedges&#39;],
                        np.ma.array(place_data[&#39;placeField&#39;], mask=mask),
                        cmap=c_map, rasterized=True)
    ax.set_ylim([0, place_data[&#39;yedges&#39;].max()])
    ax.set_xlim([0, place_data[&#39;xedges&#39;].max()])
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    centroid = place_data[&#39;centroid&#39;]
    ax.plot([centroid[0]], [centroid[1]], &#39;gX&#39;)
    plt.colorbar(pmap, cax=cax, orientation=&#39;vertical&#39;, use_gridspec=True)
#        plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    return ax

# Created by Sean Martin: 13/02/2019
def loc_place_centroid(place_data, centroid):
    &#34;&#34;&#34;
    Plots the analysis replay_data of locational correlation to spike-rate
    along with the centroid of the place field.

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to head-directional correlation
    centroid : ndarray
        The centroid of the place field

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        Spike-plot and firing rate map in two subplots respectively

    &#34;&#34;&#34;
    fig = plt.figure()

    ax = loc_spike(place_data, ax=fig.add_subplot(121))
    ax.plot([centroid[0]], [centroid[1]], &#39;gX&#39;)
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)

    ax = loc_rate(place_data, ax=fig.add_subplot(122))
    ax.plot([centroid[0]], [centroid[1]], &#39;gX&#39;)
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)
    plt.tight_layout()
    return fig

def loc_spike_time_lapse(place_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational time-lapse analysis

    Parameters
    ----------
    place_data : dict
        Graphical data from locational time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed spike-plots

    &#34;&#34;&#34;

    keys = [key[1] for key in list(enumerate(place_data.keys()))]
    fig = []
    axs = []
    keys = list(place_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, sharex=&#39;col&#39;, sharey=&#39;row&#39;)
        fig.append(f)
        axs.extend(list(ax.flatten()))

    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            loc_spike(place_data[key], ax=ax)
            nice_key = _nice_lapse_key(key)
            ax.set_title(nice_key)
        else:
            ax.set_visible(False)

    return fig

def loc_rate_time_lapse(place_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational time-lapse analysis

    Parameters
    ----------
    place_data : dict
        Graphical data from locational time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed firing-rate map

    &#34;&#34;&#34;

    keys = [key[1] for key in list(enumerate(place_data.keys()))]

    fig = []
    axs = []
    keys = list(place_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, sharex=&#39;col&#39;, sharey=&#39;row&#39;)
        fig.append(f)
        axs.extend(list(ax.flatten()))

    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            loc_rate(place_data[key], ax=ax)
            nice_key = _nice_lapse_key(key)
            ax.set_title(nice_key)
        else:
            ax.set_visible(False)

    return fig

def loc_shuffle(loc_shuffle_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational shuffling analysis

    Parameters
    ----------
    loc_shuffle_data : dict
        Graphical data from head-directional shuffling anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distribution of Skaggs IC, sparsity and spatial coherecne in three subplots

    &#34;&#34;&#34;

    # Loactional shuffling analysis
    fig1 = plt.figure()
#    ax= plt.gca()
    ax = fig1.add_subplot(221)
    ax.bar(loc_shuffle_data[&#39;skaggsEdges&#39;][:-1], loc_shuffle_data[&#39;skaggsCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
           width=np.diff(loc_shuffle_data[&#39;skaggsEdges&#39;]).mean(), rasterized=True)
    ax.plot([loc_shuffle_data[&#39;skaggs95&#39;], loc_shuffle_data[&#39;skaggs95&#39;]], \
            [0, loc_shuffle_data[&#39;skaggsCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
#        ax.plot([loc_shuffle_data[&#39;refSkaggs&#39;], loc_shuffle_data[&#39;refSkaggs&#39;]], \
#                [0, loc_shuffle_data[&#39;skaggsCount&#39;].max()], color=&#39;green&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Skaggs IC&#39;)
#    ax.set_ylabel(&#39;Count&#39;, fontsize=12)

    ax = fig1.add_subplot(222)
    ax.bar(loc_shuffle_data[&#39;sparsityEdges&#39;][:-1], loc_shuffle_data[&#39;sparsityCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=np.diff(loc_shuffle_data[&#39;sparsityEdges&#39;]).mean(), rasterized=True)
    ax.plot([loc_shuffle_data[&#39;sparsity05&#39;], loc_shuffle_data[&#39;sparsity05&#39;]], \
            [0, loc_shuffle_data[&#39;sparsityCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
#        ax.plot([loc_shuffle_data[&#39;refSparsity&#39;], loc_shuffle_data[&#39;refSparsity&#39;]], \
#                [0, loc_shuffle_data[&#39;sparsityCount&#39;].max()], color=&#39;green&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Sparsity&#39;)

    ax = fig1.add_subplot(223)
    ax.bar(loc_shuffle_data[&#39;coherenceEdges&#39;][:-1], loc_shuffle_data[&#39;coherenceCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=np.diff(loc_shuffle_data[&#39;coherenceEdges&#39;]).mean(), rasterized=True)
    ax.plot([loc_shuffle_data[&#39;coherence95&#39;], loc_shuffle_data[&#39;coherence95&#39;]], \
            [0, loc_shuffle_data[&#39;coherenceCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
#        ax.plot([loc_shuffle_data[&#39;refCoherence&#39;], loc_shuffle_data[&#39;refCoherence&#39;]], \
#                [0, loc_shuffle_data[&#39;coherenceCount&#39;].max()], color=&#39;green&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Coherence&#39;)

#    i= 0
#    labels= [&#39;Skaggs IC&#39;, &#39;Sparsity&#39;, &#39;Coherence&#39;]
    for ax in fig1.axes:
        ax.set_ylabel(&#39;Count&#39;)

    fig1.suptitle(&#39;Distribution of locational firing specificity indices&#39;)
    plt.subplots_adjust(hspace=0.35, wspace=0.23)

    return fig1

def loc_time_shift(loc_shift_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational time-shift analysis

    Parameters
    ----------
    loc_shift_data : dict
        Graphical data from head-directional time-shift anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Skaggs information content of locational firing in shifted time of spiking events
    fig2 : matplotlib.pyplot.Figure
        Sparsity of locational firing in shifted time of spiking events
    fig3 : matplotlib.pyplot.Figure
        Coherence of locational firing in shifted time of spiking events

    &#34;&#34;&#34;

    ## Locational time shift analysis

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;skaggs&#39;], linewidth=2, zorder=1)
    ax.scatter(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;skaggs&#39;], marker=&#39;o&#39;, color=RED, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;Skaggs IC&#39;)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_title(&#39;Skaggs IC of place firing in shifted time of spiking events&#39;)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.plot(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;sparsity&#39;], linewidth=2, zorder=1)
    ax.scatter(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;sparsity&#39;], marker=&#39;o&#39;, color=RED, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;Sparsity&#39;)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_title(&#39;Sparsity of place firing in shifted time of spiking events&#39;)

    fig3 = plt.figure()
    ax = plt.gca()
    ax.plot(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;coherence&#39;], linewidth=2, zorder=1)
    ax.scatter(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;coherence&#39;], marker=&#39;o&#39;, color=RED, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;Coherence&#39;)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_title(&#39;Coherence of place firing in shifted time of spiking events&#39;)

    #        for ax in fig1.axes:
    #            ax.set_xlabel(&#39;shift time&#39;)
    #        fig1.suptitle(&#39;Specifity indices in time shift&#39;)

    return fig1, fig2, fig3

def loc_auto_corr(locAuto_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational firing rate autocorrelation

    Parameters
    ----------
    locAuto_data : dict
        Graphical data from spatial correlation of firing map

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Spatial correlation map

    &#34;&#34;&#34;
    # Locational firing map autocorrelation
    clist = [(1.0, 1.0, 1.0),\
            (0.0, 0.0, 0.5),\
            (0.0, 0.0, 1.0),\
            (0.0, 0.5, 1.0),\
            (0.0, 0.75, 1.0),\
            (0.5, 1.0, 0.0),\
            (0.9, 1.0, 0.0),\
            (1.0, 0.75, 0.0),\
            (1.0, 0.4, 0.0),\
            (1.0, 0.0, 0.0),\
            (0.5, 0.0, 0.0)]

    c_map = mcol.ListedColormap(clist)

    fig1 = plt.figure()
    ax = fig1.gca()
    pc = ax.pcolormesh(locAuto_data[&#39;xshift&#39;], locAuto_data[&#39;yshift&#39;], np.ma.array(locAuto_data[&#39;corrMap&#39;], \
                    mask=np.isnan(locAuto_data[&#39;corrMap&#39;])), cmap=c_map, rasterized=True)
    ax.set_title(&#39;Spatial correlation of firing intensity map)&#39;)
    ax.set_xlabel(&#39;X-lag&#39;)
    ax.set_ylabel(&#39;Y-lag&#39;)
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    ax.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.colorbar(pc)

    return fig1

def rot_corr(plot_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of rotational correlation of spatial autocorrelation map.

    Parameters
    ----------
    plot_data : dict
        Graphical data from spatial correlation of firing map

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Rotational correlation plot

    &#34;&#34;&#34;

    # Location firing map rotational analysis
    fig1 = plt.figure()
    ax = fig1.gca()
    ax.plot(plot_data[&#39;rotAngle&#39;], plot_data[&#39;rotCorr&#39;], linewidth=2, zorder=1)
    ax.set_ylim([-1, 1])
    ax.set_xlim([0, 360])
    #plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Rotational correlation of spatial firing map&#39;)
    ax.set_xlabel(&#39;Rotation angle&#39;)
    ax.set_ylabel(&#39;Pearson correlation&#39;)

    return fig1

def dist_rate(dist_data):
    &#34;&#34;&#34;
    Plots the firing rate vs distance from border

    Parameters
    ----------
    dist_data : dict
        Graphical data from border and gradient analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distance from border vs spike rate

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(dist_data[&#39;distBins&#39;], dist_data[&#39;smoothRate&#39;], marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2, label=&#39;Firing rate&#39;)
    if &#39;rateFit&#39; in dist_data.keys():
        ax.plot(dist_data[&#39;distBins&#39;], dist_data[&#39;rateFit&#39;], &#39;go-&#39;, markerfacecolor=&#39;brown&#39;, linewidth=2, label=&#39;Fitted rate&#39;)
    ax.set_title(&#39;Distance from border vs spike rate&#39;)
    ax.set_xlabel(&#39;Distance (cm)&#39;)
    ax.set_ylabel(&#39;Rate (spikes/sec)&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.legend(loc=&#39;lower right&#39;)

    return fig1

def stair_plot(dist_data):
    &#34;&#34;&#34;
    Plots the stairs of mean distance vs firing-rate bands

    Parameters
    ----------
    dist_data : dict
        Graphical data from border and gradient analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Mean distance distance from border vs firing-rate percentage

    &#34;&#34;&#34;

    perSteps = dist_data[&#39;perSteps&#39;]
    perDist = dist_data[&#39;perDist&#39;]
    stepsize = np.diff(perSteps).mean()

    fig1 = plt.figure()
    ax = plt.gca()
    for i, step in enumerate(perSteps):
        ax.plot([step, step+ stepsize], [perDist[i], perDist[i]], color=&#39;b&#39;, linestyle=&#39;--&#39;, marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
        if i &gt; 0: #perSteps.shape[0]:
            ax.plot([step, step], [perDist[i-1], perDist[i]], color=&#39;b&#39;, linestyle=&#39;--&#39;, linewidth=2)
    ax.set_xlabel(&#39;% firing rate (spikes/sec)&#39;)
    ax.set_ylabel(&#39;Mean distance (cm)&#39;)

    return fig1

def border(border_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data from border analysis

    Parameters
    ----------
    border_data : dict
        Graphical data from border analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Histogram of taxicab distance of active pixels
    fig2 : matplotlib.pyplot.Figure
        Angular distance of pixels vs active pixel count
    fig3 : matplotlib.pyplot.Figure
        Distance from border vs spike rate
    fig4 : matplotlib.pyplot.Figure
        Mean distance distance from border vs firing-rate percentage

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = fig1.add_subplot(211)
    ax.bar(border_data[&#39;distBins&#39;], border_data[&#39;distCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=0.5*np.diff(border_data[&#39;distBins&#39;]).mean())
    ax.set_title(&#39;Histogram of taxicab distance of active pixels&#39;)
    ax.set_xlabel(&#39;Taxicab distance(cm)&#39;)
    ax.set_ylabel(&#39;Active pixel count&#39;)

    ax = fig1.add_subplot(212)
    ax.bar(border_data[&#39;circBins&#39;], border_data[&#39;angDistCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=0.5*np.diff(border_data[&#39;circBins&#39;]).mean())
    ax.set_title(&#39;Angular distance vs Active pixel count&#39;)
    ax.set_xlabel(&#39;Angular distance&#39;)
    ax.set_ylabel(&#39;Active pixel count&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.subplots_adjust(hspace=0.5)
    fig2 = plt.figure()
    ax = plt.gca()
    pcm = ax.pcolormesh(border_data[&#39;cBinsInterp&#39;], border_data[&#39;dBinsInterp&#39;], \
                       border_data[&#39;circLinMap&#39;], cmap=&#39;seismic&#39;, rasterized=True)
    ax.invert_yaxis()
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Histogram for angle vs distance from border of active pixels&#39;)
    ax.set_xlabel(&#39;Angular distance (Deg)&#39;)
    ax.set_ylabel(&#39;Taxicab distance (cm)&#39;)
    fig2.colorbar(pcm)

    fig3 = dist_rate(border_data)
    fig4 = stair_plot(border_data)

    return fig1, fig2, fig3, fig4

def gradient(gradient_data):
    &#34;&#34;&#34;
    Plots the replay_data from gradient cell analysis

    Parameters
    ----------
    border_data : dict
        Graphical data from border analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distance from border vs spike rate
    fig2 : matplotlib.pyplot.Figure
        Differential firing rate vs distance from border
    fig3 : matplotlib.pyplot.Figure
        Mean distance distance from border vs firing-rate percentage

    &#34;&#34;&#34;

    fig1 = dist_rate(gradient_data)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.plot(gradient_data[&#39;distBins&#39;], gradient_data[&#39;diffRate&#39;], color=BLUE, marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
    ax.set_title(&#39;Differential firing rate (fitted)&#39;)
    ax.set_xlabel(&#39;Distance (cm)&#39;)
    ax.set_ylabel(&#39;Differential rate (spikes/sec)&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)

    fig3 = stair_plot(gradient_data)

    return fig1, fig2, fig3

def grid(grid_data):
    &#34;&#34;&#34;
    Plots the replay_data from grid analysis

    Parameters
    ----------
    grid_data : dict
        Graphical data from border analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Autocorrelation of firing rate map, superimposed with central peaks
    fig2 : matplotlib.pyplot.Figure
        Rotational correlation of autocorrelation map

    &#34;&#34;&#34;

    fig1 = loc_auto_corr(grid_data)
    ax = fig1.axes[0]

    xmax = grid_data[&#39;xmax&#39;]
    ymax = grid_data[&#39;ymax&#39;]
    xshift = grid_data[&#39;xshift&#39;]

    ax.scatter(xmax, ymax, c=&#39;black&#39;, marker=&#39;s&#39;, zorder=2)
    for i in range(xmax.size):
        if i &lt; xmax.size-1:
            ax.plot([xmax[i], xmax[i+1]], [ymax[i], ymax[i+1]], &#39;k&#39;, linewidth=2)
        else:
            ax.plot([xmax[i], xmax[0]], [ymax[i], ymax[0]], &#39;k&#39;, linewidth=2)
    ax.plot(xshift[xshift &gt;= 0], np.zeros(find(xshift &gt;= 0).size), &#39;k--&#39;, linewidth=2)
    ax.plot(xshift[xshift &gt;= 0], xshift[xshift &gt;= 0]*ymax[0]/ xmax[0], &#39;k--&#39;, linewidth=2)
    ax.set_title(&#39;Grid cell analysis&#39;)
    ax.set_xlim([grid_data[&#39;xshift&#39;].min(), grid_data[&#39;xshift&#39;].max()])
    ax.set_ylim([grid_data[&#39;yshift&#39;].min(), grid_data[&#39;yshift&#39;].max()])
    ax.invert_yaxis()

    fig2 = None
    if &#39;rotAngle&#39; in grid_data.keys() and &#39;rotCorr&#39; in grid_data.keys():
        fig2 = rot_corr(grid_data)
        ax = fig2.axes[0]
        rmax = grid_data[&#39;rotCorr&#39;].max()
        rmin = grid_data[&#39;rotCorr&#39;].min()
        for i, th in enumerate(grid_data[&#39;anglemax&#39;]):
            ax.plot([th, th], [rmin, rmax], &#39;r--&#39;, linewidth=1)
        for i, th in enumerate(grid_data[&#39;anglemin&#39;]):
            ax.plot([th, th], [rmin, rmax], &#39;g--&#39;, linewidth=1)

        ax.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
        ax.set_title(&#39;Rotational correlation of autocorrelation map&#39;)

    if fig2:
        return fig1, fig2
    else:
        return fig1

def spike_raster(events, xlim=None, colors=[0, 0, 0], ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots the spike raster for a number of units

    Parameters
    ----------
    events : list
        The positions of the events
    xlim : tuple
        Optional start and end of raster plot
    colors :
        Optional list of colours, or single colour - default black
    ax : matplotlib.axes.Axes
        Optional axis to plot into
    **kwargs :
        A set of keyword arguments to change graph appearance

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        The spike raster
    &#34;&#34;&#34;
    linewidths = kwargs.get(&#34;linewidths&#34;, 0.1)
    linelengths = kwargs.get(&#34;linelengths&#34;, 0.5)
    title = kwargs.get(&#34;title&#34;, &#34;Spike raster&#34;)
    xlabel = kwargs.get(&#34;xlabel&#34;, &#34;Time (seconds)&#34;)
    ylabel = kwargs.get(&#34;ylabel&#34;, &#34;Cell ID&#34;)
    no_y_ticks = kwargs.get(&#34;no_y_ticks&#34;, False)
    orientation = kwargs.get(&#34;orientation&#34;, &#34;horizontal&#34;)

    ax, fig = _make_ax_if_none(ax)

    ax.eventplot(
        events, colors=colors, linelengths=linelengths, linewidths=linewidths,
        orientation=orientation)

    # Be sure to only pick integer tick locations.
    if orientation == &#34;horizontal&#34;:
        ax.yaxis.set_major_locator(ticker.MaxNLocator(integer=True))
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.invert_yaxis()
        if xlim is not None:
            ax.set_xlim(xlim[0], xlim[1])
    else:
        ax.xaxis.set_major_locator(ticker.MaxNLocator(integer=True))
        ax.set_xlabel(ylabel)
        ax.set_ylabel(xlabel)
        if xlim is not None:
            ax.set_ylim(xlim[0], xlim[1])
        ax.invert_yaxis()

    ax.set_title(title)

    if no_y_ticks:
        ax.get_yaxis().set_visible(False)

    return fig

def replay_summary(replay_data):
    &#34;&#34;&#34;
    Plot a replay data summary.

    Parameters
    ----------
    replay_data : dict
        Dictionary of graph data

    Returns
    -------
    fig : matplotlib.pyplot.Figure

    &#34;&#34;&#34;
    lfp_times = replay_data[&#34;lfp times&#34;]
    filtered_lfp = replay_data[&#34;lfp samples&#34;]
    mua_hist = replay_data[&#34;mua hists&#34;]
    swr_times = replay_data[&#34;swr times&#34;]
    num_cells = replay_data[&#34;num cells&#34;]
    spike_times = replay_data[&#34;spike times&#34;]

    colors = get_axona_colours()[:num_cells]
    xlim = (lfp_times[0], lfp_times[-1])

    # SWR and filtered LFP
    fig, axes= plt.subplots(
        nrows=3, ncols=1, figsize=(12,6), sharex=True)
    spike_raster(
        swr_times, ax=axes[0], ylabel=None, xlabel=None,
        no_y_ticks=True, colors=(&#39;b&#39;), linewidths=0.2, linelengths=0.5)
    axes[0].plot(lfp_times, filtered_lfp, color=&#39;k&#39;)
    axes[0].set_title(&#34;Filtered LFP and SWR Events&#34;)

    # MUA
    axes[1].plot(mua_hist[1], mua_hist[0], color=&#39;k&#39;)
    ticks = [i for i in range(num_cells + 1)]
    axes[1].set_yticks(ticks)
    axes[1].set_title(&#34;Number of Active Cells&#34;)

    # Raw spikes
    spike_raster(spike_times, linewidths=0.2, ax=axes[2], colors=colors)

    import matplotlib.ticker as ticker

    tick_spacing = 100
    for ax in axes:
        ax.set_xlim(xlim[0], xlim[1])
        ax.xaxis.set_major_locator(ticker.MultipleLocator(tick_spacing))

    plt.tight_layout()
    return fig

def plot_replay_sections(replay_data, spike_times, orientation=&#34;vertical&#34;):
    &#34;&#34;&#34;
    Plot zoomed in sections of the replay data spikes.

    Parameters
    ----------
    replay_data : dict
        Results from replay_summary
    spike_times : list
        A 3 tiered list, most commonly a list of nca.spike_times outputs
    orientation : str
        &#34;vertical&#34; or &#34;horizontal&#34; - the direction to plot rasters in

    Returns
    -------
    matplotlib.pyplot.Figure :
        Resulting multi Axes figure

    &#34;&#34;&#34;
    num_plots = len(replay_data[&#34;overlap swr mua&#34;])
    row_size = 6

    if num_plots &lt;= row_size:
        num_cols = num_plots
        num_rows = 1
    else:
        num_cols = row_size
        num_rows = math.ceil(num_plots / row_size)

    fig, axes = plt.subplots(
        nrows=num_rows, ncols=num_cols,
        sharex=&#39;col&#39;, tight_layout=True, figsize=(num_rows*2, num_cols*2))

    for i, i_range in enumerate(replay_data[&#34;overlap swr mua&#34;]):
        if num_plots == 1:
            ax = axes
        else:
            ax=axes.flatten()[i]
        # nca.spike_times(sleep_sample, ranges=[i_range])
        # can be used to get spike times
        spike_raster(
            spike_times[i],
            linewidths=1, ax=ax, orientation=orientation,
            colors=get_axona_colours()[:replay_data[&#34;num cells&#34;]],
            #xlim=(round(i_range[0], 1), round(i_range[1], 1)),
            title=None, ylabel=None, xlabel=None)
    return fig

def plot_angle_between_points(points, xlim, ylim, ax=None):
    &#34;&#34;&#34;
    Plots the angle between three points

    Parameters
    ----------
    points : list
        The list of points to plot the angle between
    xlim : float
        The upper xlimit of the graph
    ylim : float
        The upper ylimit of the graph
    ax : matplotlib.axes.Axes
        Optional axis to plot into

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        The angle between the points
    &#34;&#34;&#34;

    ax, fig = _make_ax_if_none(ax)
    arr = np.array(points)
    xdata = arr[:, 0]
    ydata = arr[:, 1]

    line_1 = Line2D(
        xdata[:2], ydata[:2], linewidth=1, linestyle = &#34;-&#34;, color=&#34;green&#34;,
        marker=&#34;.&#34;, markersize=10, markeredgecolor=&#39;k&#39;, markerfacecolor=&#39;k&#39;
    )
    line_2 = Line2D(
        xdata[1:], ydata[1:], linewidth=1, linestyle = &#34;-&#34;, color=&#34;red&#34;,
        marker=&#34;.&#34;, markersize=10, markeredgecolor=&#39;k&#39;, markerfacecolor=&#39;k&#39;)

    ax.add_line(line_1)
    ax.add_line(line_2)

    angle_plot = _get_angle_plot(line_1, line_2, 0.2, &#39;b&#39;, [xdata[1], ydata[1]], xlim, ylim)
    ax.add_patch(angle_plot) # To display the angle arc

    ax.set_ylim([0, ylim])
    ax.set_xlim([0, xlim])
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)
    txt_list = [&#34;P1&#34;, &#34;P2&#34;, &#34;P3&#34;]
    for i, txt in enumerate(txt_list):
        ax.annotate(txt, (xdata[i], ydata[i] - (ylim * 0.02)))
    ax.invert_yaxis()
    plt.tight_layout()
    plt.legend()
    return fig

def _get_angle_plot(
    line1, line2, offset = 1, color = None,
    origin = [0,0], len_x_axis = 1, len_y_axis = 1):
    &#34;&#34;&#34;
    Internal helper function to get an arc between two lines
    Can be displayed as a patch

    Parameters
    ----------
    line1 : matplotlib.lines.Line2D
        The first line
    line2 : matplotlib.lines.Line2D
        The second line
    offset : float
        How far out the patch should be from the origin
    color : string
        The color of the patch
    origin : list
        Where the centre of the patch should be
    len_x_axis: float
        How long the x axis is in the plot
    len_y_axis: float
        How long the y axis is in the plot

    Returns
    -------
    matplotlib.patches.Arc
        The arc which represents the angle between the lines
    &#34;&#34;&#34;

    l1xy = line1.get_xydata()
    further1 = l1xy[1] + [1, 0]
    # Angle between line1 and x-axis
    angle1 = angle_between_points(l1xy[0], l1xy[1], further1)
    if l1xy[0][1] &lt; l1xy[1][1]:
        angle1 = 360 - angle1


    l2xy = line2.get_xydata()
    further2 = l2xy[0] + [1, 0]
    # Angle between line1 and x-axis
    angle2 = angle_between_points(l2xy[1], l2xy[0], further2)
    if l2xy[1][1] &lt; l2xy[0][1]:
        angle2 = 360 - angle2

    theta1 = min(angle1, angle2)
    theta2 = max(angle1, angle2)

    angle = theta2 - theta1

    if color is None:
        color = line1.get_color() # Uses the color of line 1 if color parameter is not passed.

    return Arc(origin, len_x_axis*offset, len_y_axis*offset, 0, theta1, theta2, color=color, label = &#34;%0.2f&#34;%float(angle)+u&#34;\u00b0&#34;)

def _make_ax_if_none(ax, **kwargs):
    &#34;&#34;&#34;
    Makes a figure and gets the axis from this if no ax exists

    Parameters
    ----------
    ax : matplotlib.axes.Axes
        Input axis

    Returns
    -------
    ax, fig
        The created figure and axis if ax is None, else
        the input ax and None
    &#34;&#34;&#34;

    fig = None
    if ax is None:
        fig = plt.figure()
        ax = plt.gca(**kwargs)
    return ax, fig


def print_place_cells(
        rows, cols=7, size_multiplier=4, wspace=0.3, hspace=0.3,
        placedata=None, wavedata=None, graphdata=None, isidata=None,
        headdata=None, thetadata=None, point_size=10, units=None):
    fig = plt.figure(
        figsize=(cols * size_multiplier, rows * size_multiplier),
        tight_layout=False)
    gs = gridspec.GridSpec(rows, cols, wspace=wspace, hspace=hspace)

    for i in range(rows):
        # Plot the spike position
        place_data = placedata[i]
        if place_data is not None:
            ax = fig.add_subplot(gs[i, 0])
            if units == None:
                color = get_axona_colours(i)
            else:
                color = get_axona_colours(units[i] - 1)
            loc_spike(
                place_data, ax=ax, color=color,
                point_size=point_size)

            # Plot the rate map
            ax = fig.add_subplot(gs[i, 1])
            loc_rate(place_data, ax=ax, smooth=True)

        head_data = headdata[i]
        if head_data is not None:
            ax = fig.add_subplot(gs[i, 2], projection=&#39;polar&#39;)
            hd_rate(head_data, ax=ax, title=None)

        # Plot wave property
        if wavedata[i] is not None:
            ax = fig.add_subplot(gs[i, 3])
            largest_waveform(wavedata[i], ax=ax)

        # Plot -10 to 10 autocorrelation
        if graphdata[i] is not None:
            ax = fig.add_subplot(gs[i, 4])
            isi_corr(graphdata[i], ax=ax, title=None, xlabel=None, ylabel=None)

        if thetadata[i] is not None:
            ax = fig.add_subplot(gs[i, 5])
            theta_cell(thetadata[i], ax=ax, title=None,
                       xlabel=None, ylabel=None)

        if isidata[i] is not None:
            ax = fig.add_subplot(gs[i, 6])
            temp_fig, (ax1, ax2) = plt.subplots(2)
            isi(isidata[i], axes=[ax, ax1, ax2],
                title1=None, xlabel1=None, ylabel1=None)
            plt.close(temp_fig)

        plt.close(&#34;all&#34;)
        gc.collect()
    return fig</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="neurochat.nc_plot.angular_velocity"><code class="name flex">
<span>def <span class="ident">angular_velocity</span></span>(<span>angVel_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the angular head velocity of the animal vs spike rate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angVel_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to angular head velocity correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Scatter plot of angular velocity vs spike-rate superimposed with fitted rate</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def angular_velocity(angVel_data):
    &#34;&#34;&#34;
    Plots the angular head velocity of the animal vs spike rate

    Parameters
    ----------
    angVel_data : dict
        Graphical data from the unit firing to angular head velocity correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Scatter plot of angular velocity vs spike-rate superimposed with fitted rate

    &#34;&#34;&#34;

    ## Angular velocity analysis
    fig1 = plt.figure()
    ax = plt.gca()
    ax.scatter(angVel_data[&#39;leftBins&#39;], angVel_data[&#39;leftRate&#39;], c=BLUE, zorder=1)
    ax.plot(angVel_data[&#39;leftBins&#39;], angVel_data[&#39;leftFitRate&#39;], color=RED, linewidth=1.5, zorder=2)
    ax.scatter(angVel_data[&#39;rightBins&#39;], angVel_data[&#39;rightRate&#39;], c=BLUE, zorder=1)
    ax.plot(angVel_data[&#39;rightBins&#39;], angVel_data[&#39;rightFitRate&#39;], color=RED, linewidth=1.5, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Angular Velocity vs Spiking Rate&#39;)
    ax.set_xlabel(&#39;Angular velocity (deg/sec)&#39;)
    ax.set_ylabel(&#39;Spikes/sec&#39;)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.border"><code class="name flex">
<span>def <span class="ident">border</span></span>(<span>border_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data from border analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>border_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from border analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Histogram of taxicab distance of active pixels</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Angular distance of pixels vs active pixel count</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Distance from border vs spike rate</dd>
<dt><strong><code>fig4</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Mean distance distance from border vs firing-rate percentage</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def border(border_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data from border analysis

    Parameters
    ----------
    border_data : dict
        Graphical data from border analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Histogram of taxicab distance of active pixels
    fig2 : matplotlib.pyplot.Figure
        Angular distance of pixels vs active pixel count
    fig3 : matplotlib.pyplot.Figure
        Distance from border vs spike rate
    fig4 : matplotlib.pyplot.Figure
        Mean distance distance from border vs firing-rate percentage

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = fig1.add_subplot(211)
    ax.bar(border_data[&#39;distBins&#39;], border_data[&#39;distCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=0.5*np.diff(border_data[&#39;distBins&#39;]).mean())
    ax.set_title(&#39;Histogram of taxicab distance of active pixels&#39;)
    ax.set_xlabel(&#39;Taxicab distance(cm)&#39;)
    ax.set_ylabel(&#39;Active pixel count&#39;)

    ax = fig1.add_subplot(212)
    ax.bar(border_data[&#39;circBins&#39;], border_data[&#39;angDistCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=0.5*np.diff(border_data[&#39;circBins&#39;]).mean())
    ax.set_title(&#39;Angular distance vs Active pixel count&#39;)
    ax.set_xlabel(&#39;Angular distance&#39;)
    ax.set_ylabel(&#39;Active pixel count&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.subplots_adjust(hspace=0.5)
    fig2 = plt.figure()
    ax = plt.gca()
    pcm = ax.pcolormesh(border_data[&#39;cBinsInterp&#39;], border_data[&#39;dBinsInterp&#39;], \
                       border_data[&#39;circLinMap&#39;], cmap=&#39;seismic&#39;, rasterized=True)
    ax.invert_yaxis()
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Histogram for angle vs distance from border of active pixels&#39;)
    ax.set_xlabel(&#39;Angular distance (Deg)&#39;)
    ax.set_ylabel(&#39;Taxicab distance (cm)&#39;)
    fig2.colorbar(pcm)

    fig3 = dist_rate(border_data)
    fig4 = stair_plot(border_data)

    return fig1, fig2, fig3, fig4</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.dist_rate"><code class="name flex">
<span>def <span class="ident">dist_rate</span></span>(<span>dist_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the firing rate vs distance from border</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dist_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from border and gradient analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Distance from border vs spike rate</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def dist_rate(dist_data):
    &#34;&#34;&#34;
    Plots the firing rate vs distance from border

    Parameters
    ----------
    dist_data : dict
        Graphical data from border and gradient analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distance from border vs spike rate

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(dist_data[&#39;distBins&#39;], dist_data[&#39;smoothRate&#39;], marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2, label=&#39;Firing rate&#39;)
    if &#39;rateFit&#39; in dist_data.keys():
        ax.plot(dist_data[&#39;distBins&#39;], dist_data[&#39;rateFit&#39;], &#39;go-&#39;, markerfacecolor=&#39;brown&#39;, linewidth=2, label=&#39;Fitted rate&#39;)
    ax.set_title(&#39;Distance from border vs spike rate&#39;)
    ax.set_xlabel(&#39;Distance (cm)&#39;)
    ax.set_ylabel(&#39;Rate (spikes/sec)&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.legend(loc=&#39;lower right&#39;)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>gradient_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the replay_data from gradient cell analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>border_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from border analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Distance from border vs spike rate</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Differential firing rate vs distance from border</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Mean distance distance from border vs firing-rate percentage</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gradient(gradient_data):
    &#34;&#34;&#34;
    Plots the replay_data from gradient cell analysis

    Parameters
    ----------
    border_data : dict
        Graphical data from border analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distance from border vs spike rate
    fig2 : matplotlib.pyplot.Figure
        Differential firing rate vs distance from border
    fig3 : matplotlib.pyplot.Figure
        Mean distance distance from border vs firing-rate percentage

    &#34;&#34;&#34;

    fig1 = dist_rate(gradient_data)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.plot(gradient_data[&#39;distBins&#39;], gradient_data[&#39;diffRate&#39;], color=BLUE, marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
    ax.set_title(&#39;Differential firing rate (fitted)&#39;)
    ax.set_xlabel(&#39;Distance (cm)&#39;)
    ax.set_ylabel(&#39;Differential rate (spikes/sec)&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)

    fig3 = stair_plot(gradient_data)

    return fig1, fig2, fig3</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>grid_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the replay_data from grid analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from border analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Autocorrelation of firing rate map, superimposed with central peaks</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Rotational correlation of autocorrelation map</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def grid(grid_data):
    &#34;&#34;&#34;
    Plots the replay_data from grid analysis

    Parameters
    ----------
    grid_data : dict
        Graphical data from border analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Autocorrelation of firing rate map, superimposed with central peaks
    fig2 : matplotlib.pyplot.Figure
        Rotational correlation of autocorrelation map

    &#34;&#34;&#34;

    fig1 = loc_auto_corr(grid_data)
    ax = fig1.axes[0]

    xmax = grid_data[&#39;xmax&#39;]
    ymax = grid_data[&#39;ymax&#39;]
    xshift = grid_data[&#39;xshift&#39;]

    ax.scatter(xmax, ymax, c=&#39;black&#39;, marker=&#39;s&#39;, zorder=2)
    for i in range(xmax.size):
        if i &lt; xmax.size-1:
            ax.plot([xmax[i], xmax[i+1]], [ymax[i], ymax[i+1]], &#39;k&#39;, linewidth=2)
        else:
            ax.plot([xmax[i], xmax[0]], [ymax[i], ymax[0]], &#39;k&#39;, linewidth=2)
    ax.plot(xshift[xshift &gt;= 0], np.zeros(find(xshift &gt;= 0).size), &#39;k--&#39;, linewidth=2)
    ax.plot(xshift[xshift &gt;= 0], xshift[xshift &gt;= 0]*ymax[0]/ xmax[0], &#39;k--&#39;, linewidth=2)
    ax.set_title(&#39;Grid cell analysis&#39;)
    ax.set_xlim([grid_data[&#39;xshift&#39;].min(), grid_data[&#39;xshift&#39;].max()])
    ax.set_ylim([grid_data[&#39;yshift&#39;].min(), grid_data[&#39;yshift&#39;].max()])
    ax.invert_yaxis()

    fig2 = None
    if &#39;rotAngle&#39; in grid_data.keys() and &#39;rotCorr&#39; in grid_data.keys():
        fig2 = rot_corr(grid_data)
        ax = fig2.axes[0]
        rmax = grid_data[&#39;rotCorr&#39;].max()
        rmin = grid_data[&#39;rotCorr&#39;].min()
        for i, th in enumerate(grid_data[&#39;anglemax&#39;]):
            ax.plot([th, th], [rmin, rmax], &#39;r--&#39;, linewidth=1)
        for i, th in enumerate(grid_data[&#39;anglemin&#39;]):
            ax.plot([th, th], [rmin, rmax], &#39;g--&#39;, linewidth=1)

        ax.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
        ax.set_title(&#39;Rotational correlation of autocorrelation map&#39;)

    if fig2:
        return fig1, fig2
    else:
        return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_firing"><code class="name flex">
<span>def <span class="ident">hd_firing</span></span>(<span>hd_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of head directional correlation to spike-rate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-directional correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Polar plot of head-direction during spiking-events</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Polar plot of head-direction vs spike-rate. Predicted firing rate is also plotted.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_firing(hd_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of head directional correlation to spike-rate

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-directional correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Polar plot of head-direction during spiking-events
    fig2 : matplotlib.pyplot.Figure
        Polar plot of head-direction vs spike-rate. Predicted firing rate is also plotted.

    &#34;&#34;&#34;

    fig1 = plt.figure()
    hd_spike(hd_data, ax=plt.gca(polar=True))

    fig2 = plt.figure()
    ax2 = hd_rate(hd_data, ax=plt.gca(polar=True))
    bins = np.append(hd_data[&#39;bins&#39;], hd_data[&#39;bins&#39;][0])
    predRate = np.append(hd_data[&#39;hdPred&#39;], hd_data[&#39;hdPred&#39;][0])
    ax2.plot(np.radians(bins), predRate, color=&#39;green&#39;)
    ax2.set_rticks([hd_data[&#39;hdRate&#39;].max(), hd_data[&#39;hdPred&#39;].max()])

    return fig1, fig2</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_rate"><code class="name flex">
<span>def <span class="ident">hd_rate</span></span>(<span>hd_data, ax=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot head direction vs spike rate.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-direction correlation</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Polar Axes object. If specified, the figure is plotted in this axes.</dd>
</dl>
<p>kwargs :</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Axes of the polar plot of head-direction vs spike-rate.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_rate(hd_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plot head direction vs spike rate.

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-direction correlation
    ax : matplotlib.axes.Axes
        Polar Axes object. If specified, the figure is plotted in this axes.
    kwargs :

    Returns
    -------
    ax : matplotlib.axes.Axes
        Axes of the polar plot of head-direction vs spike-rate.

    &#34;&#34;&#34;
    title = kwargs.get(&#34;title&#34;, &#34;Head directional firing rate&#34;)
    if not ax:
        plt.figure()
        ax = plt.gca(polar=True)

    bins = np.append(hd_data[&#39;bins&#39;], hd_data[&#39;bins&#39;][0])
    rate = np.append(hd_data[&#39;smoothRate&#39;], hd_data[&#39;smoothRate&#39;][0])
    ax.plot(np.radians(bins), rate, color=BLUE)

    ax.set_title(title)
    ax.set_rticks([hd_data[&#39;hdRate&#39;].max()])

    return ax</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_rate_ccw"><code class="name flex">
<span>def <span class="ident">hd_rate_ccw</span></span>(<span>hd_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of head directional correlation to spike-rate
but split into counterclockwise and clockwise head-movements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-direction correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Polar plot of head-direction vs spike-rate in
clockwise and counterclockwise
head movements</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_rate_ccw(hd_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of head directional correlation to spike-rate
    but split into counterclockwise and clockwise head-movements.

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-direction correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Polar plot of head-direction vs spike-rate in  clockwise and counterclockwise
        head movements

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca(polar=True)
    ax.plot(np.radians(hd_data[&#39;bins&#39;]), hd_data[&#39;hdRateCW&#39;], color=BLUE)
    ax.plot(np.radians(hd_data[&#39;bins&#39;]), hd_data[&#39;hdRateCCW&#39;], color=RED)
    ax.set_title(&#39;Counter/clockwise firing rate&#39;)
    ax.set_rticks([hd_data[&#39;hdRateCW&#39;].max(), hd_data[&#39;hdRateCCW&#39;].max()])

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_rate_time_lapse"><code class="name flex">
<span>def <span class="ident">hd_rate_time_lapse</span></span>(<span>hd_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of head directional time-lapse analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from head-directional time-lapsed anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>list</code> of <code>matplotlib.pyplot.Figure</code></dt>
<dd>Time-lapsed head-drectional firing rate plot</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_rate_time_lapse(hd_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional time-lapse analysis

    Parameters
    ----------
    hd_data : dict
        Graphical data from head-directional time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed head-drectional firing rate plot

    &#34;&#34;&#34;

    keys = [key[1] for key in list(enumerate(hd_data.keys()))]
    fig = []
    axs = []
    keys = list(hd_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, subplot_kw=dict(projection=&#39;polar&#39;))
        plt.subplots_adjust(top=0.9, hspace=0.55)
        fig.append(f)
        axs.extend(list(ax.flatten()))
        
    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            nice_key = _nice_lapse_key(key)
            ax = hd_rate(hd_data[key], ax=ax)
            ax.set_title(nice_key, y=1, fontsize=10)
        else:
            ax.set_visible(False)
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_shuffle"><code class="name flex">
<span>def <span class="ident">hd_shuffle</span></span>(<span>hd_shuffle_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of head directional shuffling analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_shuffle_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from head-directional shuffling anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Distribution of Rayleigh Z statistics</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Distribution of Von Mises concentration parameter Kapppa</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_shuffle(hd_shuffle_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional shuffling analysis

    Parameters
    ----------
    hd_shuffle_data : dict
        Graphical data from head-directional shuffling anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distribution of Rayleigh Z statistics
    fig2 : matplotlib.pyplot.Figure
        Distribution of Von Mises concentration parameter Kapppa

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    ax.bar(hd_shuffle_data[&#39;raylZEdges&#39;], hd_shuffle_data[&#39;raylZCount&#39;],\
           color=&#39;slateblue&#39;, alpha=0.6,\
           width=np.diff(hd_shuffle_data[&#39;raylZEdges&#39;]).mean(), rasterized=True)
    ax.plot([hd_shuffle_data[&#39;raylZPer95&#39;], hd_shuffle_data[&#39;raylZPer95&#39;]], \
            [0, hd_shuffle_data[&#39;raylZCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Rayleigh Z distribution for shuffled spikes (red= 95th percentile)&#39;)
    ax.set_xlabel(&#39;Rayleigh Z score&#39;)
    ax.set_ylabel(&#39;Count&#39;)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.bar(hd_shuffle_data[&#39;vonMisesKEdges&#39;], hd_shuffle_data[&#39;vonMisesKCount&#39;],\
           color=&#39;slateblue&#39;, alpha=0.6, \
           width=np.diff(hd_shuffle_data[&#39;vonMisesKEdges&#39;]).mean(), rasterized=True)
    ax.plot([hd_shuffle_data[&#39;vonMisesKPer95&#39;], hd_shuffle_data[&#39;vonMisesKPer95&#39;]], \
            [0, hd_shuffle_data[&#39;vonMisesKCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;von Mises kappa distribution for shuffled spikes \n (red= 95th percentile)&#39;)
    ax.set_xlabel(&#39;von Mises kappa&#39;)
    ax.set_ylabel(&#39;Count&#39;)

    return fig1, fig2</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_spike"><code class="name flex">
<span>def <span class="ident">hd_spike</span></span>(<span>hd_data, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the head-direction of the animal at the time of spiking-events in polar scatter plot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-direction correlation</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axis</code></dt>
<dd>Axis object. If specified, the figure is plotted in this axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.Axis</code></dt>
<dd>Axis of the polar plot of head-direction during spiking events.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_spike(hd_data, ax=None):
    &#34;&#34;&#34;
    Plots the head-direction of the animal at the time of spiking-events in polar scatter plot.

    Parameters
    ----------
    hd_data : dict
        Graphical data from the unit firing to head-direction correlation
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.

    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the polar plot of head-direction during spiking events.

    &#34;&#34;&#34;

    if not ax:
        plt.figure()
        ax = plt.gca(polar=True)

    ax.scatter(np.radians(hd_data[&#39;scatter_bins&#39;]), hd_data[&#39;scatter_radius&#39;], \
             s=1, c=RED, alpha=0.75, edgecolors=&#39;none&#39;, rasterized=True)
    ax.set_rticks([])
    ax.spines[&#39;polar&#39;].set_visible(False)

    return ax</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_spike_time_lapse"><code class="name flex">
<span>def <span class="ident">hd_spike_time_lapse</span></span>(<span>hd_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of head directional time-lapse analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from head-directional time-lapsed anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>list</code> of <code>matplotlib.pyplot.Figure</code></dt>
<dd>Time-lapsed spike-plots</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_spike_time_lapse(hd_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional time-lapse analysis

    Parameters
    ----------
    hd_data : dict
        Graphical data from head-directional time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed spike-plots

    &#34;&#34;&#34;


    keys = [key[1] for key in list(enumerate(hd_data.keys()))]
    fig = []
    axs = []
    keys = list(hd_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, subplot_kw=dict(projection=&#39;polar&#39;))
        plt.subplots_adjust(top=0.9, hspace=0.55)
        fig.append(f)
        axs.extend(list(ax.flatten()))
        
    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            nice_key = _nice_lapse_key(key)
            ax = hd_spike(hd_data[key], ax=ax)
            ax.set_title(nice_key, y=1, fontsize=10)
        else:
            ax.set_visible(False)
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.hd_time_shift"><code class="name flex">
<span>def <span class="ident">hd_time_shift</span></span>(<span>hd_shift_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of head directional time-shift analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hd_shift_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from head-directional time-shift anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Skaggs information content of head directional firing in shifted time of spiking events</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Peak firing rate of head directional firing in shifted time of spiking events</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Skaggs information content of head directional firing in shifted time of spiking events</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hd_time_shift(hd_shift_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of head directional time-shift analysis

    Parameters
    ----------
    hd_shift_data : dict
        Graphical data from head-directional time-shift anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Skaggs information content of head directional firing in shifted time of spiking events
    fig2 : matplotlib.pyplot.Figure
        Peak firing rate of head directional firing in shifted time of spiking events
    fig3 : matplotlib.pyplot.Figure
        Skaggs information content of head directional firing in shifted time of spiking events
    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;skaggs&#39;],\
            marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_ylabel(&#39;Skaggs IC&#39;)
    ax.set_title(&#39;Skaggs IC of hd firing in shifted time of spiking events&#39;)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;peakRate&#39;],\
            marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_ylabel(&#39;Peak firing rate (spikes/sec)&#39;)
    ax.set_title(&#39;Peak FR of hd firing in shifted time of spiking events&#39;)

    fig3 = plt.figure()
    ax = plt.gca()
    ax.scatter(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;delta&#39;], c=RED, zorder=3)
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], hd_shift_data[&#39;deltaFit&#39;], color=BLUE, linewidth=1.5, zorder=1)
    ax.plot(hd_shift_data[&#39;shiftTime&#39;], np.zeros(hd_shift_data[&#39;shiftTime&#39;].size), color=&#39;k&#39;, linestyle=&#39;--&#39;, linewidth=1.5, zorder=2)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_ylabel(&#39;Delta (degree)&#39;)
    ax.set_title(&#39;Delta of hd firing in shifted time of spiking events&#39;)

    return fig1, fig2, fig3</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.isi"><code class="name flex">
<span>def <span class="ident">isi</span></span>(<span>isi_data, axes=[None, None, None], **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots Interspike interval histogram and scatter plots of interval-before
vs interval-after.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>isi_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the ISI analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Histogram of ISI</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Scatter plot of ISI-before vs ISI-after in loglog scale</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>2D histogram of the ISI-before vs ISI-after in log-log scale</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isi(isi_data, axes=[None, None, None], **kwargs):
    &#34;&#34;&#34;
    Plots Interspike interval histogram and scatter plots of interval-before
    vs interval-after.

    Parameters
    ----------
    isi_data : dict
        Graphical data from the ISI analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Histogram of ISI
    fig2 : matplotlib.pyplot.Figure
        Scatter plot of ISI-before vs ISI-after in loglog scale
    fig3 : matplotlib.pyplot.Figure
        2D histogram of the ISI-before vs ISI-after in log-log scale

    &#34;&#34;&#34;

    # Plot ISI
    # histogram
    title = kwargs.get(&#34;title1&#34;, &#39;Distribution of inter-spike interval&#39;)
    xlabel = kwargs.get(&#34;xlabel1&#34;, &#39;ISI (ms)&#39;)
    ylabel = kwargs.get(&#34;ylabel1&#34;, &#39;Spike count&#39;)
    ax, fig1 = _make_ax_if_none(axes[0])
    ax.bar(isi_data[&#39;isiBins&#39;], isi_data[&#39;isiHist&#39;], color=&#39;darkblue&#39;, \
           edgecolor=&#39;darkblue&#39;, rasterized=True)
    ax.plot([5, 5,], [0, isi_data[&#39;maxCount&#39;]], linestyle=&#39;dashed&#39;,\
            linewidth=2, color=&#39;red&#39;)
    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    max_axis = isi_data[&#39;isiBins&#39;].max()
    max_axisLog = np.ceil(np.log10(max_axis))

    ## ISI scatterplot
    ax, fig2 = _make_ax_if_none(axes[1])
    ax.loglog(isi_data[&#39;isiBefore&#39;], isi_data[&#39;isiAfter&#39;], axes=ax, \
            linestyle=&#39; &#39;, marker=&#39;o&#39;, markersize=1, \
            markeredgecolor=&#39;k&#39;, markerfacecolor=None, rasterized=True)
#    ax.autoscale(enable= True, axis= &#39;both&#39;, tight= True)
    ax.plot(ax.get_xlim(), [5, 5], linestyle=&#39;dashed&#39;, linewidth=2, color=&#39;red&#39;)
    ax.set_aspect(1)
    #    ax.set_xlabel(&#39;Interval before (ms)&#39;)
    ax.set_ylabel(&#39;Interval after (ms)&#39;)
    ax.set_xlabel(&#39;Interval before (ms)&#39;)
    ax.set_title(&#39;Distribution of ISI \n (before and after spike)&#39;)

    #
    logBins = np.logspace(0, max_axisLog, max_axisLog*70)
    joint_count, xedges, yedges = np.histogram2d(isi_data[&#39;isiBefore&#39;],\
                                isi_data[&#39;isiAfter&#39;], bins=logBins)

    # Scatter colored
    _extent = [xedges[0], xedges[-2], yedges[0], yedges[-2]]

#        ax = fig2.add_subplot(212, aspect= &#39;equal&#39;)
    ax, fig3 = _make_ax_if_none(axes[2])
    c_map = plt.cm.jet
    c_map.set_under(&#39;white&#39;)
    ax.pcolormesh(xedges[0:-1], yedges[0:-1], joint_count,\
                  cmap=c_map, vmin=1, rasterized=True)
    ax.plot(ax.get_xlim(), [5, 5], linestyle=&#39;dashed&#39;, linewidth=2, color=&#39;red&#39;)
    plt.axis(_extent)
    ax.set_xscale(&#39;log&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;Interval before (ms)&#39;)
    ax.set_ylabel(&#39;Interval after (ms)&#39;)
    ax.set_title(&#39;Distribution of ISI \n (before and after spike)&#39;)

    return fig1, fig2, fig3</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.isi_corr"><code class="name flex">
<span>def <span class="ident">isi_corr</span></span>(<span>isi_corr_data, ax=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots ISI correlation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>isi_corr_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the ISI correlation</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Optional axes object to plot to.</dd>
</dl>
<p>kwargs :
title : str</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>ISI correlation histogram</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isi_corr(isi_corr_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots ISI correlation.

    Parameters
    ----------
    isi_corr_data : dict
        Graphical data from the ISI correlation
    ax : matplotlib.axes.Axes
        Optional axes object to plot to.
    kwargs :
        title : str

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        ISI correlation histogram

    &#34;&#34;&#34;
    isi_time = abs(isi_corr_data[&#39;isiCorrBins&#39;].min())
    default_title = (
        &#39;Autocorrelation Histogram \n ({}ms)&#39;.format(str(isi_time)))
    title = kwargs.get(&#34;title&#34;, default_title)
    xlabel = kwargs.get(&#34;xlabel&#34;, &#34;Time (ms)&#34;)
    ylabel = kwargs.get(&#34;ylabel&#34;, &#34;Counts&#34;)
    plot_theta = kwargs.get(&#34;plot_theta&#34;, False)

    ax, fig = _make_ax_if_none(ax)

    show_edges = False
    line_width = 1 if show_edges else 0
    all_bins = isi_corr_data[&#39;isiAllCorrBins&#39;]

    widths = [
        abs(all_bins[i+1] - all_bins[i]) for i in range(len(all_bins) - 1)]
    bin_centres = [
        (all_bins[i+1] + all_bins[i]) / 2 for i in range(len(all_bins) - 1)]
    ax.bar(bin_centres, isi_corr_data[&#39;isiCorr&#39;],
           width=widths, linewidth=line_width, color=&#39;darkblue&#39;,
           edgecolor=&#39;black&#39;, rasterized=True, align=&#39;center&#39;, antialiased=True)
    ax.tick_params(width=1.5)

    if plot_theta:
        ax.plot(bin_centres, isi_corr_data[&#39;corrFit&#39;], linewidth=2, color=&#39;red&#39;)

    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)

    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.largest_waveform"><code class="name flex">
<span>def <span class="ident">largest_waveform</span></span>(<span>wave_data, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot the largest waveform in electrode groups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wave_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data form the Waveform analysis</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Optional axes to plot to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.pyplot.Figure</code></dt>
<dd>The figure plotted to, or None if an axes is provided</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def largest_waveform(wave_data, ax=None):
    &#34;&#34;&#34;
    Plot the largest waveform in electrode groups.

    Parameters
    ----------
    wave_data : dict
        Graphical data form the Waveform analysis
    ax : matplotlib.axes.Axes
        Optional axes to plot to
    Returns
    -------
    matplotlib.pyplot.Figure
        The figure plotted to, or None if an axes is provided
    &#34;&#34;&#34;
    ax, fig = _make_ax_if_none(ax)

    mean_wave = wave_data[&#39;Mean wave&#39;][:, wave_data[&#34;Max channel&#34;]]
    std_wave = wave_data[&#39;Std wave&#39;][:, wave_data[&#34;Max channel&#34;]]
    ax.plot(mean_wave, color=&#39;black&#39;, linewidth=2.0)
    ax.plot(mean_wave+std_wave, color=&#39;green&#39;, linestyle=&#39;dashed&#39;)
    ax.plot(mean_wave-std_wave, color=&#39;green&#39;, linestyle=&#39;dashed&#39;)

    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.lfp_spectrum"><code class="name flex">
<span>def <span class="ident">lfp_spectrum</span></span>(<span>plot_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots LFP spectrum analysis data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the ISI correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Line plot of LFP spectrum using Welch's method</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lfp_spectrum(plot_data):
    &#34;&#34;&#34;
    Plots LFP spectrum analysis data

    Parameters
    ----------
    plot_data : dict
        Graphical data from the ISI correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Line plot of LFP spectrum using Welch&#39;s method

    &#34;&#34;&#34;


    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(plot_data[&#39;f&#39;], plot_data[&#39;Pxx&#39;], linewidth=2)
    ax.set_xlabel(&#39;Frequency (Hz)&#39;)
    ax.set_ylabel(&#39;PSD&#39;)
    _extent = [0, plot_data[&#39;f&#39;].max(), 0, plot_data[&#39;Pxx&#39;].max()]
    plt.axis(_extent)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.lfp_spectrum_tr"><code class="name flex">
<span>def <span class="ident">lfp_spectrum_tr</span></span>(<span>plot_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots time-resolved LFP spectrum analysis data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the ISI correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>3D plot of short-term FFT of the LFP signal</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def lfp_spectrum_tr(plot_data):
    &#34;&#34;&#34;
    Plots time-resolved LFP spectrum analysis data

    Parameters
    ----------
    plot_data : dict
        Graphical data from the ISI correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        3D plot of short-term FFT of the LFP signal

    &#34;&#34;&#34;

    fig1 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(plot_data[&#39;t&#39;], plot_data[&#39;f&#39;], plot_data[&#39;Sxx&#39;], cmap=c_map)
    _extent = [0, plot_data[&#39;t&#39;].max(), 0, plot_data[&#39;f&#39;].max()]
    plt.axis(_extent)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig1.colorbar(pcm)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_auto_corr"><code class="name flex">
<span>def <span class="ident">loc_auto_corr</span></span>(<span>locAuto_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of locational firing rate autocorrelation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>locAuto_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from spatial correlation of firing map</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Spatial correlation map</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_auto_corr(locAuto_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational firing rate autocorrelation

    Parameters
    ----------
    locAuto_data : dict
        Graphical data from spatial correlation of firing map

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Spatial correlation map

    &#34;&#34;&#34;
    # Locational firing map autocorrelation
    clist = [(1.0, 1.0, 1.0),\
            (0.0, 0.0, 0.5),\
            (0.0, 0.0, 1.0),\
            (0.0, 0.5, 1.0),\
            (0.0, 0.75, 1.0),\
            (0.5, 1.0, 0.0),\
            (0.9, 1.0, 0.0),\
            (1.0, 0.75, 0.0),\
            (1.0, 0.4, 0.0),\
            (1.0, 0.0, 0.0),\
            (0.5, 0.0, 0.0)]

    c_map = mcol.ListedColormap(clist)

    fig1 = plt.figure()
    ax = fig1.gca()
    pc = ax.pcolormesh(locAuto_data[&#39;xshift&#39;], locAuto_data[&#39;yshift&#39;], np.ma.array(locAuto_data[&#39;corrMap&#39;], \
                    mask=np.isnan(locAuto_data[&#39;corrMap&#39;])), cmap=c_map, rasterized=True)
    ax.set_title(&#39;Spatial correlation of firing intensity map)&#39;)
    ax.set_xlabel(&#39;X-lag&#39;)
    ax.set_ylabel(&#39;Y-lag&#39;)
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    ax.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.colorbar(pc)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_firing"><code class="name flex">
<span>def <span class="ident">loc_firing</span></span>(<span>place_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of locational correlation to spike-rate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-directional correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Spike-plot and firing rate map in two subplots respectively</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_firing(place_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of locational correlation to spike-rate

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to head-directional correlation

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        Spike-plot and firing rate map in two subplots respectively

    &#34;&#34;&#34;
    fig = plt.figure()

    ax = loc_spike(place_data, ax=fig.add_subplot(121))
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)

    ax = loc_rate(place_data, ax=fig.add_subplot(122))
    ax.set_xlabel(&#39;cm&#39;)
    #ax.set_ylabel(&#39;YLoc&#39;)
#    fig.colorbar(cax)
    fig.set_tight_layout(True)
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_firing_and_place"><code class="name flex">
<span>def <span class="ident">loc_firing_and_place</span></span>(<span>place_data, smooth=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of locational correlation to spike-rate
with a place map</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-directional correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Spike-plot and firing rate map and place field in three subplots respectively</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_firing_and_place(place_data, smooth=True):
    &#34;&#34;&#34;
    Plots the analysis replay_data of locational correlation to spike-rate
    with a place map

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to head-directional correlation

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        Spike-plot and firing rate map and place field in three subplots respectively

    &#34;&#34;&#34;
    fig = plt.figure()

    ax1 = loc_spike(place_data, ax=fig.add_subplot(131))
    ax1.set_xlabel(&#39;cm&#39;)
    ax1.set_ylabel(&#39;cm&#39;)

    ax2 = loc_rate(place_data, ax=fig.add_subplot(132, sharey=ax1), smooth=smooth)
    ax2.set_xlabel(&#39;cm&#39;)

    ax3 = loc_place_field(place_data, ax=fig.add_subplot(133, sharey=ax1))
    ax3.set_xlabel(&#39;cm&#39;)

    fig.set_tight_layout(True)
    plt.subplots_adjust(wspace=0.25)
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_place_centroid"><code class="name flex">
<span>def <span class="ident">loc_place_centroid</span></span>(<span>place_data, centroid)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of locational correlation to spike-rate
along with the centroid of the place field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to head-directional correlation</dd>
<dt><strong><code>centroid</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The centroid of the place field</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Spike-plot and firing rate map in two subplots respectively</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_place_centroid(place_data, centroid):
    &#34;&#34;&#34;
    Plots the analysis replay_data of locational correlation to spike-rate
    along with the centroid of the place field.

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to head-directional correlation
    centroid : ndarray
        The centroid of the place field

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        Spike-plot and firing rate map in two subplots respectively

    &#34;&#34;&#34;
    fig = plt.figure()

    ax = loc_spike(place_data, ax=fig.add_subplot(121))
    ax.plot([centroid[0]], [centroid[1]], &#39;gX&#39;)
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)

    ax = loc_rate(place_data, ax=fig.add_subplot(122))
    ax.plot([centroid[0]], [centroid[1]], &#39;gX&#39;)
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)
    plt.tight_layout()
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_place_field"><code class="name flex">
<span>def <span class="ident">loc_place_field</span></span>(<span>place_data, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the location of the place field(s) of the unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the correlation of unit firing to location of the animal</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axis</code></dt>
<dd>Axis object. If specified, the figure is plotted in this axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.Axis</code></dt>
<dd>Axis of the spike-plot</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_place_field(place_data, ax=None):
    &#34;&#34;&#34;
    Plots the location of the place field(s) of the unit.

    Parameters
    ----------
    place_data : dict
        Graphical data from the correlation of unit firing to location of the animal
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.

    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the spike-plot

    &#34;&#34;&#34;

    # spatial place field
    ax, _ = _make_ax_if_none(ax)
    clist = [(0.0, 0.0, 1.0),\
            (0.0, 1.0, 0.5),\
            (0.9, 1.0, 0.0),\
            (1.0, 0.75, 0.0),\
            (0.9, 0.0, 0.0)]
    c_map = mcol.ListedColormap(clist)

    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#39;right&#39;, size=&#39;3%&#39;, pad=0.05)
    mask = (place_data[&#39;placeField&#39;] == 0)
    pmap= ax.pcolormesh(place_data[&#39;xedges&#39;], place_data[&#39;yedges&#39;],
                        np.ma.array(place_data[&#39;placeField&#39;], mask=mask),
                        cmap=c_map, rasterized=True)
    ax.set_ylim([0, place_data[&#39;yedges&#39;].max()])
    ax.set_xlim([0, place_data[&#39;xedges&#39;].max()])
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    centroid = place_data[&#39;centroid&#39;]
    ax.plot([centroid[0]], [centroid[1]], &#39;gX&#39;)
    plt.colorbar(pmap, cax=cax, orientation=&#39;vertical&#39;, use_gridspec=True)
#        plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    return ax</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_rate"><code class="name flex">
<span>def <span class="ident">loc_rate</span></span>(<span>place_data, ax=None, smooth=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots location vs spike rate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to locational correlation</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axis</code></dt>
<dd>Axis object. If specified, the figure is plotted in this axis.</dd>
</dl>
<p>kwargs :
colormap : str
viridis is used if not specified
"default" uses the standard red green intensity colours
but these are bad for colorblindness.
style : str
What kind of map to plot - can be
"contour", "digitized" or "interpolated"
levels : int
Number of contour regions.
Returns</p>
<hr>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.Axis</code></dt>
<dd>Axis of the firing rate map</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_rate(place_data, ax=None, smooth=True, **kwargs):
    &#34;&#34;&#34;
    Plots location vs spike rate

    Parameters
    ----------
    place_data : dict
        Graphical data from the unit firing to locational correlation
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.
    kwargs :
        colormap : str
            viridis is used if not specified
            &#34;default&#34; uses the standard red green intensity colours
            but these are bad for colorblindness.
        style : str
            What kind of map to plot - can be
            &#34;contour&#34;, &#34;digitized&#34; or &#34;interpolated&#34;
        levels : int
            Number of contour regions.
    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the firing rate map

    &#34;&#34;&#34;
    colormap = kwargs.get(&#34;colormap&#34;, &#34;viridis&#34;)
    style = kwargs.get(&#34;style&#34;, &#34;contour&#34;)
    levels = kwargs.get(&#34;levels&#34;, 5)
    splits = None

    if colormap is &#34;default&#34;:
        clist = [(0.0, 0.0, 1.0),\
                (0.0, 1.0, 0.5),\
                (0.9, 1.0, 0.0),\
                (1.0, 0.75, 0.0),\
                (0.9, 0.0, 0.0)]
        colormap = mcol.ListedColormap(clist)

    ax, fig = _make_ax_if_none(ax)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#39;right&#39;, size=&#39;3%&#39;, pad=0.05)
    if smooth:
        fmap = place_data[&#39;smoothMap&#39;]
    else:
        fmap = place_data[&#39;firingMap&#39;]

    if style == &#34;digitized&#34;:
        res = ax.pcolormesh(
            place_data[&#39;xedges&#39;], place_data[&#39;yedges&#39;],
            np.ma.array(fmap, mask=np.isnan(fmap)),
            cmap=colormap, rasterized=True)

    elif style == &#34;interpolated&#34;:
        extent = (
            0, place_data[&#39;xedges&#39;].max(),
            0, place_data[&#39;yedges&#39;].max())
        tp = fmap[:-1, :-1]
        res = ax.imshow(
            tp, cmap=colormap,
            extent=extent, interpolation=&#34;bicubic&#34;,
            origin=&#34;lower&#34;)

    elif style == &#34;contour&#34;:
        dx = np.mean(np.diff(place_data[&#39;xedges&#39;]))
        dy = np.mean(np.diff(place_data[&#39;yedges&#39;]))
        pad_map = np.pad(fmap[:-1, :-1], ((1, 1), (1, 1)), &#34;edge&#34;)
        vmin, vmax = np.nanmin(pad_map), np.nanmax(pad_map)
        if vmin != vmax:
            splits = np.linspace(vmin, vmax, levels+1)
        else:
            splits = np.array([vmin, vmin*2])
        x_edges = np.append(
            place_data[&#34;xedges&#34;] - dx/2,
            place_data[&#34;xedges&#34;][-1] + dx/2)
        y_edges = np.append(
            place_data[&#34;yedges&#34;] - dy/2,
            place_data[&#34;yedges&#34;][-1] + dy/2)
        res = ax.contourf(
            x_edges, y_edges,
            np.ma.array(pad_map, mask=np.isnan(pad_map)),
            levels=splits, cmap=colormap, corner_mask=True)

        # This produces it with no padding
        # res = ax.contourf(
        #     place_data[&#39;xedges&#39;][:-1] + dx / 2.,
        #     place_data[&#39;yedges&#39;][:-1] + dy / 2.,
        #     np.ma.array(fmap[:-1, :-1], mask=np.isnan(fmap[:-1, :-1])),
        #     levels=15, cmap=colormap, corner_mask=True)

    else:
        logging.error(&#34;Unrecognised style passed to loc_rate&#34;)
        return

    ax.set_ylim([0, place_data[&#39;yedges&#39;].max()])
    ax.set_xlim([0, place_data[&#39;xedges&#39;].max()])
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    cbar = plt.colorbar(res, cax=cax, orientation=&#39;vertical&#39;, use_gridspec=True)
    # cbar.ax.set_ticks(levels)
    # cbar.ax.set_yticklabels(np.around(levels, decimals=1))
    if splits is not None:
        split_text = np.around(splits, decimals=1)
        cbar.ax.set_yticklabels(split_text)

    return ax</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_rate_time_lapse"><code class="name flex">
<span>def <span class="ident">loc_rate_time_lapse</span></span>(<span>place_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of locational time-lapse analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from locational time-lapsed anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>list</code> of <code>matplotlib.pyplot.Figure</code></dt>
<dd>Time-lapsed firing-rate map</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_rate_time_lapse(place_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational time-lapse analysis

    Parameters
    ----------
    place_data : dict
        Graphical data from locational time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed firing-rate map

    &#34;&#34;&#34;

    keys = [key[1] for key in list(enumerate(place_data.keys()))]

    fig = []
    axs = []
    keys = list(place_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, sharex=&#39;col&#39;, sharey=&#39;row&#39;)
        fig.append(f)
        axs.extend(list(ax.flatten()))

    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            loc_rate(place_data[key], ax=ax)
            nice_key = _nice_lapse_key(key)
            ax.set_title(nice_key)
        else:
            ax.set_visible(False)

    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_shuffle"><code class="name flex">
<span>def <span class="ident">loc_shuffle</span></span>(<span>loc_shuffle_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of locational shuffling analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc_shuffle_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from head-directional shuffling anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Distribution of Skaggs IC, sparsity and spatial coherecne in three subplots</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_shuffle(loc_shuffle_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational shuffling analysis

    Parameters
    ----------
    loc_shuffle_data : dict
        Graphical data from head-directional shuffling anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Distribution of Skaggs IC, sparsity and spatial coherecne in three subplots

    &#34;&#34;&#34;

    # Loactional shuffling analysis
    fig1 = plt.figure()
#    ax= plt.gca()
    ax = fig1.add_subplot(221)
    ax.bar(loc_shuffle_data[&#39;skaggsEdges&#39;][:-1], loc_shuffle_data[&#39;skaggsCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
           width=np.diff(loc_shuffle_data[&#39;skaggsEdges&#39;]).mean(), rasterized=True)
    ax.plot([loc_shuffle_data[&#39;skaggs95&#39;], loc_shuffle_data[&#39;skaggs95&#39;]], \
            [0, loc_shuffle_data[&#39;skaggsCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
#        ax.plot([loc_shuffle_data[&#39;refSkaggs&#39;], loc_shuffle_data[&#39;refSkaggs&#39;]], \
#                [0, loc_shuffle_data[&#39;skaggsCount&#39;].max()], color=&#39;green&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Skaggs IC&#39;)
#    ax.set_ylabel(&#39;Count&#39;, fontsize=12)

    ax = fig1.add_subplot(222)
    ax.bar(loc_shuffle_data[&#39;sparsityEdges&#39;][:-1], loc_shuffle_data[&#39;sparsityCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=np.diff(loc_shuffle_data[&#39;sparsityEdges&#39;]).mean(), rasterized=True)
    ax.plot([loc_shuffle_data[&#39;sparsity05&#39;], loc_shuffle_data[&#39;sparsity05&#39;]], \
            [0, loc_shuffle_data[&#39;sparsityCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
#        ax.plot([loc_shuffle_data[&#39;refSparsity&#39;], loc_shuffle_data[&#39;refSparsity&#39;]], \
#                [0, loc_shuffle_data[&#39;sparsityCount&#39;].max()], color=&#39;green&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Sparsity&#39;)

    ax = fig1.add_subplot(223)
    ax.bar(loc_shuffle_data[&#39;coherenceEdges&#39;][:-1], loc_shuffle_data[&#39;coherenceCount&#39;], color=&#39;slateblue&#39;, alpha=0.6, \
                    width=np.diff(loc_shuffle_data[&#39;coherenceEdges&#39;]).mean(), rasterized=True)
    ax.plot([loc_shuffle_data[&#39;coherence95&#39;], loc_shuffle_data[&#39;coherence95&#39;]], \
            [0, loc_shuffle_data[&#39;coherenceCount&#39;].max()], color=&#39;red&#39;, linewidth=2)
#        ax.plot([loc_shuffle_data[&#39;refCoherence&#39;], loc_shuffle_data[&#39;refCoherence&#39;]], \
#                [0, loc_shuffle_data[&#39;coherenceCount&#39;].max()], color=&#39;green&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Coherence&#39;)

#    i= 0
#    labels= [&#39;Skaggs IC&#39;, &#39;Sparsity&#39;, &#39;Coherence&#39;]
    for ax in fig1.axes:
        ax.set_ylabel(&#39;Count&#39;)

    fig1.suptitle(&#39;Distribution of locational firing specificity indices&#39;)
    plt.subplots_adjust(hspace=0.35, wspace=0.23)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_spike"><code class="name flex">
<span>def <span class="ident">loc_spike</span></span>(<span>place_data, ax=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the location of spiking-events (spike-plot) along with the trace of animal in the enviroment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the correlation of unit firing to location of the animal</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.axis</code></dt>
<dd>Axis object. If specified, the figure is plotted in this axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.pyplot.Axis</code></dt>
<dd>Axis of the spike-plot</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_spike(place_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots the location of spiking-events (spike-plot) along with the trace of animal in the enviroment.

    Parameters
    ----------
    place_data : dict
        Graphical data from the correlation of unit firing to location of the animal
    ax : matplotlib.pyplot.axis
        Axis object. If specified, the figure is plotted in this axis.

    Returns
    -------
    ax : matplotlib.pyplot.Axis
        Axis of the spike-plot

    &#34;&#34;&#34;
    # default_point_size = max(
    #     place_data[&#39;yedges&#39;].max() - place_data[&#39;yedges&#39;].min(),
    #     place_data[&#39;xedges&#39;].max() - place_data[&#39;xedges&#39;].min()
    # ) / 10
    default_point_size = 2

    color = kwargs.get(&#34;color&#34;, RED)
    point_size = kwargs.get(&#34;point_size&#34;, default_point_size)
    # spatial firing map
    if not ax:
        plt.figure()
        ax = plt.gca()

    ax.plot(place_data[&#39;posX&#39;], place_data[&#39;posY&#39;], color=&#39;black&#39;, zorder=1)
    ax.scatter(place_data[&#39;spikeLoc&#39;][0], place_data[&#39;spikeLoc&#39;][1], \
               s=point_size, marker=&#39;o&#39;, color=color, zorder=2)
    ax.set_ylim([0, place_data[&#39;yedges&#39;].max()])
    ax.set_xlim([0, place_data[&#39;xedges&#39;].max()])
    #asp = np.diff(ax.get_xlim())[0] / np.diff(ax.get_ylim())[0]
    #ax.set_aspect(asp)
    ax.set_aspect(&#39;equal&#39;)
    ax.invert_yaxis()
    return ax</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_spike_time_lapse"><code class="name flex">
<span>def <span class="ident">loc_spike_time_lapse</span></span>(<span>place_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of locational time-lapse analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>place_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from locational time-lapsed anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>list</code> of <code>matplotlib.pyplot.Figure</code></dt>
<dd>Time-lapsed spike-plots</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_spike_time_lapse(place_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational time-lapse analysis

    Parameters
    ----------
    place_data : dict
        Graphical data from locational time-lapsed anlaysis

    Returns
    -------
    fig : list of matplotlib.pyplot.Figure
        Time-lapsed spike-plots

    &#34;&#34;&#34;

    keys = [key[1] for key in list(enumerate(place_data.keys()))]
    fig = []
    axs = []
    keys = list(place_data.keys())
    nkey = len(keys)
    nfig = int(np.ceil(nkey/4))
    for _ in range(nfig):
        f, ax = plt.subplots(2, 2, sharex=&#39;col&#39;, sharey=&#39;row&#39;)
        fig.append(f)
        axs.extend(list(ax.flatten()))

    for i, ax in enumerate(axs):
        if i &lt; len(keys):
            key = keys[i]
            loc_spike(place_data[key], ax=ax)
            nice_key = _nice_lapse_key(key)
            ax.set_title(nice_key)
        else:
            ax.set_visible(False)

    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.loc_time_shift"><code class="name flex">
<span>def <span class="ident">loc_time_shift</span></span>(<span>loc_shift_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of locational time-shift analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc_shift_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from head-directional time-shift anlaysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Skaggs information content of locational firing in shifted time of spiking events</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Sparsity of locational firing in shifted time of spiking events</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Coherence of locational firing in shifted time of spiking events</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loc_time_shift(loc_shift_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of locational time-shift analysis

    Parameters
    ----------
    loc_shift_data : dict
        Graphical data from head-directional time-shift anlaysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Skaggs information content of locational firing in shifted time of spiking events
    fig2 : matplotlib.pyplot.Figure
        Sparsity of locational firing in shifted time of spiking events
    fig3 : matplotlib.pyplot.Figure
        Coherence of locational firing in shifted time of spiking events

    &#34;&#34;&#34;

    ## Locational time shift analysis

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;skaggs&#39;], linewidth=2, zorder=1)
    ax.scatter(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;skaggs&#39;], marker=&#39;o&#39;, color=RED, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;Skaggs IC&#39;)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_title(&#39;Skaggs IC of place firing in shifted time of spiking events&#39;)

    fig2 = plt.figure()
    ax = plt.gca()
    ax.plot(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;sparsity&#39;], linewidth=2, zorder=1)
    ax.scatter(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;sparsity&#39;], marker=&#39;o&#39;, color=RED, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;Sparsity&#39;)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_title(&#39;Sparsity of place firing in shifted time of spiking events&#39;)

    fig3 = plt.figure()
    ax = plt.gca()
    ax.plot(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;coherence&#39;], linewidth=2, zorder=1)
    ax.scatter(loc_shift_data[&#39;shiftTime&#39;], loc_shift_data[&#39;coherence&#39;], marker=&#39;o&#39;, color=RED, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;Coherence&#39;)
    ax.set_xlabel(&#39;Shift time (ms)&#39;)
    ax.set_title(&#39;Coherence of place firing in shifted time of spiking events&#39;)

    #        for ax in fig1.axes:
    #            ax.set_xlabel(&#39;shift time&#39;)
    #        fig1.suptitle(&#39;Specifity indices in time shift&#39;)

    return fig1, fig2, fig3</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.multiple_regression"><code class="name flex">
<span>def <span class="ident">multiple_regression</span></span>(<span>mra_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the replay_data of multiple regression analysis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mra_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from multiple regression analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Bar plot of multiple regression replay_data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def multiple_regression(mra_data):
    &#34;&#34;&#34;
    Plots the replay_data of multiple regression analysis.

    Parameters
    ----------
    mra_data : dict
        Graphical data from multiple regression analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Bar plot of multiple regression replay_data

    &#34;&#34;&#34;

    varOrder = [&#39;Total&#39;, &#39;Loc&#39;, &#39;HD&#39;, &#39;Speed&#39;, &#39;Ang Vel&#39;, &#39;Dist Border&#39;]
    fig1 = plt.figure()
    ax = plt.gca()
    ax.bar(np.arange(6), mra_data[&#39;meanRsq&#39;], color=&#39;royalblue&#39;, align=&#39;center&#39;)
    ax.errorbar(np.arange(6), mra_data[&#39;meanRsq&#39;], fmt=&#39;ro&#39;,\
                yerr=mra_data[&#39;stdRsq&#39;], ecolor=&#39;k&#39;, elinewidth=3)
    ax.set_title(&#39;Multiple regression scores&#39;)
    ax.set_ylabel(&#39;$R^2$&#39;)
    plt.xticks(np.arange(6), varOrder)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.plot_angle_between_points"><code class="name flex">
<span>def <span class="ident">plot_angle_between_points</span></span>(<span>points, xlim, ylim, ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the angle between three points</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of points to plot the angle between</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>float</code></dt>
<dd>The upper xlimit of the graph</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>float</code></dt>
<dd>The upper ylimit of the graph</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Optional axis to plot into</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>The angle between the points</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_angle_between_points(points, xlim, ylim, ax=None):
    &#34;&#34;&#34;
    Plots the angle between three points

    Parameters
    ----------
    points : list
        The list of points to plot the angle between
    xlim : float
        The upper xlimit of the graph
    ylim : float
        The upper ylimit of the graph
    ax : matplotlib.axes.Axes
        Optional axis to plot into

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        The angle between the points
    &#34;&#34;&#34;

    ax, fig = _make_ax_if_none(ax)
    arr = np.array(points)
    xdata = arr[:, 0]
    ydata = arr[:, 1]

    line_1 = Line2D(
        xdata[:2], ydata[:2], linewidth=1, linestyle = &#34;-&#34;, color=&#34;green&#34;,
        marker=&#34;.&#34;, markersize=10, markeredgecolor=&#39;k&#39;, markerfacecolor=&#39;k&#39;
    )
    line_2 = Line2D(
        xdata[1:], ydata[1:], linewidth=1, linestyle = &#34;-&#34;, color=&#34;red&#34;,
        marker=&#34;.&#34;, markersize=10, markeredgecolor=&#39;k&#39;, markerfacecolor=&#39;k&#39;)

    ax.add_line(line_1)
    ax.add_line(line_2)

    angle_plot = _get_angle_plot(line_1, line_2, 0.2, &#39;b&#39;, [xdata[1], ydata[1]], xlim, ylim)
    ax.add_patch(angle_plot) # To display the angle arc

    ax.set_ylim([0, ylim])
    ax.set_xlim([0, xlim])
    ax.set_aspect(&#39;equal&#39;)
    ax.set_xlabel(&#39;cm&#39;)
    ax.set_ylabel(&#39;cm&#39;)
    txt_list = [&#34;P1&#34;, &#34;P2&#34;, &#34;P3&#34;]
    for i, txt in enumerate(txt_list):
        ax.annotate(txt, (xdata[i], ydata[i] - (ylim * 0.02)))
    ax.invert_yaxis()
    plt.tight_layout()
    plt.legend()
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.plot_replay_sections"><code class="name flex">
<span>def <span class="ident">plot_replay_sections</span></span>(<span>replay_data, spike_times, orientation='vertical')</span>
</code></dt>
<dd>
<section class="desc"><p>Plot zoomed in sections of the replay data spikes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>replay_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Results from replay_summary</dd>
<dt><strong><code>spike_times</code></strong> :&ensp;<code>list</code></dt>
<dd>A 3 tiered list, most commonly a list of nca.spike_times outputs</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>"vertical" or "horizontal" - the direction to plot rasters in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.pyplot.Figure</code> :</dt>
<dd>Resulting multi Axes figure</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot_replay_sections(replay_data, spike_times, orientation=&#34;vertical&#34;):
    &#34;&#34;&#34;
    Plot zoomed in sections of the replay data spikes.

    Parameters
    ----------
    replay_data : dict
        Results from replay_summary
    spike_times : list
        A 3 tiered list, most commonly a list of nca.spike_times outputs
    orientation : str
        &#34;vertical&#34; or &#34;horizontal&#34; - the direction to plot rasters in

    Returns
    -------
    matplotlib.pyplot.Figure :
        Resulting multi Axes figure

    &#34;&#34;&#34;
    num_plots = len(replay_data[&#34;overlap swr mua&#34;])
    row_size = 6

    if num_plots &lt;= row_size:
        num_cols = num_plots
        num_rows = 1
    else:
        num_cols = row_size
        num_rows = math.ceil(num_plots / row_size)

    fig, axes = plt.subplots(
        nrows=num_rows, ncols=num_cols,
        sharex=&#39;col&#39;, tight_layout=True, figsize=(num_rows*2, num_cols*2))

    for i, i_range in enumerate(replay_data[&#34;overlap swr mua&#34;]):
        if num_plots == 1:
            ax = axes
        else:
            ax=axes.flatten()[i]
        # nca.spike_times(sleep_sample, ranges=[i_range])
        # can be used to get spike times
        spike_raster(
            spike_times[i],
            linewidths=1, ax=ax, orientation=orientation,
            colors=get_axona_colours()[:replay_data[&#34;num cells&#34;]],
            #xlim=(round(i_range[0], 1), round(i_range[1], 1)),
            title=None, ylabel=None, xlabel=None)
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.plv"><code class="name flex">
<span>def <span class="ident">plv</span></span>(<span>plv_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of Phase-locking value (PLV)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plv_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the PLV analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of spike-triggered average (STA)</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of FFT of STA (fSTA), average power spectrum of spike-triggered LFP signals (STP),
spike-field coherence and PLV in four subplots</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plv(plv_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of Phase-locking value (PLV)

    Parameters
    ----------
    plv_data : dict
        Graphical data from the PLV analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Plot of spike-triggered average (STA)
    fig2 : matplotlib.pyplot.Figure
        Plot of FFT of STA (fSTA), average power spectrum of spike-triggered LFP signals (STP),
        spike-field coherence and PLV in four subplots

    &#34;&#34;&#34;

    f = plv_data[&#39;f&#39;]
    t = plv_data[&#39;t&#39;]
    STA = plv_data[&#39;STA&#39;]
    fSTA = plv_data[&#39;fSTA&#39;]
    STP = plv_data[&#39;STP&#39;]
    SFC = plv_data[&#39;SFC&#39;]
    PLV = plv_data[&#39;PLV&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(t, STA, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Spike-triggered average (STA)&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;STA (uV)&#39;)

    fig2 = plt.figure()
    ax = fig2.add_subplot(221)
    ax.plot(f, fSTA, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;fft of STA&#39;)

    ax = fig2.add_subplot(222)
    ax.plot(f, STP, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;STP&#39;)

    ax = fig2.add_subplot(223)
    ax.plot(f, SFC, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;SFC&#39;)

    ax = fig2.add_subplot(224)
    ax.plot(f, PLV, linewidth=2, color=&#39;darkblue&#39;)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;PLV&#39;)

    for ax in fig2.axes:
        ax.set_xlabel(&#39;Frequency (Hz)&#39;)

    fig2.suptitle(&#39;Frequency analysis of spike-triggered lfp metrics&#39;)

    plt.subplots_adjust(wspace=0.3, hspace=0.35)
    return fig1, fig2</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.plv_bs"><code class="name flex">
<span>def <span class="ident">plv_bs</span></span>(<span>plv_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of bootstrapped Phase-locking value (PLV)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plv_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the time-resolved PLV analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of fSTA</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of STP</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of SFC</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plv_bs(plv_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of bootstrapped Phase-locking value (PLV)

    Parameters
    ----------
    plv_data : dict
        Graphical data from the time-resolved PLV analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Plot of fSTA
    fig2 : matplotlib.pyplot.Figure
        Plot of STP
    fig3 : matplotlib.pyplot.Figure
        Plot of SFC

    &#34;&#34;&#34;
    f = plv_data[&#39;f&#39;]
    t = plv_data[&#39;t&#39;]
    STAm = plv_data[&#39;STAm&#39;]
    fSTAm = plv_data[&#39;fSTAm&#39;]
    STPm = plv_data[&#39;STPm&#39;]
    SFCm = plv_data[&#39;SFCm&#39;]
    PLVm = plv_data[&#39;PLVm&#39;]

    STAe = plv_data[&#39;STAe&#39;]
    fSTAe = plv_data[&#39;fSTAe&#39;]
    STPe = plv_data[&#39;STPe&#39;]
    SFCe = plv_data[&#39;SFCe&#39;]
    PLVe = plv_data[&#39;PLVe&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    ax.plot(t, STAm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;o&#39;, \
                 markerfacecolor=&#39;darkblue&#39;, markeredgecolor=&#39;none&#39;)
    ax.fill_between(t, STAm- STAe, STAm+ STAe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Spike-triggered average (STA)&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;STA (uV)&#39;)

    fig2 = plt.figure()
    ax = fig2.add_subplot(221)
    ax.plot(f, fSTAm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, fSTAm- fSTAe, fSTAm+ fSTAe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;fft of STA&#39;)

    ax = fig2.add_subplot(222)
    ax.plot(f, STPm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, STPm- STPe, STPm+ STPe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;STP&#39;)

    ax = fig2.add_subplot(223)
    ax.plot(f, SFCm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, SFCm- SFCe, SFCm+ SFCe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;SFC&#39;)

    ax = fig2.add_subplot(224)
    ax.plot(f, PLVm, linewidth=2, color=&#39;darkblue&#39;, marker=&#39;.&#39;, rasterized=True)
    ax.fill_between(f, PLVm- PLVe, PLVm+ PLVe, \
                 facecolor=&#39;cornflowerblue&#39;, alpha=0.5,\
                 edgecolor=&#39;none&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_ylabel(&#39;PLV&#39;)

    for ax in fig2.axes:
        ax.set_xlabel(&#39;Frequency (Hz)&#39;)

    fig2.suptitle(&#39;Frequency analysis of spike-triggered lfp metrics (bootstrap)&#39;)
    plt.subplots_adjust(wspace=0.3, hspace=0.35)
    return fig1, fig2</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.plv_tr"><code class="name flex">
<span>def <span class="ident">plv_tr</span></span>(<span>plv_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of time-resolved Phase-locking value (PLV)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plv_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the time-resolved PLV analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of fSTA</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of STP</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Plot of SFC</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plv_tr(plv_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of time-resolved Phase-locking value (PLV)

    Parameters
    ----------
    plv_data : dict
        Graphical data from the time-resolved PLV analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Plot of fSTA
    fig2 : matplotlib.pyplot.Figure
        Plot of STP
    fig3 : matplotlib.pyplot.Figure
        Plot of SFC

    &#34;&#34;&#34;

    offset = plv_data[&#39;offset&#39;]
    f = plv_data[&#39;f&#39;]
    fSTA = plv_data[&#39;fSTA&#39;]
#        STP= plv_data[&#39;STP&#39;]
    SFC = plv_data[&#39;SFC&#39;]
    PLV = plv_data[&#39;PLV&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(offset, f, fSTA, cmap=c_map, rasterized=True)
    plt.title(&#39;Time-resolved fSTA&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig1.colorbar(pcm)

    fig2 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(offset, f, SFC, cmap=c_map, rasterized=True)
    plt.title(&#39;Time-resolved SFC&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig2.colorbar(pcm)

    fig3 = plt.figure()
    ax = plt.gca()
    c_map = plt.cm.jet
    pcm = ax.pcolormesh(offset, f, PLV, cmap=c_map, rasterized=True)
    plt.title(&#39;Time-resolved PLV&#39;)
    ax.set_xlabel(&#39;Time (sec)&#39;)
    ax.set_ylabel(&#39;Frequency (Hz)&#39;)
    fig3.colorbar(pcm)

    return fig1, fig2, fig3</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.print_place_cells"><code class="name flex">
<span>def <span class="ident">print_place_cells</span></span>(<span>rows, cols=7, size_multiplier=4, wspace=0.3, hspace=0.3, placedata=None, wavedata=None, graphdata=None, isidata=None, headdata=None, thetadata=None, point_size=10, units=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print_place_cells(
        rows, cols=7, size_multiplier=4, wspace=0.3, hspace=0.3,
        placedata=None, wavedata=None, graphdata=None, isidata=None,
        headdata=None, thetadata=None, point_size=10, units=None):
    fig = plt.figure(
        figsize=(cols * size_multiplier, rows * size_multiplier),
        tight_layout=False)
    gs = gridspec.GridSpec(rows, cols, wspace=wspace, hspace=hspace)

    for i in range(rows):
        # Plot the spike position
        place_data = placedata[i]
        if place_data is not None:
            ax = fig.add_subplot(gs[i, 0])
            if units == None:
                color = get_axona_colours(i)
            else:
                color = get_axona_colours(units[i] - 1)
            loc_spike(
                place_data, ax=ax, color=color,
                point_size=point_size)

            # Plot the rate map
            ax = fig.add_subplot(gs[i, 1])
            loc_rate(place_data, ax=ax, smooth=True)

        head_data = headdata[i]
        if head_data is not None:
            ax = fig.add_subplot(gs[i, 2], projection=&#39;polar&#39;)
            hd_rate(head_data, ax=ax, title=None)

        # Plot wave property
        if wavedata[i] is not None:
            ax = fig.add_subplot(gs[i, 3])
            largest_waveform(wavedata[i], ax=ax)

        # Plot -10 to 10 autocorrelation
        if graphdata[i] is not None:
            ax = fig.add_subplot(gs[i, 4])
            isi_corr(graphdata[i], ax=ax, title=None, xlabel=None, ylabel=None)

        if thetadata[i] is not None:
            ax = fig.add_subplot(gs[i, 5])
            theta_cell(thetadata[i], ax=ax, title=None,
                       xlabel=None, ylabel=None)

        if isidata[i] is not None:
            ax = fig.add_subplot(gs[i, 6])
            temp_fig, (ax1, ax2) = plt.subplots(2)
            isi(isidata[i], axes=[ax, ax1, ax2],
                title1=None, xlabel1=None, ylabel1=None)
            plt.close(temp_fig)

        plt.close(&#34;all&#34;)
        gc.collect()
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.replay_summary"><code class="name flex">
<span>def <span class="ident">replay_summary</span></span>(<span>replay_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot a replay data summary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>replay_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of graph data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def replay_summary(replay_data):
    &#34;&#34;&#34;
    Plot a replay data summary.

    Parameters
    ----------
    replay_data : dict
        Dictionary of graph data

    Returns
    -------
    fig : matplotlib.pyplot.Figure

    &#34;&#34;&#34;
    lfp_times = replay_data[&#34;lfp times&#34;]
    filtered_lfp = replay_data[&#34;lfp samples&#34;]
    mua_hist = replay_data[&#34;mua hists&#34;]
    swr_times = replay_data[&#34;swr times&#34;]
    num_cells = replay_data[&#34;num cells&#34;]
    spike_times = replay_data[&#34;spike times&#34;]

    colors = get_axona_colours()[:num_cells]
    xlim = (lfp_times[0], lfp_times[-1])

    # SWR and filtered LFP
    fig, axes= plt.subplots(
        nrows=3, ncols=1, figsize=(12,6), sharex=True)
    spike_raster(
        swr_times, ax=axes[0], ylabel=None, xlabel=None,
        no_y_ticks=True, colors=(&#39;b&#39;), linewidths=0.2, linelengths=0.5)
    axes[0].plot(lfp_times, filtered_lfp, color=&#39;k&#39;)
    axes[0].set_title(&#34;Filtered LFP and SWR Events&#34;)

    # MUA
    axes[1].plot(mua_hist[1], mua_hist[0], color=&#39;k&#39;)
    ticks = [i for i in range(num_cells + 1)]
    axes[1].set_yticks(ticks)
    axes[1].set_title(&#34;Number of Active Cells&#34;)

    # Raw spikes
    spike_raster(spike_times, linewidths=0.2, ax=axes[2], colors=colors)

    import matplotlib.ticker as ticker

    tick_spacing = 100
    for ax in axes:
        ax.set_xlim(xlim[0], xlim[1])
        ax.xaxis.set_major_locator(ticker.MultipleLocator(tick_spacing))

    plt.tight_layout()
    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.rot_corr"><code class="name flex">
<span>def <span class="ident">rot_corr</span></span>(<span>plot_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis outcome of rotational correlation of spatial autocorrelation map.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from spatial correlation of firing map</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Rotational correlation plot</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rot_corr(plot_data):
    &#34;&#34;&#34;
    Plots the analysis outcome of rotational correlation of spatial autocorrelation map.

    Parameters
    ----------
    plot_data : dict
        Graphical data from spatial correlation of firing map

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Rotational correlation plot

    &#34;&#34;&#34;

    # Location firing map rotational analysis
    fig1 = plt.figure()
    ax = fig1.gca()
    ax.plot(plot_data[&#39;rotAngle&#39;], plot_data[&#39;rotCorr&#39;], linewidth=2, zorder=1)
    ax.set_ylim([-1, 1])
    ax.set_xlim([0, 360])
    #plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Rotational correlation of spatial firing map&#39;)
    ax.set_xlabel(&#39;Rotation angle&#39;)
    ax.set_ylabel(&#39;Pearson correlation&#39;)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.scatterplot_matrix"><code class="name flex">
<span>def <span class="ident">scatterplot_matrix</span></span>(<span>_data, names=[], **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots a scatterplot matrix of subplots.
Each row of "_data" is plotted
against other rows, resulting in a nrows by nrows grid of subplots with the
diagonal subplots labeled with "names".
Additional keyword arguments are
passed on to matplotlib's "plot" command. Returns the matplotlib figure
object containg the subplot grid.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def scatterplot_matrix(_data, names=[], **kwargs):
    &#34;&#34;&#34;Plots a scatterplot matrix of subplots.  Each row of &#34;_data&#34; is plotted
    against other rows, resulting in a nrows by nrows grid of subplots with the
    diagonal subplots labeled with &#34;names&#34;.  Additional keyword arguments are
    passed on to matplotlib&#39;s &#34;plot&#34; command. Returns the matplotlib figure
    object containg the subplot grid.&#34;&#34;&#34;
    numvars, _ = _data.shape
    fig, axs = plt.subplots(nrows=numvars, ncols=numvars, figsize=(8, 8))
    fig.subplots_adjust(hspace=0.05, wspace=0.05)

    for ax in axs.flat:
        # Hide all ticks and labels
        ax.xaxis.set_visible(False)
        ax.yaxis.set_visible(False)

        # Set up ticks only on one side for the &#34;edge&#34; subplots...
        if ax.is_first_col():
            ax.yaxis.set_ticks_position(&#39;left&#39;)
        if ax.is_last_col():
            ax.yaxis.set_ticks_position(&#39;right&#39;)
        if ax.is_first_row():
            ax.xaxis.set_ticks_position(&#39;top&#39;)
        if ax.is_last_row():
            ax.xaxis.set_ticks_position(&#39;bottom&#39;)

    # Plot the _data.
    for i, j in zip(*np.triu_indices_from(axs, k=1)):
        for x, y in [(i, j), (j, i)]:
            axs[y, x].scatter(_data[x], _data[y], **kwargs)

    # Label the diagonal subplots...
    if len(names) == numvars:
        for i, label in enumerate(names):
            axs[i, i].annotate(label, (0.5, 0.5), xycoords=&#39;axes fraction&#39;,\
               ha=&#39;center&#39;, va=&#39;center&#39;)

    # Turn on the proper x or y axes ticks.
    for i, j in zip(range(numvars), itertools.cycle((-1, 0))):
        axs[j, i].xaxis.set_visible(True)
        axs[i, j].yaxis.set_visible(True)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.set_backend"><code class="name flex">
<span>def <span class="ident">set_backend</span></span>(<span>backend)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the
backend of Matplotlib</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>str</code></dt>
<dd>The new backend for Matplotlib</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="see-also">See also</h2>
<p><code>matplotlib.pyplot.switch_backend()</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_backend(backend):
    &#34;&#34;&#34;
    Sets the  backend of Matplotlib

    Parameters
    ----------
    backend : str
        The new backend for Matplotlib

    Returns
    -------
    None

    See also
    --------
    matplotlib.pyplot.switch_backend()

    &#34;&#34;&#34;

    if backend:
        plt.switch_backend(backend)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.speed"><code class="name flex">
<span>def <span class="ident">speed</span></span>(<span>speed_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the speed of the animal vs spike rate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>speed_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the unit firing to speed correlation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Scatter plot of speed vs spike-rate superimposed with fitted rate</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def speed(speed_data):
    &#34;&#34;&#34;
    Plots the speed of the animal vs spike rate

    Parameters
    ----------
    speed_data : dict
        Graphical data from the unit firing to speed correlation

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Scatter plot of speed vs spike-rate superimposed with fitted rate

    &#34;&#34;&#34;

    ## Speed analysis
    fig1 = plt.figure()
    ax = plt.gca()
    ax.scatter(speed_data[&#39;bins&#39;], speed_data[&#39;rate&#39;], c=BLUE, zorder=1)
    ax.plot(speed_data[&#39;bins&#39;], speed_data[&#39;fitRate&#39;], color=RED, linewidth=1.5, zorder=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;Speed vs Spiking Rate&#39;)
    ax.set_xlabel(&#39;Speed (cm/sec)&#39;)
    ax.set_ylabel(&#39;Spikes/sec&#39;)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.spike_phase"><code class="name flex">
<span>def <span class="ident">spike_phase</span></span>(<span>phase_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the analysis replay_data of spike-LFP phase locking</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>phase_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the spike-LFP phase locking analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Phase histogram</dd>
<dt><strong><code>fig2</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Phase distribution in circular plot</dd>
<dt><strong><code>fig3</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Phase-raster in one subplot, phase histogram in another</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def spike_phase(phase_data):
    &#34;&#34;&#34;
    Plots the analysis replay_data of spike-LFP phase locking

    Parameters
    ----------
    phase_data : dict
        Graphical data from the spike-LFP phase locking analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Phase histogram
    fig2 : matplotlib.pyplot.Figure
        Phase distribution in circular plot
    fig3 : matplotlib.pyplot.Figure
        Phase-raster in one subplot, phase histogram in another

    &#34;&#34;&#34;
    phBins = phase_data[&#39;phBins&#39;]
    phCount = phase_data[&#39;phCount&#39;]

    fig1 = plt.figure()
    ax = plt.gca()
    ax.bar(np.append(phBins, phBins+ 360), np.append(phCount, phCount), \
           color=&#39;slateblue&#39;, width=np.diff(phBins).mean(),\
           alpha=0.6, align=&#39;center&#39;, rasterized=True)
    ax.plot(np.append(phBins, phBins+ 360), 0.5*np.max(phCount)*(np.cos(np.append(phBins, phBins+ 360)*np.pi/180)+ 1), \
            color=&#39;red&#39;, linewidth=2)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_title(&#39;LFP phase distribution (red= reference cosine line)&#39;)
    ax.set_xlabel(&#39;Degrees&#39;)
    ax.set_ylabel(&#39;Spike count&#39;)

    fig2 = plt.figure()
    ax = plt.gca(polar=True)
    ax.bar(phBins*np.pi/180, phCount, width=3*np.pi/180, color=&#39;blue&#39;,\
           alpha=0.6, bottom=np.max(phase_data[&#39;phCount&#39;])/2, rasterized=True)
    ax.plot([0, phase_data[&#39;meanTheta&#39;]], [0, 1.5*np.max(phCount)], \
            linewidth=3, color=&#39;red&#39;, marker=&#39;.&#39;)
    plt.title(&#39;LFP phase distribution (red= mean direction)&#39;)

    fig3 = plt.figure()
    ax = fig3.add_subplot(211)
    #cdict= {&#39;blue&#39;: (0, 0, 1),
    #       &#39;white&#39;: (0, 0, 0)}
    #c_map = mcol.LinearSegmentedColormap(&#39;my_colormap&#39;, cdict, 256)
    ax.pcolormesh(phase_data[&#39;rasterbins&#39;], np.arange(0, phase_data[&#39;raster&#39;].shape[0]), \
                  phase_data[&#39;raster&#39;], cmap=plt.cm.binary, rasterized=True)
    
    # Alternative idea for plotting, not currently working. 
    # rasters = phase_data[&#39;raster&#39;]
    # bin_length = np.mean(np.diff(phase_data[&#39;raster&#39;], 0))

    # for idx, row in enumerate(rasters):
    #      rasters[idx] = [
    #          j_idx*(bin_length) +0.5*bin_length if j == 1 else 0 for 
    #             j_idx, j in enumerate(row)]
    # ax.eventplot(rasters)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    plt.title(&#39;Phase raster&#39;)
    ax.set_ylabel(&#39;Time&#39;)

    ax = fig3.add_subplot(212)
    ax.bar(phBins, phCount, color=&#39;slateblue&#39;, \
           width=np.diff(phBins).mean(), alpha=0.6, align=&#39;center&#39;, rasterized=True)
    plt.autoscale(enable=True, axis=&#39;both&#39;, tight=True)
    ax.set_xlabel(&#39;Phase(deg)&#39;)
    ax.set_ylabel(&#39;Spike count&#39;)

    return fig1, fig2, fig3</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.spike_raster"><code class="name flex">
<span>def <span class="ident">spike_raster</span></span>(<span>events, xlim=None, colors=[0, 0, 0], ax=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the spike raster for a number of units</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>events</code></strong> :&ensp;<code>list</code></dt>
<dd>The positions of the events</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Optional start and end of raster plot</dd>
<dt>colors :</dt>
<dt>Optional list of colours, or single colour - default black</dt>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Optional axis to plot into</dd>
</dl>
<p>**kwargs :
A set of keyword arguments to change graph appearance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>The spike raster</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def spike_raster(events, xlim=None, colors=[0, 0, 0], ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots the spike raster for a number of units

    Parameters
    ----------
    events : list
        The positions of the events
    xlim : tuple
        Optional start and end of raster plot
    colors :
        Optional list of colours, or single colour - default black
    ax : matplotlib.axes.Axes
        Optional axis to plot into
    **kwargs :
        A set of keyword arguments to change graph appearance

    Returns
    -------
    fig : matplotlib.pyplot.Figure
        The spike raster
    &#34;&#34;&#34;
    linewidths = kwargs.get(&#34;linewidths&#34;, 0.1)
    linelengths = kwargs.get(&#34;linelengths&#34;, 0.5)
    title = kwargs.get(&#34;title&#34;, &#34;Spike raster&#34;)
    xlabel = kwargs.get(&#34;xlabel&#34;, &#34;Time (seconds)&#34;)
    ylabel = kwargs.get(&#34;ylabel&#34;, &#34;Cell ID&#34;)
    no_y_ticks = kwargs.get(&#34;no_y_ticks&#34;, False)
    orientation = kwargs.get(&#34;orientation&#34;, &#34;horizontal&#34;)

    ax, fig = _make_ax_if_none(ax)

    ax.eventplot(
        events, colors=colors, linelengths=linelengths, linewidths=linewidths,
        orientation=orientation)

    # Be sure to only pick integer tick locations.
    if orientation == &#34;horizontal&#34;:
        ax.yaxis.set_major_locator(ticker.MaxNLocator(integer=True))
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        ax.invert_yaxis()
        if xlim is not None:
            ax.set_xlim(xlim[0], xlim[1])
    else:
        ax.xaxis.set_major_locator(ticker.MaxNLocator(integer=True))
        ax.set_xlabel(ylabel)
        ax.set_ylabel(xlabel)
        if xlim is not None:
            ax.set_ylim(xlim[0], xlim[1])
        ax.invert_yaxis()

    ax.set_title(title)

    if no_y_ticks:
        ax.get_yaxis().set_visible(False)

    return fig</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.stair_plot"><code class="name flex">
<span>def <span class="ident">stair_plot</span></span>(<span>dist_data)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the stairs of mean distance vs firing-rate bands</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dist_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from border and gradient analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Mean distance distance from border vs firing-rate percentage</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stair_plot(dist_data):
    &#34;&#34;&#34;
    Plots the stairs of mean distance vs firing-rate bands

    Parameters
    ----------
    dist_data : dict
        Graphical data from border and gradient analysis

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Mean distance distance from border vs firing-rate percentage

    &#34;&#34;&#34;

    perSteps = dist_data[&#39;perSteps&#39;]
    perDist = dist_data[&#39;perDist&#39;]
    stepsize = np.diff(perSteps).mean()

    fig1 = plt.figure()
    ax = plt.gca()
    for i, step in enumerate(perSteps):
        ax.plot([step, step+ stepsize], [perDist[i], perDist[i]], color=&#39;b&#39;, linestyle=&#39;--&#39;, marker=&#39;o&#39;, markerfacecolor=RED, linewidth=2)
        if i &gt; 0: #perSteps.shape[0]:
            ax.plot([step, step], [perDist[i-1], perDist[i]], color=&#39;b&#39;, linestyle=&#39;--&#39;, linewidth=2)
    ax.set_xlabel(&#39;% firing rate (spikes/sec)&#39;)
    ax.set_ylabel(&#39;Mean distance (cm)&#39;)

    return fig1</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.theta_cell"><code class="name flex">
<span>def <span class="ident">theta_cell</span></span>(<span>plot_data, ax=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots theta-modulated cell and theta-skipping cell analysis data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>plot_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the theta-modulated cell</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>Optional axes object to plot to.</dd>
</dl>
<p>kwargs :
title : str</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.pyplot.Figure</code></dt>
<dd>ISI correlation histogram superimposed with fitted sinusoidal curve.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def theta_cell(plot_data, ax=None, **kwargs):
    &#34;&#34;&#34;
    Plots theta-modulated cell and theta-skipping cell analysis data

    Parameters
    ----------
    plot_data : dict
        Graphical data from the theta-modulated cell
    ax : matplotlib.axes.Axes
        Optional axes object to plot to.
    kwargs :
        title : str

    Returns
    -------
    matplotlib.pyplot.Figure
        ISI correlation histogram superimposed with fitted sinusoidal curve.

    &#34;&#34;&#34;
    return isi_corr(plot_data, ax=ax, plot_theta=True, **kwargs)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_plot.wave_property"><code class="name flex">
<span>def <span class="ident">wave_property</span></span>(<span>wave_data, plots=[2, 2])</span>
</code></dt>
<dd>
<section class="desc"><p>Plots mean +/-std of waveforms in electrode groups</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wave_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Graphical data from the Waveform analysis</dd>
<dt><strong><code>plots</code></strong> :&ensp;<code>list</code></dt>
<dd>Subplot shape. [2, 2] for tetrode setup</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig1</code></strong> :&ensp;<code>matplotlib.pyplot.Figure</code></dt>
<dd>Matlab figure object</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def wave_property(wave_data, plots=[2, 2]):
    &#34;&#34;&#34;
    Plots mean +/-std of waveforms in electrode groups

    Parameters
    ----------
    wave_data : dict
        Graphical data from the Waveform analysis
    plots : list
        Subplot shape. [2, 2] for tetrode setup

    Returns
    -------
    fig1 : matplotlib.pyplot.Figure
        Matlab figure object

    &#34;&#34;&#34;

    # Wave property analysis
    fig1, ax = plt.subplots(plots[0], plots[1])
    ax = ax.flatten()
    # Plot waves
    for i in np.arange(len(ax)):
        ax[i].plot(wave_data[&#39;Mean wave&#39;][:, i], color=&#39;black&#39;, linewidth=2.0)
        ax[i].plot(wave_data[&#39;Mean wave&#39;][:, i]+wave_data[&#39;Std wave&#39;][:, i],\
          color=&#39;green&#39;, linestyle=&#39;dashed&#39;)
        ax[i].plot(wave_data[&#39;Mean wave&#39;][:, i]-wave_data[&#39;Std wave&#39;][:, i],\
          color=&#39;green&#39;, linestyle=&#39;dashed&#39;)

    return fig1</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neurochat" href="index.html">neurochat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="neurochat.nc_plot.angular_velocity" href="#neurochat.nc_plot.angular_velocity">angular_velocity</a></code></li>
<li><code><a title="neurochat.nc_plot.border" href="#neurochat.nc_plot.border">border</a></code></li>
<li><code><a title="neurochat.nc_plot.dist_rate" href="#neurochat.nc_plot.dist_rate">dist_rate</a></code></li>
<li><code><a title="neurochat.nc_plot.gradient" href="#neurochat.nc_plot.gradient">gradient</a></code></li>
<li><code><a title="neurochat.nc_plot.grid" href="#neurochat.nc_plot.grid">grid</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_firing" href="#neurochat.nc_plot.hd_firing">hd_firing</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_rate" href="#neurochat.nc_plot.hd_rate">hd_rate</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_rate_ccw" href="#neurochat.nc_plot.hd_rate_ccw">hd_rate_ccw</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_rate_time_lapse" href="#neurochat.nc_plot.hd_rate_time_lapse">hd_rate_time_lapse</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_shuffle" href="#neurochat.nc_plot.hd_shuffle">hd_shuffle</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_spike" href="#neurochat.nc_plot.hd_spike">hd_spike</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_spike_time_lapse" href="#neurochat.nc_plot.hd_spike_time_lapse">hd_spike_time_lapse</a></code></li>
<li><code><a title="neurochat.nc_plot.hd_time_shift" href="#neurochat.nc_plot.hd_time_shift">hd_time_shift</a></code></li>
<li><code><a title="neurochat.nc_plot.isi" href="#neurochat.nc_plot.isi">isi</a></code></li>
<li><code><a title="neurochat.nc_plot.isi_corr" href="#neurochat.nc_plot.isi_corr">isi_corr</a></code></li>
<li><code><a title="neurochat.nc_plot.largest_waveform" href="#neurochat.nc_plot.largest_waveform">largest_waveform</a></code></li>
<li><code><a title="neurochat.nc_plot.lfp_spectrum" href="#neurochat.nc_plot.lfp_spectrum">lfp_spectrum</a></code></li>
<li><code><a title="neurochat.nc_plot.lfp_spectrum_tr" href="#neurochat.nc_plot.lfp_spectrum_tr">lfp_spectrum_tr</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_auto_corr" href="#neurochat.nc_plot.loc_auto_corr">loc_auto_corr</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_firing" href="#neurochat.nc_plot.loc_firing">loc_firing</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_firing_and_place" href="#neurochat.nc_plot.loc_firing_and_place">loc_firing_and_place</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_place_centroid" href="#neurochat.nc_plot.loc_place_centroid">loc_place_centroid</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_place_field" href="#neurochat.nc_plot.loc_place_field">loc_place_field</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_rate" href="#neurochat.nc_plot.loc_rate">loc_rate</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_rate_time_lapse" href="#neurochat.nc_plot.loc_rate_time_lapse">loc_rate_time_lapse</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_shuffle" href="#neurochat.nc_plot.loc_shuffle">loc_shuffle</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_spike" href="#neurochat.nc_plot.loc_spike">loc_spike</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_spike_time_lapse" href="#neurochat.nc_plot.loc_spike_time_lapse">loc_spike_time_lapse</a></code></li>
<li><code><a title="neurochat.nc_plot.loc_time_shift" href="#neurochat.nc_plot.loc_time_shift">loc_time_shift</a></code></li>
<li><code><a title="neurochat.nc_plot.multiple_regression" href="#neurochat.nc_plot.multiple_regression">multiple_regression</a></code></li>
<li><code><a title="neurochat.nc_plot.plot_angle_between_points" href="#neurochat.nc_plot.plot_angle_between_points">plot_angle_between_points</a></code></li>
<li><code><a title="neurochat.nc_plot.plot_replay_sections" href="#neurochat.nc_plot.plot_replay_sections">plot_replay_sections</a></code></li>
<li><code><a title="neurochat.nc_plot.plv" href="#neurochat.nc_plot.plv">plv</a></code></li>
<li><code><a title="neurochat.nc_plot.plv_bs" href="#neurochat.nc_plot.plv_bs">plv_bs</a></code></li>
<li><code><a title="neurochat.nc_plot.plv_tr" href="#neurochat.nc_plot.plv_tr">plv_tr</a></code></li>
<li><code><a title="neurochat.nc_plot.print_place_cells" href="#neurochat.nc_plot.print_place_cells">print_place_cells</a></code></li>
<li><code><a title="neurochat.nc_plot.replay_summary" href="#neurochat.nc_plot.replay_summary">replay_summary</a></code></li>
<li><code><a title="neurochat.nc_plot.rot_corr" href="#neurochat.nc_plot.rot_corr">rot_corr</a></code></li>
<li><code><a title="neurochat.nc_plot.scatterplot_matrix" href="#neurochat.nc_plot.scatterplot_matrix">scatterplot_matrix</a></code></li>
<li><code><a title="neurochat.nc_plot.set_backend" href="#neurochat.nc_plot.set_backend">set_backend</a></code></li>
<li><code><a title="neurochat.nc_plot.speed" href="#neurochat.nc_plot.speed">speed</a></code></li>
<li><code><a title="neurochat.nc_plot.spike_phase" href="#neurochat.nc_plot.spike_phase">spike_phase</a></code></li>
<li><code><a title="neurochat.nc_plot.spike_raster" href="#neurochat.nc_plot.spike_raster">spike_raster</a></code></li>
<li><code><a title="neurochat.nc_plot.stair_plot" href="#neurochat.nc_plot.stair_plot">stair_plot</a></code></li>
<li><code><a title="neurochat.nc_plot.theta_cell" href="#neurochat.nc_plot.theta_cell">theta_cell</a></code></li>
<li><code><a title="neurochat.nc_plot.wave_property" href="#neurochat.nc_plot.wave_property">wave_property</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>