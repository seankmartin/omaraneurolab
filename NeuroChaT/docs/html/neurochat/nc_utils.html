<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>neurochat.nc_utils API documentation</title>
<meta name="description" content="This module implements utility functions and classes for NeuroChaT software â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neurochat.nc_utils</code></h1>
</header>
<section id="section-intro">
<p>This module implements utility functions and classes for NeuroChaT software</p>
<p>@author: Md Nurul Islam; islammn at tcd dot ie</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module implements utility functions and classes for NeuroChaT software

@author: Md Nurul Islam; islammn at tcd dot ie

&#34;&#34;&#34;

import logging
import time
from collections import OrderedDict as oDict
import os
from os import listdir
from os.path import isfile, isdir, join
import re

import pandas as pd
import numpy as np
import numpy.linalg as nalg

import scipy
import scipy.stats as stats
import scipy.signal as sg
from scipy.fftpack import fft

class NLog(logging.Handler):
    &#34;&#34;&#34;
    Class for handling log information (messages, errors and warnings) for NeuroChaT.
    It formats the incoming message in HTML and sends it to the log interface of NeuroChaT.
    
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self.setup()
    def setup(self):
        &#34;&#34;&#34;
        Removes all the logging handlers and sets up a new logger with HTML formatting.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        log = logging.getLogger()
        for hdlr in log.handlers[:]:  # remove all old handlers
            log.removeHandler(hdlr)
        fmt = logging.Formatter(&#39;%(asctime)s (%(filename)s)  %(levelname)s--  %(message)s&#39;, &#39;%H:%M:%S&#39;)
        self.setFormatter(fmt)
        log.addHandler(self)
        # You can control the logging level
        log.setLevel(logging.DEBUG)
        logging.addLevelName(20, &#39;&#39;)
        
    def emit(self, record):
        &#34;&#34;&#34;
        Formats the incoming record and 
        
        Parameters
        ----------
        record
            Log record to dispkay or store
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        msg = self.format(record)
        level = record.levelname
        msg = level+ &#39;:&#39;+ msg
        print(msg)
        time.sleep(0.25)
#        self.emit(QtCore.SIGNAL(&#39;update_log(QString)&#39;), msg)

class Singleton(object):
    &#34;&#34;&#34;
    Creates a Singleton object created from a subclass of this class
    
    &#34;&#34;&#34;
    
    def __new__(cls, *arg, **kwarg):
        if not hasattr(cls, &#39;_instance&#39;):
            cls._instance = super().__new__(cls, *arg, **kwarg)
        return cls._instance

def bhatt(X1, X2):
    &#34;&#34;&#34;
    Calculates Bhattacharyya coefficient and Bhattacharyya distance between two distributions
    
    Parameters
    ----------
    X1, X2 : ndarray 
        Distributions under consideration
    
    Returns
    -------
    bc, d : float
        Bhattacharyya coefficient and Bhattacharyya distance
    
    &#34;&#34;&#34;
    
    r1, c1 = X1.shape
    r2, c2 = X2.shape
    if c1 == c2:
        mu1 = X1.mean(axis=0)
        mu2 = X2.mean(axis=0)
        C1 = np.cov(X1.T)
        C2 = np.cov(X2.T)
        C = (C1+ C2)/2
        chol = nalg.cholesky(C).T
        dmu = (mu1- mu2)@nalg.inv(chol)
        try:
            d = 0.125*dmu@(dmu.T)+ 0.5*np.log(nalg.det(C)/np.sqrt(nalg.det(C1)*nalg.det(C2)))
        except:
            d = 0.125*dmu@(dmu.T)+ 0.5*np.log(np.abs(nalg.det(C@nalg.inv(scipy.linalg.sqrtm(C1@C2)))))
        bc = np.exp(-1*d)

        return bc, d
    else:
        logging.error(&#39;Cannot measure Bhattacharyya distance, column sizes do not match!&#39;)

def butter_filter(x, Fs, *args):
    &#34;&#34;&#34;
    Filtering function using bidirectional zero-phase shift Butterworth filter.
    
    Parameters
    ----------
    x : ndarray 
        Data or signal to filter
    Fs : Sampling frequency
    *kwargs
        Arguments with filter paramters
    
    Returns
    -------
    ndarray
        Filtered signal
        
    &#34;&#34;&#34;
    
    gstop = 20 # minimum dB attenuation at stopabnd
    gpass = 3 # maximum dB loss during ripple
#    order= args[0]
    for arg in args:
        if isinstance(arg, str):
            filttype = arg
    if filttype == &#39;lowpass&#39; or filttype == &#39;highpass&#39;:
        wp = args[1]/(Fs/2)
        if wp &gt; 1:
            wp = 1
            if filttype == &#39;lowpass&#39;:
                logging.warning(&#39;Butterworth filter critical freqeuncy Wp is capped at 1&#39;)
            else:
                logging.error(&#39;Cannot highpass filter over Nyquist frequency!&#39;)

    elif filttype == &#39;bandpass&#39;:
        if len(args) &lt; 4:
            logging.error(&#39;Insufficient Butterworth filter arguments&#39;)
        else:
            wp = np.array(args[1:3])/(Fs/2)
            if wp[0] &gt;= wp[1]:
                logging.error(&#39;Butterworth filter lower cutoff frequency must be smaller than upper cutoff freqeuncy!&#39;)

            if wp[0] == 0 and wp[1] &gt;= 1:
                logging.error(&#39;Invalid filter specifications, check cutt off frequencies and sampling frequency!&#39;)
            elif wp[0] == 0:
                wp = wp[1]
                filttype = &#39;lowpass&#39;
                logging.warning(&#39;Butterworth filter type selected: lowpass&#39;)
            elif wp[1] &gt;= 1:
                wp = wp[0]
                filttype = &#39;highpass&#39;
                logging.warning(&#39;Butterworth filter type selected: highpass&#39;)

    if filttype == &#39;lowpass&#39;:
        ws = min([wp+ 0.1, 1])
    elif filttype == &#39;highpass&#39;:
        ws = max([wp- 0.1, 0.01/(Fs/2)])
    elif filttype == &#39;bandpass&#39;:
        ws = np.zeros_like(wp)
        ws[0] = max([wp[0]- 0.1, 0.01/(Fs/2)])
        ws[1] = min([wp[1]+ 0.1, 1])

    min_order, min_wp = sg.buttord(wp, ws, gpass, gstop)
#    if order&lt;= min_order:
#        order= min_order
#        wp= min_wp

    b, a = sg.butter(min_order, min_wp, btype=filttype, output=&#39;ba&#39;)

    return sg.filtfilt(b, a, x)

def chop_edges(x, xlen, ylen):
    &#34;&#34;&#34;
    Chope the edges of a firing rate map if they are not visited at ll or with zero firing rate
    
    Parameters
    ----------
    x : ndarray 
        Matrix of firing rate
    xlen : int
        Maximum length of the x-axis
    ylen : int
        Maximum length of the y-axis
    
    Returns
    -------
    low_ind : list of int
        Index of low end of valid edges
    hig_end :
        Index of high end of valid edges
    y : ndarray
        Chopped firing map
    
    &#34;&#34;&#34;
    
    y = np.copy(x)
    low_ind = [0, 0]
    high_ind = [x.shape[0], x.shape[1]]

    MOVEON = True
    while y.shape[1] &gt; xlen and MOVEON:
        no_filled_bins1 = np.sum(y[:, 0] &gt; 0)
        no_filled_bins2 = np.sum(y[:, -1] &gt; 0)

        if no_filled_bins1 == 0:
            low_ind[1] += 1
            MOVEON = True
        else:
            MOVEON = False
        if no_filled_bins2 == 0:
            high_ind[1] -= 1
            MOVEON = True
        else:
            MOVEON = False

# Following is the old MATLAB logic, we have changed it to remove the edges with zero count
#        if no_filled_bins1&lt; no_filled_bins2:
#            low_ind[1] += 1
#        else:
#            high_ind[1] -= 1
        y = x[low_ind[0]: high_ind[0], low_ind[1]:high_ind[1]]

    MOVEON = True
    while y.shape[0] &gt; ylen and MOVEON:
        no_filled_bins1 = np.sum(y[0, :] &gt; 0)
        no_filled_bins2 = np.sum(y[-1, :] &gt; 0)

        if no_filled_bins1 == 0:
            low_ind[0] += 1
            MOVEON = True
        else:
            MOVEON = False
        if no_filled_bins2 == 0:
            high_ind[0] -= 1
            MOVEON = True
        else:
            MOVEON = False

# Following is the old MATLAB logic, we have changed it to remove the edges with zero count
#        if no_filled_bins1&lt; no_filled_bins2:
#            low_ind[0] += 1
#        else:
#            high_ind[0]-=1
        y = x[low_ind[0]: high_ind[0], low_ind[1]:high_ind[1]]

    return low_ind, high_ind, y

def corr_coeff(x1, x2):
    &#34;&#34;&#34;
    Correlation coefficient between two numeric series or two signals.
    
    Parameters
    ----------
    x1, x2 : ndarray
        Input numeric array or signals
    
    Returns
    -------
    float
        Correlation coefficient of input arrays
    
    &#34;&#34;&#34;
    
    try:
        return np.sum(np.multiply(x1- x1.mean(), x2- x2.mean()))/ \
            np.sqrt(np.sum((x1- x1.mean())**2)*np.sum((x2- x2.mean())**2))
    except:
        return 0

def extrema(x, mincap=None, maxcap=None):
    &#34;&#34;&#34;
    Finds the extrema in a numeric array or a signal
    
    Parameters
    ----------
    mincap
        Maximum value for the minima
    maxcap
        Minimum value for the maxima
    
    Returns
    -------
    xmax : ndarray
        Maxima values
    imax : ndarray
        Maxima indices
    xmin : ndarray
        Minima values
    imin : ndarray
        Minima indices
    
    &#34;&#34;&#34;
    
    x = np.array(x)
    # Flat peaks at the end of the series are not considered yet
    dx = np.diff(x)
    if not np.any(dx):
        return [], [], [], []

    a = find(dx != 0) # indices where x changes
    lm = find(np.diff(a) != 1)+1 # indices where a is not sequential
    d = a[lm]- a[lm-1]
    a[lm] = a[lm]- np.floor(d//2)

    xa = x[a] # series without flat peaks
    d = np.sign(xa[1:-1]- xa[:-2])- np.sign(xa[2:]- xa[1:-1])
    imax = a[find(d &gt; 0)+1]
    xmax = x[imax]
    imin = a[find(d &lt; 0)+1]
    xmin = x[imin]

    if mincap:
        imin = imin[xmin &lt;= mincap]
        xmin = xmin[xmin &lt;= mincap]
    if maxcap:
        imax = imax[xmax &lt;= maxcap]
        xmax = xmax[xmax &lt;= maxcap]

    return xmax, imax, xmin, imin

def fft_psd(x, Fs, nfft=None, side=&#39;one&#39;, ptype=&#39;psd&#39;):
    &#34;&#34;&#34;
    Calculates the Fast Fourier Transform (FFT) of a signal.
    
    Parameters
    ----------
    x : ndarray
        Input signal
    Fs
        Sampling frequency
    nfft : int
        Number of FFT points
    side : str
        &#39;one&#39;-sided or &#39;two&#39;-sided FFT
    ptype : str
        Calculates power-spectral density if set to &#39;psd&#39;
    
    Returns
    -------
    x_fft : ndarray
        FFT of input
    f : ndarray
        FFt frequency
    
    &#34;&#34;&#34;


    if nfft is None:
        nfft = 2**(np.floor(np.log2(len(x)))+1)

    if nfft &lt; Fs:
        nfft = 2**(np.floor(np.log2(Fs))+1)
    nfft = int(nfft)
    dummy = np.zeros(nfft)
    if nfft &gt; len(x):
        dummy[:len(x)] = x
        x = dummy

    winfun = np.hanning(nfft)
    xf = np.arange(0, Fs, Fs/nfft)
    f = xf[0: int(nfft/2)+ 1]


    if side == &#39;one&#39;:
        x_fft = fft(np.multiply(x, winfun), nfft)
        if ptype == &#39;psd&#39;:
            x_fft = np.absolute(x_fft[0: int(nfft/2)+ 1])**2/nfft**2
            x_fft[1:-1] = 2*x_fft[1:-1]

    return x_fft, f

def find(X, n=None, direction=&#39;all&#39;):
    &#34;&#34;&#34;
    Finds the non-zero entries of a signal or array.
    
    Parameters
    ----------
    X : ndarray or list
        Array or list of numbers whose non-zero entries need to find out
    n : int
        Number of such entries
    direction : str
        If &#39;all&#39;, all entries of length n are returned. If &#39;first&#39;, first n entries
        are returned. If &#39;last&#39;, last n entrues are returned.
    
    Returns
    -------
    ndarray
        Indices of non-zero entries.
    
    &#34;&#34;&#34;
    
    if isinstance(X, list):
        X = np.array(X)
    X = X.flatten()
    if n is None:
        n = len(X)
    ind = np.where(X)[0]
    if ind.size:
        if direction == &#39;all&#39; or direction == &#39;first&#39;:
            ind = ind[:n]
        elif direction == &#39;last&#39;:
            ind = ind[np.flipud(np.arange(-1, -(n+1), - 1))]
    return np.array(ind)

def find2d(X, n=None):
    &#34;&#34;&#34;
    Finds the non-zero entries of a matrix.
    
    Parameters
    ----------
    X : ndarray
        Matrix whose non-zero entries need to find out
    n : int
        Number of such entries
    
    Returns
    -------
    ndarray
        x-indices of non-zero entries.
    ndarray
        y-indices of non-zero entries.
    
    &#34;&#34;&#34;
    
    if len(X.shape) == 2:
        J = []
        I = []
        for r in np.arange(X.shape[0]):
            I.extend(find(X[r, ]))
            J.extend(r*np.ones((len(find(X[r, ])), ), dtype=int))
        if len(I):
            if n is not None and n &lt; len(I):
                I = I[:n]
                J = J[:n]
        return np.array(J), np.array(I)

    else:
        logging.error(&#39;ndrray is not 2D. Check shape attributes of the input!&#39;)

def find_chunk(x):
    &#34;&#34;&#34;
    Finds size and indeices of chunks of non-zero segments in an array
    
    Parameters
    ----------
    x : ndarray
        Inout array whose non-zero chunks are to be explored
    
    Returns
    -------
    segsize : ndarray
        Lengths of non-zero chunks
    segind : ndarray
        Indices of non-zero chunks
    
    &#34;&#34;&#34;
    
    # x is a binary array input i.e. x= data&gt; 0.5 will find all the chunks in data where data is greater than 0.5
    i = 0
    segsize = []
    segind = np.zeros(x.shape)
    while i &lt; len(x):
        if x[i]:
            c = 0
            j = i
            while i &lt; len(x):
                if x[i]:
                    c += 1
                    i += 1
                else:
                    break
            segsize.append(c)
            segind[j:i] = c # indexing by size of the chunk
        i += 1
    return segsize, segind

def hellinger(X1, X2):
    &#34;&#34;&#34;
    Calculates Hellinger distance between two distributions.
    
    Parameters
    ----------
    X1, X2 : ndarray 
        Distributions under consideration
    
    Returns
    -------
    d : float
        Calculated Hellinger distance    
    
    &#34;&#34;&#34;    
    
    if X1.shape[1] != X2.shape[1]:
        logging.error(&#39;Hellinger distance cannot be computed, column sizes do not match!&#39;)
    else:
        return np.sqrt(1- bhatt(X1, X2)[0])

def histogram(x, bins):    
    &#34;&#34;&#34;
    Calculates the histogram count of input array
    
    Parameters
    ----------
    x : ndarray 
        Array whose histogram needs to be calculated
    bins
        Number of histogram bins
    
    Returns
    -------
    ndarray
        Histogram count
    ndarray
        Histogram bins(lowers edges)
    
    &#34;&#34;&#34;     
    # This function is not a replacement of np.histogram; it is created for convenience
    # of binned-based rate calculations and mimicking matlab histc that includes digitized indices
    if isinstance(bins, int):
        bins = np.arange(np.min(x), np.max(x), (np.max(x)- np.min(x))/bins)
    bins = np.append(bins, bins[-1]+ np.mean(np.diff(bins)))
    return np.histogram(x, bins)[0], np.digitize(x, bins)-1, bins[:- 1]

def histogram2d(y, x, ybins, xbins):
    &#34;&#34;&#34;
    Calculates the joint histogram count of two arrays
    
    Parameters
    ----------
    y, x : ndarray
        Arrays whose histogram needs to be calculated
    ybins
        Number of histogram bins in y-axis
    xbins
        Number of histogram bins in x-axis
    
    Returns
    -------
    ndarray
        Histogram count
    ndarray
        Histogram bins in x-axis (lowers edges)
    ndarray
        Histogram bins in y-axis (lowers edges)
    
    &#34;&#34;&#34;
    
    # This function is not a repalcement of np.histogram
    if isinstance(xbins, int):
        xbins = np.arange(np.min(x), np.max(x), (np.max(x)- np.min(x))/xbins)
    xbins = np.append(xbins, xbins[-1]+ np.mean(np.diff(xbins)))
    if isinstance(ybins, int):
        ybins = np.arange(np.min(y), np.max(y), (np.max(y)- np.min(y))/ybins)
    ybins = np.append(ybins, ybins[-1]+ np.mean(np.diff(ybins)))

    return np.histogram2d(y, x, [ybins, xbins])[0], ybins[:-1], xbins[:-1]

def linfit(X, Y, getPartial=False):
    &#34;&#34;&#34;
    Calculates the linear regression coefficients in least-square sense.
    
    Parameters
    ----------
    X : ndarray
        Matrix with input variables or factors (num_dim X num_obs)
    Y : ndarray
        Array of oservation data
    getPartial : bool
        Get the partial correlation coefficients if &#39;True&#39;
    
    Returns
    -------
    _results : dict
        Dictionary with results of least-square optimization of linear regression
        
    &#34;&#34;&#34;    
    
    _results = oDict()
    if len(X.shape) == 2:
        Nd, Nobs = X.shape
    else:
        Nobs = X.shape[0]
        Nd = 1
    if Nobs == len(Y):
        A = np.vstack([X, np.ones(X.shape[0])]).T
        B = np.linalg.lstsq(A, Y, rcond=-1)[0]
        Y_fit = np.matmul(A, B)
        _results[&#39;coeff&#39;] = B[:-1]
        _results[&#39;intercept&#39;] = B[-1]
        _results[&#39;yfit&#39;] = Y_fit
        _results.update(residual_stat(Y, Y_fit, 1))
    else:
        logging.error(&#39;linfit: Number of rows in X and Y does not match!&#39;)

    if Nd &gt; 1 and getPartial:
        semiCorr = np.zeros(Nd) # Semi partial correlation
        for d in np.arange(Nd):
            part_results = linfit(np.delete(X, 1, axis=0), Y, getPartial=False)
            semiCorr[d] = _results[&#39;Rsq&#39;]- part_results[&#39;Rsq&#39;]
        _results[&#39;semiCorr&#39;] = semiCorr

    return _results

def nxl_write(
    file_name, data_frame, sheet_name=&#39;Sheet1&#39;, startRow=0, startColumn=0):
    &#34;&#34;&#34;
    Write Pandas DataFrame to excel file. It is a wrapper for Pandas.ExcelWriter()
    
    Parameters
    ----------
    filename : str
        Name of the output file
    data_frame : pandas.DataFrame
        DataFrame to export
    sheet_name : str
        Sheet name of the Excel file where the data is written
    startRow : int
        Which row in the file the data writing should start
    startColumn : int
        Which column in the file the data writing should start        
    
    Returns
    -------
    None    
    
    &#34;&#34;&#34;
    # Create a Pandas Excel writer using XlsxWriter as the engine.
    writer = pd.ExcelWriter(file_name, engine=&#39;xlsxwriter&#39;)
    # Convert the dataframe to an XlsxWriter Excel object.
    data_frame.to_excel(writer, sheet_name)
    # Close the Pandas Excel writer and output the Excel file.
    writer.save()

def residual_stat(y, y_fit, p):
    &#34;&#34;&#34;
    Calculates the goodness of fit and other residual statistics between observed
    and fitted values from a model
    
    Parameters
    ----------
    y : ndarray
        Observed data
    y_fit : ndarray
        Fitted data to a linear model
    p : int
        Model order
    
    Returns
    -------
    _results : dict
        Dictionary of residual statistics
    
    &#34;&#34;&#34;
    
   # p= total explanatory variables excluding constants
    _results = oDict()
    res = y- y_fit
    ss_res = np.sum(res**2)
    ss_tot = np.sum((y- np.mean(y))**2)
    r_sq = 1- ss_res/ss_tot
    adj_r_sq = 1- (ss_res/ ss_tot)* ((len(y)-1)/(len(y)- p-1))
    _results[&#39;Pearson R&#39;], _results[&#39;Pearson P&#39;] = stats.pearsonr(y, y_fit)

    _results[&#39;Rsq&#39;] = r_sq
    _results[&#39;adj Rsq&#39;] = adj_r_sq

    return _results

def rot_2d(x, theta):
    &#34;&#34;&#34;
    Rotates a firing map by a specified angle
    
    Parameters
    ----------
    x : ndarray
        Matrix of firing rate map
    theta
        Angle of rotation in theta
        
    Returns
    -------
    ndarray
        Rotated matrix
    
    &#34;&#34;&#34;
    
    return scipy.ndimage.interpolation.rotate(x, theta, reshape=False, mode=&#39;constant&#39;, cval=np.min(x))

# Created by Sean Martin 14/02/2019
def angle_between_points(a, b, c):
    &#34;&#34;&#34;
    Returns the angle between the lines ab and bc, &lt;abc
    
    Parameters
    ----------
    a : ndarray
        The first point
    b : ndarray 
        The second point
    c : the last point
        
    Returns
    -------
    float
        The angle in degrees
    
    &#34;&#34;&#34;
    ba = a - b
    bc = c - b

    length_ba = np.linalg.norm(ba)
    length_bc = np.linalg.norm(bc)

    if length_bc != 0 and length_ba != 0:
        cosine_angle = np.dot(ba, bc) / (length_ba * length_bc)
        angle = np.arccos(cosine_angle)
    else:
        logging.error(
            &#34;Angle between points: Two points are the same&#34; +
            &#34; can&#39;t measure angle as a result&#34;)
        angle = np.NAN

    return np.degrees(angle)

def centre_of_mass(co_ords, weights, axis=0):
    &#34;&#34;&#34;
    Calculates the co-ordinate centre of mass for a system of particles with co ords and weights

    Parameters
    ----------
    co_ords : ndarray
        Array of co-ordinate positions, assumed to have co_ords.shape[axis] co-ordinates
    weights : ndarray
        Array of corresponding weights
    axis : int, default 0
        The axis along which the co-ordinates are specified, expected 0 or 1

    Returns
    -------
    ndarray
        Co-ordinate of the centre of mass
    &#34;&#34;&#34;
    shape = co_ords.shape
    if axis == 0:
        weighted = np.multiply(
            co_ords, 
            np.repeat(weights, shape[1]).reshape(shape))
    elif axis == 1:
        weighted = np.multiply(
            co_ords, 
            np.tile(weights, shape[0]).reshape(shape)) 
    else:
        logging.error(&#34;centre_of_mass: Expected axis to be 0 or 1&#34;)
    return np.sum(weighted, axis=axis) / np.sum(weights)
    
def smooth_1d(x, filttype=&#39;b&#39;, filtsize=5, **kwargs):
    &#34;&#34;&#34;
    Filters a 1D array or signal.
    
    Parameters
    ----------
    x : ndarray
        Array or signal to be filtered. If matrix, each column or row is filtered
        individually depending on &#39;dir&#39; parameter that takes either &#39;0&#39; for along-column
        and &#39;1&#39; for along-row filtering.
    filttype : str
        &#39;b&#39; for moving average or box filter. &#39;g&#39; for Gaussian filter
    filtsize
        Box size for box filter and sigma for Gaussian filter
        
    Returns
    -------
    ndarray
        Filtered data
    
    &#34;&#34;&#34;
    
    x = np.array(x)
    direction = kwargs.get(&#39;dir&#39;, 0) # default along column
    if filttype == &#39;g&#39;:
        halfwid = np.round(3*filtsize)
        xx = np.arange(-halfwid, halfwid+1, 1)
        filt = np.exp(-(xx**2)/(2*filtsize**2))/(np.sqrt(2*np.pi)*filtsize)
    elif filttype == &#39;b&#39;:
        filt = np.ones(filtsize, )/filtsize

    if len(x.shape) == 1:
        result = np.convolve(x, filt, mode=&#39;same&#39;)
    elif len([x.shape]) == 2:
        result = np.zeros(x.shape)
        if direction:
            for i in np.arange(0, x.shape[0]):
                result[i, :] = np.convolve(x[i, :], filt, mode=&#39;same&#39;)
        else:
            for i in np.arange(0, x.shape[0]):
                result[:, i] = np.convolve(x[:, i], filt, mode=&#39;same&#39;)
    return result

def smooth_2d(x, filttype=&#39;b&#39;, filtsize=5):
    &#34;&#34;&#34;
    Filters a 2D array or signal.
    
    Parameters
    ----------
    x : ndarray
        Matrix to be filtered
    filttype : str
        &#39;b&#39; for moving average or box filter. &#39;g&#39; for Gaussian filter
    filtsize
        Box size for box filter and sigma for Gaussian filter
        
    Returns
    -------
    smoothX
        Filtered matrix
    
    &#34;&#34;&#34;
    
    nanInd = np.isnan(x)
    x[nanInd] = 0
    if filttype == &#39;g&#39;:
        halfwid = np.round(3*filtsize)
        xx, yy = np.meshgrid(np.arange(-halfwid, halfwid+1, 1), np.arange(-halfwid, halfwid+1, 1), copy=False)
        filt = np.exp(-(xx**2+ yy**2)/(2*filtsize**2)) # /(2*np.pi*filtsize**2) # This is the scaling used before;
                                                        #But tested with ones(50, 50); gives a hogher value
        filt = filt/ np.sum(filt)
    elif filttype == &#39;b&#39;:
        filt = np.ones((filtsize, filtsize))/filtsize**2

    smoothX = sg.convolve2d(x, filt, mode=&#39;same&#39;)
    smoothX[nanInd] = np.nan

    return smoothX

def find_true_ranges(arr, truth_arr, min_range):
    &#34;&#34;&#34;
    Returns a list of ranges where truth values occur and the corresponding
    values from arr, arr is assumed to be a sorted list

    Parameters
    ----------
    arr : ndarray
        list of values to get ranges from, equal in length to truth_arr
    truth_arr : ndarray
        list of truth values to make the ranges
    min_range : int or float 
        the minimum length of range

    Returns
    -------
    list
        A list of tuples, ranges in arr where truth values are truth_arr
    &#34;&#34;&#34;

    in_range = False
    ranges = []
    for idx, b in enumerate(truth_arr):
        if b and not in_range:
            in_range = True
            range_start = arr[idx]
        if not b and in_range:
            in_range = False
            range_end = arr[idx - 1]
            if range_end - range_start &gt; min_range:
                ranges.append((range_start, range_end))
    return ranges

def find_peaks(data, **kwargs):
    &#34;&#34;&#34;
    Returns the peaks in the data based on gradient calculations

    Parameters
    ----------
    kwargs
        start : int 
            Where to start looking for peaks in the data, default 0
        end : int
            Where to stop looking for peaks in the data, default data.size - 1
        thresh : float
            Don&#39;t consider any peaks with a value below this, default 0
    &#34;&#34;&#34;

    data = np.array(data)
    slope = np.diff(data)
    start_at = kwargs.get(&#39;start&#39;, 0)
    end_at = kwargs.get(&#39;end&#39;, slope.size)
    thresh = kwargs.get(&#39;thresh&#39;, 0)

    peak_loc = [j for j in np.arange(start_at, end_at-1) \
                if slope[j] &gt; 0 and slope[j+1] &lt;= 0]
    peak_val = [data[peak_loc[i]] for i in range(0, len(peak_loc))]

    valid_loc = [
        i for i in range(0, len(peak_loc)) if peak_val[i] &gt;= thresh]
    if len(valid_loc) == 0:
        return []
    peak_val, peak_loc= zip(*((peak_val[i], peak_loc[i]) for i in valid_loc))
    return np.array(peak_val), np.array(peak_loc)


def log_exception(ex, more_info=&#34;&#34;):
    &#34;&#34;&#34;
    Log an expection and additional info

    Parameters
    ----------
    ex : Exception
        The python exception that occured
    more_info : 
        Additional string to log
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;

    template = &#34;{0} because exception of type {1} occurred. Arguments:\n{2!r}&#34;
    message = template.format(more_info, type(ex).__name__, ex.args)
    logging.error(message)

def window_rms(a, window_size, mode=&#34;same&#34;):
    &#34;&#34;&#34;
    Calculate the rms envelope, similar to matlab.  
    
    mode determines how many points are output
    mode valid will have no border effects
    mode same will produce a value for each input
    &#34;&#34;&#34;
    a2 = np.power(a,2)
    window = np.ones(window_size)/float(window_size)
    return np.sqrt(np.convolve(a2, window, mode))

def distinct_window_rms(a, N):
    &#34;&#34;&#34;
    Calculate the rms of a in windows of N data points.
    &#34;&#34;&#34;
    a = np.array(a)
    a = np.square(a) / float(N)
    rms_array = []
    rms = 0
    
    # For now, just throw away the last window if it does not fit
    for idx, point in enumerate(a):
        rms += point
        if idx % N == N-1:
            rms_array.append(np.sqrt(rms))
            rms = 0
    return rms_array

def static_vars(**kwargs):
    def decorate(func):
        for k in kwargs:
            setattr(func, k, kwargs[k])
        return func
    return decorate

@static_vars(colorcells=[])
def get_axona_colours(index=None):
    &#34;&#34;&#34;
    Create Axona cell colours.
    
    Parameters
    ----------
    index : int
        Optional integer to get colours at
    Returns
    -------
    list :
        A list of colours as rgb tuples with values in 0 to 1
    &#34;&#34;&#34;

    if len(get_axona_colours.colorcells) == 0:
    # crget_axona_colours.eate Axona cell colours if don&#39;t exist
        get_axona_colours.colorcells.append((0,0,200/255))
        get_axona_colours.colorcells.append((80/255,1,80/255))
        get_axona_colours.colorcells.append((1,0,0))
        get_axona_colours.colorcells.append((245/255,0,1))
        get_axona_colours.colorcells.append((75/255,200/255,255/255))
        get_axona_colours.colorcells.append((0/255, 185/255,0/255))
        get_axona_colours.colorcells.append((255/255, 185/255,50/255))
        get_axona_colours.colorcells.append((0/255, 150/255,175/255))
        get_axona_colours.colorcells.append((150/255, 0/255,175/255))
        get_axona_colours.colorcells.append((170/255, 170/255,0/255))
        get_axona_colours.colorcells.append((200/255, 0/255,0/255))
        get_axona_colours.colorcells.append((255/255, 255/255,0/255))
        get_axona_colours.colorcells.append((140/255, 140/255,140/255))
        get_axona_colours.colorcells.append((0/255, 255/255,255/255))
        get_axona_colours.colorcells.append((255/255, 0/255,160/255))
        get_axona_colours.colorcells.append((175/255, 75/255, 75/255))
        get_axona_colours.colorcells.append((255/255, 155/255, 175/255))
        get_axona_colours.colorcells.append((190/255, 190/255, 190/255))
        get_axona_colours.colorcells.append((255/255, 255/255, 75/255))
        get_axona_colours.colorcells.append((154/255, 205/255, 50/255))
        get_axona_colours.colorcells.append((255/255, 99/255, 71/255))
        get_axona_colours.colorcells.append((0/255, 255/255, 127/255))
        get_axona_colours.colorcells.append((255/255, 140/255, 0/255))
        get_axona_colours.colorcells.append((32/255, 178/255, 170/255))
        get_axona_colours.colorcells.append((255/255, 69/255, 0/255))
        get_axona_colours.colorcells.append((240/255, 230/255, 140/255))
        get_axona_colours.colorcells.append((100/255, 145/255, 237/255))
        get_axona_colours.colorcells.append((255/255, 218/255, 185/255))
        get_axona_colours.colorcells.append((153/255, 50/255, 204/255))
        get_axona_colours.colorcells.append((250/255, 128/255, 114/255))

    if index is None:
        return get_axona_colours.colorcells
    else:
        if index &gt;= len(get_axona_colours.colorcells):
            logging.error(&#34;Passed colour index out of range&#34;)
            return
        return get_axona_colours.colorcells[index]

def has_ext(filename, ext):
    &#34;&#34;&#34;
    Check if the filename ends in the extension
    
    Parameters
    ----------
    filename : str
        The name of the file
    ext : str
        The extension, may have leading dot (e.g txt == .txt)
    
    Returns
    -------
    bool indicating if the filename has the extension

    &#34;&#34;&#34;
    if ext == None:
        return True
    if ext[0] != &#34;.&#34;:
        ext = &#34;.&#34; + ext
    return filename[-len(ext):].lower() == ext.lower()


def get_all_files_in_dir(
        in_dir, ext=None, return_absolute=True, 
        recursive=False, verbose=False, re_filter=None):
    &#34;&#34;&#34;
    Get all files in the directory with the given extension.
    
    Parameters
    ----------
    in_dir : str
        The absolute path to the directory
    ext : str, optional. Defaults to True.
        The extension of files to get.
    return_absolute : bool, optional. Defaults to True.
        Whether to return the absolute filename or not.
    recursive: bool, optional. Defaults to False.
        Whether to recurse through directories.
    verbose: bool, optional. Defaults to False.
        Whether to print the files found.

    Returns
    -------
    List : A list of filenames
    &#34;&#34;&#34;
    if not isdir(in_dir):
        print(&#34;Non existant directory &#34; + str(in_dir))
        return []

    def match_filter(f):
        if re_filter is None:
            return True
        search_res = re.search(re_filter, f)
        return search_res is not None

    def ok_file(root_dir, f):
        return has_ext(f, ext) and isfile(join(root_dir, f)) and match_filter(f)

    def convert_to_path(root_dir, f): 
        return join(root_dir, f) if return_absolute else f

    if verbose:
        print(&#34;Adding following files from {}&#34;.format(in_dir))

    if recursive:
        onlyfiles = []
        for root, _, filenames in os.walk(in_dir):
            start_root = root[:len(in_dir)]

            if len(root) == len(start_root):
                end_root = &#34;&#34;
            else:
                end_root = root[len(in_dir + os.sep):]
            for filename in filenames:
                filename = join(end_root, filename)
                if ok_file(start_root, filename):
                    to_add = convert_to_path(start_root, filename)
                    if verbose:
                        print(to_add)
                    onlyfiles.append(to_add)

    else:
        onlyfiles = [
            convert_to_path(in_dir, f) for f in sorted(listdir(in_dir))
            if ok_file(in_dir, f)
        ]
        if verbose:
            for f in onlyfiles:
                print(f)

    if verbose:
        print()
    return onlyfiles

def make_dir_if_not_exists(location):
    &#34;&#34;&#34;Makes directory structure for given location&#34;&#34;&#34;
    os.makedirs(os.path.dirname(location), exist_ok=True)

def remove_extension(filename, keep_dot=True, return_ext=False):
    modifier = 0 if keep_dot else 1
    ext = filename.split(&#34;.&#34;)[-1]
    remove = len(ext) + modifier
    if return_ext:
        return filename[:-remove], ext
    else:
        return filename[:-remove]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="neurochat.nc_utils.angle_between_points"><code class="name flex">
<span>def <span class="ident">angle_between_points</span></span>(<span>a, b, c)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the angle between the lines ab and bc, &lt;abc</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The first point</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>The second point</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>the</code> <code>last</code> <code>point</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The angle in degrees</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def angle_between_points(a, b, c):
    &#34;&#34;&#34;
    Returns the angle between the lines ab and bc, &lt;abc
    
    Parameters
    ----------
    a : ndarray
        The first point
    b : ndarray 
        The second point
    c : the last point
        
    Returns
    -------
    float
        The angle in degrees
    
    &#34;&#34;&#34;
    ba = a - b
    bc = c - b

    length_ba = np.linalg.norm(ba)
    length_bc = np.linalg.norm(bc)

    if length_bc != 0 and length_ba != 0:
        cosine_angle = np.dot(ba, bc) / (length_ba * length_bc)
        angle = np.arccos(cosine_angle)
    else:
        logging.error(
            &#34;Angle between points: Two points are the same&#34; +
            &#34; can&#39;t measure angle as a result&#34;)
        angle = np.NAN

    return np.degrees(angle)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.bhatt"><code class="name flex">
<span>def <span class="ident">bhatt</span></span>(<span>X1, X2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates Bhattacharyya coefficient and Bhattacharyya distance between two distributions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X1</code></strong>, <strong><code>X2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Distributions under consideration</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bc</code></strong>, <strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>Bhattacharyya coefficient and Bhattacharyya distance</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def bhatt(X1, X2):
    &#34;&#34;&#34;
    Calculates Bhattacharyya coefficient and Bhattacharyya distance between two distributions
    
    Parameters
    ----------
    X1, X2 : ndarray 
        Distributions under consideration
    
    Returns
    -------
    bc, d : float
        Bhattacharyya coefficient and Bhattacharyya distance
    
    &#34;&#34;&#34;
    
    r1, c1 = X1.shape
    r2, c2 = X2.shape
    if c1 == c2:
        mu1 = X1.mean(axis=0)
        mu2 = X2.mean(axis=0)
        C1 = np.cov(X1.T)
        C2 = np.cov(X2.T)
        C = (C1+ C2)/2
        chol = nalg.cholesky(C).T
        dmu = (mu1- mu2)@nalg.inv(chol)
        try:
            d = 0.125*dmu@(dmu.T)+ 0.5*np.log(nalg.det(C)/np.sqrt(nalg.det(C1)*nalg.det(C2)))
        except:
            d = 0.125*dmu@(dmu.T)+ 0.5*np.log(np.abs(nalg.det(C@nalg.inv(scipy.linalg.sqrtm(C1@C2)))))
        bc = np.exp(-1*d)

        return bc, d
    else:
        logging.error(&#39;Cannot measure Bhattacharyya distance, column sizes do not match!&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.butter_filter"><code class="name flex">
<span>def <span class="ident">butter_filter</span></span>(<span>x, Fs, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Filtering function using bidirectional zero-phase shift Butterworth filter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Data or signal to filter</dd>
<dt><strong><code>Fs</code></strong> :&ensp;<code>Sampling</code> <code>frequency</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>*kwargs</code></strong></dt>
<dd>Arguments with filter paramters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Filtered signal</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def butter_filter(x, Fs, *args):
    &#34;&#34;&#34;
    Filtering function using bidirectional zero-phase shift Butterworth filter.
    
    Parameters
    ----------
    x : ndarray 
        Data or signal to filter
    Fs : Sampling frequency
    *kwargs
        Arguments with filter paramters
    
    Returns
    -------
    ndarray
        Filtered signal
        
    &#34;&#34;&#34;
    
    gstop = 20 # minimum dB attenuation at stopabnd
    gpass = 3 # maximum dB loss during ripple
#    order= args[0]
    for arg in args:
        if isinstance(arg, str):
            filttype = arg
    if filttype == &#39;lowpass&#39; or filttype == &#39;highpass&#39;:
        wp = args[1]/(Fs/2)
        if wp &gt; 1:
            wp = 1
            if filttype == &#39;lowpass&#39;:
                logging.warning(&#39;Butterworth filter critical freqeuncy Wp is capped at 1&#39;)
            else:
                logging.error(&#39;Cannot highpass filter over Nyquist frequency!&#39;)

    elif filttype == &#39;bandpass&#39;:
        if len(args) &lt; 4:
            logging.error(&#39;Insufficient Butterworth filter arguments&#39;)
        else:
            wp = np.array(args[1:3])/(Fs/2)
            if wp[0] &gt;= wp[1]:
                logging.error(&#39;Butterworth filter lower cutoff frequency must be smaller than upper cutoff freqeuncy!&#39;)

            if wp[0] == 0 and wp[1] &gt;= 1:
                logging.error(&#39;Invalid filter specifications, check cutt off frequencies and sampling frequency!&#39;)
            elif wp[0] == 0:
                wp = wp[1]
                filttype = &#39;lowpass&#39;
                logging.warning(&#39;Butterworth filter type selected: lowpass&#39;)
            elif wp[1] &gt;= 1:
                wp = wp[0]
                filttype = &#39;highpass&#39;
                logging.warning(&#39;Butterworth filter type selected: highpass&#39;)

    if filttype == &#39;lowpass&#39;:
        ws = min([wp+ 0.1, 1])
    elif filttype == &#39;highpass&#39;:
        ws = max([wp- 0.1, 0.01/(Fs/2)])
    elif filttype == &#39;bandpass&#39;:
        ws = np.zeros_like(wp)
        ws[0] = max([wp[0]- 0.1, 0.01/(Fs/2)])
        ws[1] = min([wp[1]+ 0.1, 1])

    min_order, min_wp = sg.buttord(wp, ws, gpass, gstop)
#    if order&lt;= min_order:
#        order= min_order
#        wp= min_wp

    b, a = sg.butter(min_order, min_wp, btype=filttype, output=&#39;ba&#39;)

    return sg.filtfilt(b, a, x)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.centre_of_mass"><code class="name flex">
<span>def <span class="ident">centre_of_mass</span></span>(<span>co_ords, weights, axis=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the co-ordinate centre of mass for a system of particles with co ords and weights</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>co_ords</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of co-ordinate positions, assumed to have co_ords.shape[axis] co-ordinates</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of corresponding weights</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>The axis along which the co-ordinates are specified, expected 0 or 1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Co-ordinate of the centre of mass</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def centre_of_mass(co_ords, weights, axis=0):
    &#34;&#34;&#34;
    Calculates the co-ordinate centre of mass for a system of particles with co ords and weights

    Parameters
    ----------
    co_ords : ndarray
        Array of co-ordinate positions, assumed to have co_ords.shape[axis] co-ordinates
    weights : ndarray
        Array of corresponding weights
    axis : int, default 0
        The axis along which the co-ordinates are specified, expected 0 or 1

    Returns
    -------
    ndarray
        Co-ordinate of the centre of mass
    &#34;&#34;&#34;
    shape = co_ords.shape
    if axis == 0:
        weighted = np.multiply(
            co_ords, 
            np.repeat(weights, shape[1]).reshape(shape))
    elif axis == 1:
        weighted = np.multiply(
            co_ords, 
            np.tile(weights, shape[0]).reshape(shape)) 
    else:
        logging.error(&#34;centre_of_mass: Expected axis to be 0 or 1&#34;)
    return np.sum(weighted, axis=axis) / np.sum(weights)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.chop_edges"><code class="name flex">
<span>def <span class="ident">chop_edges</span></span>(<span>x, xlen, ylen)</span>
</code></dt>
<dd>
<section class="desc"><p>Chope the edges of a firing rate map if they are not visited at ll or with zero firing rate</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix of firing rate</dd>
<dt><strong><code>xlen</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum length of the x-axis</dd>
<dt><strong><code>ylen</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum length of the y-axis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>low_ind</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>Index of low end of valid edges</dd>
<dt><code>hig_end</code> :</dt>
<dd>Index of high end of valid edges</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Chopped firing map</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def chop_edges(x, xlen, ylen):
    &#34;&#34;&#34;
    Chope the edges of a firing rate map if they are not visited at ll or with zero firing rate
    
    Parameters
    ----------
    x : ndarray 
        Matrix of firing rate
    xlen : int
        Maximum length of the x-axis
    ylen : int
        Maximum length of the y-axis
    
    Returns
    -------
    low_ind : list of int
        Index of low end of valid edges
    hig_end :
        Index of high end of valid edges
    y : ndarray
        Chopped firing map
    
    &#34;&#34;&#34;
    
    y = np.copy(x)
    low_ind = [0, 0]
    high_ind = [x.shape[0], x.shape[1]]

    MOVEON = True
    while y.shape[1] &gt; xlen and MOVEON:
        no_filled_bins1 = np.sum(y[:, 0] &gt; 0)
        no_filled_bins2 = np.sum(y[:, -1] &gt; 0)

        if no_filled_bins1 == 0:
            low_ind[1] += 1
            MOVEON = True
        else:
            MOVEON = False
        if no_filled_bins2 == 0:
            high_ind[1] -= 1
            MOVEON = True
        else:
            MOVEON = False

# Following is the old MATLAB logic, we have changed it to remove the edges with zero count
#        if no_filled_bins1&lt; no_filled_bins2:
#            low_ind[1] += 1
#        else:
#            high_ind[1] -= 1
        y = x[low_ind[0]: high_ind[0], low_ind[1]:high_ind[1]]

    MOVEON = True
    while y.shape[0] &gt; ylen and MOVEON:
        no_filled_bins1 = np.sum(y[0, :] &gt; 0)
        no_filled_bins2 = np.sum(y[-1, :] &gt; 0)

        if no_filled_bins1 == 0:
            low_ind[0] += 1
            MOVEON = True
        else:
            MOVEON = False
        if no_filled_bins2 == 0:
            high_ind[0] -= 1
            MOVEON = True
        else:
            MOVEON = False

# Following is the old MATLAB logic, we have changed it to remove the edges with zero count
#        if no_filled_bins1&lt; no_filled_bins2:
#            low_ind[0] += 1
#        else:
#            high_ind[0]-=1
        y = x[low_ind[0]: high_ind[0], low_ind[1]:high_ind[1]]

    return low_ind, high_ind, y</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.corr_coeff"><code class="name flex">
<span>def <span class="ident">corr_coeff</span></span>(<span>x1, x2)</span>
</code></dt>
<dd>
<section class="desc"><p>Correlation coefficient between two numeric series or two signals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x1</code></strong>, <strong><code>x2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Input numeric array or signals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Correlation coefficient of input arrays</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def corr_coeff(x1, x2):
    &#34;&#34;&#34;
    Correlation coefficient between two numeric series or two signals.
    
    Parameters
    ----------
    x1, x2 : ndarray
        Input numeric array or signals
    
    Returns
    -------
    float
        Correlation coefficient of input arrays
    
    &#34;&#34;&#34;
    
    try:
        return np.sum(np.multiply(x1- x1.mean(), x2- x2.mean()))/ \
            np.sqrt(np.sum((x1- x1.mean())**2)*np.sum((x2- x2.mean())**2))
    except:
        return 0</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.distinct_window_rms"><code class="name flex">
<span>def <span class="ident">distinct_window_rms</span></span>(<span>a, N)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the rms of a in windows of N data points.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def distinct_window_rms(a, N):
    &#34;&#34;&#34;
    Calculate the rms of a in windows of N data points.
    &#34;&#34;&#34;
    a = np.array(a)
    a = np.square(a) / float(N)
    rms_array = []
    rms = 0
    
    # For now, just throw away the last window if it does not fit
    for idx, point in enumerate(a):
        rms += point
        if idx % N == N-1:
            rms_array.append(np.sqrt(rms))
            rms = 0
    return rms_array</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.extrema"><code class="name flex">
<span>def <span class="ident">extrema</span></span>(<span>x, mincap=None, maxcap=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Finds the extrema in a numeric array or a signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mincap</code></strong></dt>
<dd>Maximum value for the minima</dd>
<dt><strong><code>maxcap</code></strong></dt>
<dd>Minimum value for the maxima</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>xmax</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Maxima values</dd>
<dt><strong><code>imax</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Maxima indices</dd>
<dt><strong><code>xmin</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Minima values</dd>
<dt><strong><code>imin</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Minima indices</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def extrema(x, mincap=None, maxcap=None):
    &#34;&#34;&#34;
    Finds the extrema in a numeric array or a signal
    
    Parameters
    ----------
    mincap
        Maximum value for the minima
    maxcap
        Minimum value for the maxima
    
    Returns
    -------
    xmax : ndarray
        Maxima values
    imax : ndarray
        Maxima indices
    xmin : ndarray
        Minima values
    imin : ndarray
        Minima indices
    
    &#34;&#34;&#34;
    
    x = np.array(x)
    # Flat peaks at the end of the series are not considered yet
    dx = np.diff(x)
    if not np.any(dx):
        return [], [], [], []

    a = find(dx != 0) # indices where x changes
    lm = find(np.diff(a) != 1)+1 # indices where a is not sequential
    d = a[lm]- a[lm-1]
    a[lm] = a[lm]- np.floor(d//2)

    xa = x[a] # series without flat peaks
    d = np.sign(xa[1:-1]- xa[:-2])- np.sign(xa[2:]- xa[1:-1])
    imax = a[find(d &gt; 0)+1]
    xmax = x[imax]
    imin = a[find(d &lt; 0)+1]
    xmin = x[imin]

    if mincap:
        imin = imin[xmin &lt;= mincap]
        xmin = xmin[xmin &lt;= mincap]
    if maxcap:
        imax = imax[xmax &lt;= maxcap]
        xmax = xmax[xmax &lt;= maxcap]

    return xmax, imax, xmin, imin</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.fft_psd"><code class="name flex">
<span>def <span class="ident">fft_psd</span></span>(<span>x, Fs, nfft=None, side='one', ptype='psd')</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the Fast Fourier Transform (FFT) of a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Input signal</dd>
<dt><strong><code>Fs</code></strong></dt>
<dd>Sampling frequency</dd>
<dt><strong><code>nfft</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of FFT points</dd>
<dt><strong><code>side</code></strong> :&ensp;<code>str</code></dt>
<dd>'one'-sided or 'two'-sided FFT</dd>
<dt><strong><code>ptype</code></strong> :&ensp;<code>str</code></dt>
<dd>Calculates power-spectral density if set to 'psd'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x_fft</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>FFT of input</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>FFt frequency</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fft_psd(x, Fs, nfft=None, side=&#39;one&#39;, ptype=&#39;psd&#39;):
    &#34;&#34;&#34;
    Calculates the Fast Fourier Transform (FFT) of a signal.
    
    Parameters
    ----------
    x : ndarray
        Input signal
    Fs
        Sampling frequency
    nfft : int
        Number of FFT points
    side : str
        &#39;one&#39;-sided or &#39;two&#39;-sided FFT
    ptype : str
        Calculates power-spectral density if set to &#39;psd&#39;
    
    Returns
    -------
    x_fft : ndarray
        FFT of input
    f : ndarray
        FFt frequency
    
    &#34;&#34;&#34;


    if nfft is None:
        nfft = 2**(np.floor(np.log2(len(x)))+1)

    if nfft &lt; Fs:
        nfft = 2**(np.floor(np.log2(Fs))+1)
    nfft = int(nfft)
    dummy = np.zeros(nfft)
    if nfft &gt; len(x):
        dummy[:len(x)] = x
        x = dummy

    winfun = np.hanning(nfft)
    xf = np.arange(0, Fs, Fs/nfft)
    f = xf[0: int(nfft/2)+ 1]


    if side == &#39;one&#39;:
        x_fft = fft(np.multiply(x, winfun), nfft)
        if ptype == &#39;psd&#39;:
            x_fft = np.absolute(x_fft[0: int(nfft/2)+ 1])**2/nfft**2
            x_fft[1:-1] = 2*x_fft[1:-1]

    return x_fft, f</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>X, n=None, direction='all')</span>
</code></dt>
<dd>
<section class="desc"><p>Finds the non-zero entries of a signal or array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Array or list of numbers whose non-zero entries need to find out</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of such entries</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>str</code></dt>
<dd>If 'all', all entries of length n are returned. If 'first', first n entries
are returned. If 'last', last n entrues are returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Indices of non-zero entries.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find(X, n=None, direction=&#39;all&#39;):
    &#34;&#34;&#34;
    Finds the non-zero entries of a signal or array.
    
    Parameters
    ----------
    X : ndarray or list
        Array or list of numbers whose non-zero entries need to find out
    n : int
        Number of such entries
    direction : str
        If &#39;all&#39;, all entries of length n are returned. If &#39;first&#39;, first n entries
        are returned. If &#39;last&#39;, last n entrues are returned.
    
    Returns
    -------
    ndarray
        Indices of non-zero entries.
    
    &#34;&#34;&#34;
    
    if isinstance(X, list):
        X = np.array(X)
    X = X.flatten()
    if n is None:
        n = len(X)
    ind = np.where(X)[0]
    if ind.size:
        if direction == &#39;all&#39; or direction == &#39;first&#39;:
            ind = ind[:n]
        elif direction == &#39;last&#39;:
            ind = ind[np.flipud(np.arange(-1, -(n+1), - 1))]
    return np.array(ind)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.find2d"><code class="name flex">
<span>def <span class="ident">find2d</span></span>(<span>X, n=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Finds the non-zero entries of a matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix whose non-zero entries need to find out</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of such entries</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>x-indices of non-zero entries.</dd>
<dt><code>ndarray</code></dt>
<dd>y-indices of non-zero entries.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find2d(X, n=None):
    &#34;&#34;&#34;
    Finds the non-zero entries of a matrix.
    
    Parameters
    ----------
    X : ndarray
        Matrix whose non-zero entries need to find out
    n : int
        Number of such entries
    
    Returns
    -------
    ndarray
        x-indices of non-zero entries.
    ndarray
        y-indices of non-zero entries.
    
    &#34;&#34;&#34;
    
    if len(X.shape) == 2:
        J = []
        I = []
        for r in np.arange(X.shape[0]):
            I.extend(find(X[r, ]))
            J.extend(r*np.ones((len(find(X[r, ])), ), dtype=int))
        if len(I):
            if n is not None and n &lt; len(I):
                I = I[:n]
                J = J[:n]
        return np.array(J), np.array(I)

    else:
        logging.error(&#39;ndrray is not 2D. Check shape attributes of the input!&#39;)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.find_chunk"><code class="name flex">
<span>def <span class="ident">find_chunk</span></span>(<span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Finds size and indeices of chunks of non-zero segments in an array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Inout array whose non-zero chunks are to be explored</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>segsize</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Lengths of non-zero chunks</dd>
<dt><strong><code>segind</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Indices of non-zero chunks</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find_chunk(x):
    &#34;&#34;&#34;
    Finds size and indeices of chunks of non-zero segments in an array
    
    Parameters
    ----------
    x : ndarray
        Inout array whose non-zero chunks are to be explored
    
    Returns
    -------
    segsize : ndarray
        Lengths of non-zero chunks
    segind : ndarray
        Indices of non-zero chunks
    
    &#34;&#34;&#34;
    
    # x is a binary array input i.e. x= data&gt; 0.5 will find all the chunks in data where data is greater than 0.5
    i = 0
    segsize = []
    segind = np.zeros(x.shape)
    while i &lt; len(x):
        if x[i]:
            c = 0
            j = i
            while i &lt; len(x):
                if x[i]:
                    c += 1
                    i += 1
                else:
                    break
            segsize.append(c)
            segind[j:i] = c # indexing by size of the chunk
        i += 1
    return segsize, segind</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.find_peaks"><code class="name flex">
<span>def <span class="ident">find_peaks</span></span>(<span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the peaks in the data based on gradient calculations</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>start : int
Where to start looking for peaks in the data, default 0
end : int
Where to stop looking for peaks in the data, default data.size - 1
thresh : float
Don't consider any peaks with a value below this, default 0</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find_peaks(data, **kwargs):
    &#34;&#34;&#34;
    Returns the peaks in the data based on gradient calculations

    Parameters
    ----------
    kwargs
        start : int 
            Where to start looking for peaks in the data, default 0
        end : int
            Where to stop looking for peaks in the data, default data.size - 1
        thresh : float
            Don&#39;t consider any peaks with a value below this, default 0
    &#34;&#34;&#34;

    data = np.array(data)
    slope = np.diff(data)
    start_at = kwargs.get(&#39;start&#39;, 0)
    end_at = kwargs.get(&#39;end&#39;, slope.size)
    thresh = kwargs.get(&#39;thresh&#39;, 0)

    peak_loc = [j for j in np.arange(start_at, end_at-1) \
                if slope[j] &gt; 0 and slope[j+1] &lt;= 0]
    peak_val = [data[peak_loc[i]] for i in range(0, len(peak_loc))]

    valid_loc = [
        i for i in range(0, len(peak_loc)) if peak_val[i] &gt;= thresh]
    if len(valid_loc) == 0:
        return []
    peak_val, peak_loc= zip(*((peak_val[i], peak_loc[i]) for i in valid_loc))
    return np.array(peak_val), np.array(peak_loc)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.find_true_ranges"><code class="name flex">
<span>def <span class="ident">find_true_ranges</span></span>(<span>arr, truth_arr, min_range)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of ranges where truth values occur and the corresponding
values from arr, arr is assumed to be a sorted list</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>list of values to get ranges from, equal in length to truth_arr</dd>
<dt><strong><code>truth_arr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>list of truth values to make the ranges</dd>
<dt><strong><code>min_range</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>the minimum length of range</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of tuples, ranges in arr where truth values are truth_arr</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find_true_ranges(arr, truth_arr, min_range):
    &#34;&#34;&#34;
    Returns a list of ranges where truth values occur and the corresponding
    values from arr, arr is assumed to be a sorted list

    Parameters
    ----------
    arr : ndarray
        list of values to get ranges from, equal in length to truth_arr
    truth_arr : ndarray
        list of truth values to make the ranges
    min_range : int or float 
        the minimum length of range

    Returns
    -------
    list
        A list of tuples, ranges in arr where truth values are truth_arr
    &#34;&#34;&#34;

    in_range = False
    ranges = []
    for idx, b in enumerate(truth_arr):
        if b and not in_range:
            in_range = True
            range_start = arr[idx]
        if not b and in_range:
            in_range = False
            range_end = arr[idx - 1]
            if range_end - range_start &gt; min_range:
                ranges.append((range_start, range_end))
    return ranges</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.get_all_files_in_dir"><code class="name flex">
<span>def <span class="ident">get_all_files_in_dir</span></span>(<span>in_dir, ext=None, return_absolute=True, recursive=False, verbose=False, re_filter=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get all files in the directory with the given extension.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>in_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The absolute path to the directory</dd>
</dl>
<p>ext : str, optional. Defaults to True.
The extension of files to get.
return_absolute : bool, optional. Defaults to True.
Whether to return the absolute filename or not.
recursive: bool, optional. Defaults to False.
Whether to recurse through directories.
verbose: bool, optional. Defaults to False.
Whether to print the files found.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>List</code></strong> :&ensp;<code>A</code> <code>list</code> of <code>filenames</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_all_files_in_dir(
        in_dir, ext=None, return_absolute=True, 
        recursive=False, verbose=False, re_filter=None):
    &#34;&#34;&#34;
    Get all files in the directory with the given extension.
    
    Parameters
    ----------
    in_dir : str
        The absolute path to the directory
    ext : str, optional. Defaults to True.
        The extension of files to get.
    return_absolute : bool, optional. Defaults to True.
        Whether to return the absolute filename or not.
    recursive: bool, optional. Defaults to False.
        Whether to recurse through directories.
    verbose: bool, optional. Defaults to False.
        Whether to print the files found.

    Returns
    -------
    List : A list of filenames
    &#34;&#34;&#34;
    if not isdir(in_dir):
        print(&#34;Non existant directory &#34; + str(in_dir))
        return []

    def match_filter(f):
        if re_filter is None:
            return True
        search_res = re.search(re_filter, f)
        return search_res is not None

    def ok_file(root_dir, f):
        return has_ext(f, ext) and isfile(join(root_dir, f)) and match_filter(f)

    def convert_to_path(root_dir, f): 
        return join(root_dir, f) if return_absolute else f

    if verbose:
        print(&#34;Adding following files from {}&#34;.format(in_dir))

    if recursive:
        onlyfiles = []
        for root, _, filenames in os.walk(in_dir):
            start_root = root[:len(in_dir)]

            if len(root) == len(start_root):
                end_root = &#34;&#34;
            else:
                end_root = root[len(in_dir + os.sep):]
            for filename in filenames:
                filename = join(end_root, filename)
                if ok_file(start_root, filename):
                    to_add = convert_to_path(start_root, filename)
                    if verbose:
                        print(to_add)
                    onlyfiles.append(to_add)

    else:
        onlyfiles = [
            convert_to_path(in_dir, f) for f in sorted(listdir(in_dir))
            if ok_file(in_dir, f)
        ]
        if verbose:
            for f in onlyfiles:
                print(f)

    if verbose:
        print()
    return onlyfiles</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.get_axona_colours"><code class="name flex">
<span>def <span class="ident">get_axona_colours</span></span>(<span>index=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Axona cell colours.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional integer to get colours at</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> :</dt>
<dd>A list of colours as rgb tuples with values in 0 to 1</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@static_vars(colorcells=[])
def get_axona_colours(index=None):
    &#34;&#34;&#34;
    Create Axona cell colours.
    
    Parameters
    ----------
    index : int
        Optional integer to get colours at
    Returns
    -------
    list :
        A list of colours as rgb tuples with values in 0 to 1
    &#34;&#34;&#34;

    if len(get_axona_colours.colorcells) == 0:
    # crget_axona_colours.eate Axona cell colours if don&#39;t exist
        get_axona_colours.colorcells.append((0,0,200/255))
        get_axona_colours.colorcells.append((80/255,1,80/255))
        get_axona_colours.colorcells.append((1,0,0))
        get_axona_colours.colorcells.append((245/255,0,1))
        get_axona_colours.colorcells.append((75/255,200/255,255/255))
        get_axona_colours.colorcells.append((0/255, 185/255,0/255))
        get_axona_colours.colorcells.append((255/255, 185/255,50/255))
        get_axona_colours.colorcells.append((0/255, 150/255,175/255))
        get_axona_colours.colorcells.append((150/255, 0/255,175/255))
        get_axona_colours.colorcells.append((170/255, 170/255,0/255))
        get_axona_colours.colorcells.append((200/255, 0/255,0/255))
        get_axona_colours.colorcells.append((255/255, 255/255,0/255))
        get_axona_colours.colorcells.append((140/255, 140/255,140/255))
        get_axona_colours.colorcells.append((0/255, 255/255,255/255))
        get_axona_colours.colorcells.append((255/255, 0/255,160/255))
        get_axona_colours.colorcells.append((175/255, 75/255, 75/255))
        get_axona_colours.colorcells.append((255/255, 155/255, 175/255))
        get_axona_colours.colorcells.append((190/255, 190/255, 190/255))
        get_axona_colours.colorcells.append((255/255, 255/255, 75/255))
        get_axona_colours.colorcells.append((154/255, 205/255, 50/255))
        get_axona_colours.colorcells.append((255/255, 99/255, 71/255))
        get_axona_colours.colorcells.append((0/255, 255/255, 127/255))
        get_axona_colours.colorcells.append((255/255, 140/255, 0/255))
        get_axona_colours.colorcells.append((32/255, 178/255, 170/255))
        get_axona_colours.colorcells.append((255/255, 69/255, 0/255))
        get_axona_colours.colorcells.append((240/255, 230/255, 140/255))
        get_axona_colours.colorcells.append((100/255, 145/255, 237/255))
        get_axona_colours.colorcells.append((255/255, 218/255, 185/255))
        get_axona_colours.colorcells.append((153/255, 50/255, 204/255))
        get_axona_colours.colorcells.append((250/255, 128/255, 114/255))

    if index is None:
        return get_axona_colours.colorcells
    else:
        if index &gt;= len(get_axona_colours.colorcells):
            logging.error(&#34;Passed colour index out of range&#34;)
            return
        return get_axona_colours.colorcells[index]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.has_ext"><code class="name flex">
<span>def <span class="ident">has_ext</span></span>(<span>filename, ext)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if the filename ends in the extension</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>str</code></dt>
<dd>The extension, may have leading dot (e.g txt == .txt)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code> <code>indicating</code> <code>if</code> <code>the</code> <code>filename</code> <code>has</code> <code>the</code> <code>extension</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def has_ext(filename, ext):
    &#34;&#34;&#34;
    Check if the filename ends in the extension
    
    Parameters
    ----------
    filename : str
        The name of the file
    ext : str
        The extension, may have leading dot (e.g txt == .txt)
    
    Returns
    -------
    bool indicating if the filename has the extension

    &#34;&#34;&#34;
    if ext == None:
        return True
    if ext[0] != &#34;.&#34;:
        ext = &#34;.&#34; + ext
    return filename[-len(ext):].lower() == ext.lower()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.hellinger"><code class="name flex">
<span>def <span class="ident">hellinger</span></span>(<span>X1, X2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates Hellinger distance between two distributions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X1</code></strong>, <strong><code>X2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Distributions under consideration</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>float</code></dt>
<dd>Calculated Hellinger distance</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hellinger(X1, X2):
    &#34;&#34;&#34;
    Calculates Hellinger distance between two distributions.
    
    Parameters
    ----------
    X1, X2 : ndarray 
        Distributions under consideration
    
    Returns
    -------
    d : float
        Calculated Hellinger distance    
    
    &#34;&#34;&#34;    
    
    if X1.shape[1] != X2.shape[1]:
        logging.error(&#39;Hellinger distance cannot be computed, column sizes do not match!&#39;)
    else:
        return np.sqrt(1- bhatt(X1, X2)[0])</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.histogram"><code class="name flex">
<span>def <span class="ident">histogram</span></span>(<span>x, bins)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the histogram count of input array</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array whose histogram needs to be calculated</dd>
<dt><strong><code>bins</code></strong></dt>
<dd>Number of histogram bins</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Histogram count</dd>
<dt><code>ndarray</code></dt>
<dd>Histogram bins(lowers edges)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def histogram(x, bins):    
    &#34;&#34;&#34;
    Calculates the histogram count of input array
    
    Parameters
    ----------
    x : ndarray 
        Array whose histogram needs to be calculated
    bins
        Number of histogram bins
    
    Returns
    -------
    ndarray
        Histogram count
    ndarray
        Histogram bins(lowers edges)
    
    &#34;&#34;&#34;     
    # This function is not a replacement of np.histogram; it is created for convenience
    # of binned-based rate calculations and mimicking matlab histc that includes digitized indices
    if isinstance(bins, int):
        bins = np.arange(np.min(x), np.max(x), (np.max(x)- np.min(x))/bins)
    bins = np.append(bins, bins[-1]+ np.mean(np.diff(bins)))
    return np.histogram(x, bins)[0], np.digitize(x, bins)-1, bins[:- 1]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.histogram2d"><code class="name flex">
<span>def <span class="ident">histogram2d</span></span>(<span>y, x, ybins, xbins)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the joint histogram count of two arrays</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong>, <strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Arrays whose histogram needs to be calculated</dd>
<dt><strong><code>ybins</code></strong></dt>
<dd>Number of histogram bins in y-axis</dd>
<dt><strong><code>xbins</code></strong></dt>
<dd>Number of histogram bins in x-axis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Histogram count</dd>
<dt><code>ndarray</code></dt>
<dd>Histogram bins in x-axis (lowers edges)</dd>
<dt><code>ndarray</code></dt>
<dd>Histogram bins in y-axis (lowers edges)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def histogram2d(y, x, ybins, xbins):
    &#34;&#34;&#34;
    Calculates the joint histogram count of two arrays
    
    Parameters
    ----------
    y, x : ndarray
        Arrays whose histogram needs to be calculated
    ybins
        Number of histogram bins in y-axis
    xbins
        Number of histogram bins in x-axis
    
    Returns
    -------
    ndarray
        Histogram count
    ndarray
        Histogram bins in x-axis (lowers edges)
    ndarray
        Histogram bins in y-axis (lowers edges)
    
    &#34;&#34;&#34;
    
    # This function is not a repalcement of np.histogram
    if isinstance(xbins, int):
        xbins = np.arange(np.min(x), np.max(x), (np.max(x)- np.min(x))/xbins)
    xbins = np.append(xbins, xbins[-1]+ np.mean(np.diff(xbins)))
    if isinstance(ybins, int):
        ybins = np.arange(np.min(y), np.max(y), (np.max(y)- np.min(y))/ybins)
    ybins = np.append(ybins, ybins[-1]+ np.mean(np.diff(ybins)))

    return np.histogram2d(y, x, [ybins, xbins])[0], ybins[:-1], xbins[:-1]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.linfit"><code class="name flex">
<span>def <span class="ident">linfit</span></span>(<span>X, Y, getPartial=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the linear regression coefficients in least-square sense.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>X</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix with input variables or factors (num_dim X num_obs)</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of oservation data</dd>
<dt><strong><code>getPartial</code></strong> :&ensp;<code>bool</code></dt>
<dd>Get the partial correlation coefficients if 'True'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_results</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with results of least-square optimization of linear regression</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def linfit(X, Y, getPartial=False):
    &#34;&#34;&#34;
    Calculates the linear regression coefficients in least-square sense.
    
    Parameters
    ----------
    X : ndarray
        Matrix with input variables or factors (num_dim X num_obs)
    Y : ndarray
        Array of oservation data
    getPartial : bool
        Get the partial correlation coefficients if &#39;True&#39;
    
    Returns
    -------
    _results : dict
        Dictionary with results of least-square optimization of linear regression
        
    &#34;&#34;&#34;    
    
    _results = oDict()
    if len(X.shape) == 2:
        Nd, Nobs = X.shape
    else:
        Nobs = X.shape[0]
        Nd = 1
    if Nobs == len(Y):
        A = np.vstack([X, np.ones(X.shape[0])]).T
        B = np.linalg.lstsq(A, Y, rcond=-1)[0]
        Y_fit = np.matmul(A, B)
        _results[&#39;coeff&#39;] = B[:-1]
        _results[&#39;intercept&#39;] = B[-1]
        _results[&#39;yfit&#39;] = Y_fit
        _results.update(residual_stat(Y, Y_fit, 1))
    else:
        logging.error(&#39;linfit: Number of rows in X and Y does not match!&#39;)

    if Nd &gt; 1 and getPartial:
        semiCorr = np.zeros(Nd) # Semi partial correlation
        for d in np.arange(Nd):
            part_results = linfit(np.delete(X, 1, axis=0), Y, getPartial=False)
            semiCorr[d] = _results[&#39;Rsq&#39;]- part_results[&#39;Rsq&#39;]
        _results[&#39;semiCorr&#39;] = semiCorr

    return _results</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.log_exception"><code class="name flex">
<span>def <span class="ident">log_exception</span></span>(<span>ex, more_info='')</span>
</code></dt>
<dd>
<section class="desc"><p>Log an expection and additional info</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ex</code></strong> :&ensp;<code>Exception</code></dt>
<dd>The python exception that occured</dd>
<dt><strong><code>more_info</code></strong></dt>
<dd>Additional string to log</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def log_exception(ex, more_info=&#34;&#34;):
    &#34;&#34;&#34;
    Log an expection and additional info

    Parameters
    ----------
    ex : Exception
        The python exception that occured
    more_info : 
        Additional string to log
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;

    template = &#34;{0} because exception of type {1} occurred. Arguments:\n{2!r}&#34;
    message = template.format(more_info, type(ex).__name__, ex.args)
    logging.error(message)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.make_dir_if_not_exists"><code class="name flex">
<span>def <span class="ident">make_dir_if_not_exists</span></span>(<span>location)</span>
</code></dt>
<dd>
<section class="desc"><p>Makes directory structure for given location</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_dir_if_not_exists(location):
    &#34;&#34;&#34;Makes directory structure for given location&#34;&#34;&#34;
    os.makedirs(os.path.dirname(location), exist_ok=True)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.nxl_write"><code class="name flex">
<span>def <span class="ident">nxl_write</span></span>(<span>file_name, data_frame, sheet_name='Sheet1', startRow=0, startColumn=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Write Pandas DataFrame to excel file. It is a wrapper for Pandas.ExcelWriter()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the output file</dd>
<dt><strong><code>data_frame</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>DataFrame to export</dd>
<dt><strong><code>sheet_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Sheet name of the Excel file where the data is written</dd>
<dt><strong><code>startRow</code></strong> :&ensp;<code>int</code></dt>
<dd>Which row in the file the data writing should start</dd>
<dt><strong><code>startColumn</code></strong> :&ensp;<code>int</code></dt>
<dd>Which column in the file the data writing should start</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def nxl_write(
    file_name, data_frame, sheet_name=&#39;Sheet1&#39;, startRow=0, startColumn=0):
    &#34;&#34;&#34;
    Write Pandas DataFrame to excel file. It is a wrapper for Pandas.ExcelWriter()
    
    Parameters
    ----------
    filename : str
        Name of the output file
    data_frame : pandas.DataFrame
        DataFrame to export
    sheet_name : str
        Sheet name of the Excel file where the data is written
    startRow : int
        Which row in the file the data writing should start
    startColumn : int
        Which column in the file the data writing should start        
    
    Returns
    -------
    None    
    
    &#34;&#34;&#34;
    # Create a Pandas Excel writer using XlsxWriter as the engine.
    writer = pd.ExcelWriter(file_name, engine=&#39;xlsxwriter&#39;)
    # Convert the dataframe to an XlsxWriter Excel object.
    data_frame.to_excel(writer, sheet_name)
    # Close the Pandas Excel writer and output the Excel file.
    writer.save()</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.remove_extension"><code class="name flex">
<span>def <span class="ident">remove_extension</span></span>(<span>filename, keep_dot=True, return_ext=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_extension(filename, keep_dot=True, return_ext=False):
    modifier = 0 if keep_dot else 1
    ext = filename.split(&#34;.&#34;)[-1]
    remove = len(ext) + modifier
    if return_ext:
        return filename[:-remove], ext
    else:
        return filename[:-remove]</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.residual_stat"><code class="name flex">
<span>def <span class="ident">residual_stat</span></span>(<span>y, y_fit, p)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the goodness of fit and other residual statistics between observed
and fitted values from a model</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Observed data</dd>
<dt><strong><code>y_fit</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Fitted data to a linear model</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>int</code></dt>
<dd>Model order</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>_results</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of residual statistics</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def residual_stat(y, y_fit, p):
    &#34;&#34;&#34;
    Calculates the goodness of fit and other residual statistics between observed
    and fitted values from a model
    
    Parameters
    ----------
    y : ndarray
        Observed data
    y_fit : ndarray
        Fitted data to a linear model
    p : int
        Model order
    
    Returns
    -------
    _results : dict
        Dictionary of residual statistics
    
    &#34;&#34;&#34;
    
   # p= total explanatory variables excluding constants
    _results = oDict()
    res = y- y_fit
    ss_res = np.sum(res**2)
    ss_tot = np.sum((y- np.mean(y))**2)
    r_sq = 1- ss_res/ss_tot
    adj_r_sq = 1- (ss_res/ ss_tot)* ((len(y)-1)/(len(y)- p-1))
    _results[&#39;Pearson R&#39;], _results[&#39;Pearson P&#39;] = stats.pearsonr(y, y_fit)

    _results[&#39;Rsq&#39;] = r_sq
    _results[&#39;adj Rsq&#39;] = adj_r_sq

    return _results</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.rot_2d"><code class="name flex">
<span>def <span class="ident">rot_2d</span></span>(<span>x, theta)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotates a firing map by a specified angle</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix of firing rate map</dd>
<dt><strong><code>theta</code></strong></dt>
<dd>Angle of rotation in theta</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Rotated matrix</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rot_2d(x, theta):
    &#34;&#34;&#34;
    Rotates a firing map by a specified angle
    
    Parameters
    ----------
    x : ndarray
        Matrix of firing rate map
    theta
        Angle of rotation in theta
        
    Returns
    -------
    ndarray
        Rotated matrix
    
    &#34;&#34;&#34;
    
    return scipy.ndimage.interpolation.rotate(x, theta, reshape=False, mode=&#39;constant&#39;, cval=np.min(x))</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.smooth_1d"><code class="name flex">
<span>def <span class="ident">smooth_1d</span></span>(<span>x, filttype='b', filtsize=5, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Filters a 1D array or signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array or signal to be filtered. If matrix, each column or row is filtered
individually depending on 'dir' parameter that takes either '0' for along-column
and '1' for along-row filtering.</dd>
<dt><strong><code>filttype</code></strong> :&ensp;<code>str</code></dt>
<dd>'b' for moving average or box filter. 'g' for Gaussian filter</dd>
<dt><strong><code>filtsize</code></strong></dt>
<dd>Box size for box filter and sigma for Gaussian filter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Filtered data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def smooth_1d(x, filttype=&#39;b&#39;, filtsize=5, **kwargs):
    &#34;&#34;&#34;
    Filters a 1D array or signal.
    
    Parameters
    ----------
    x : ndarray
        Array or signal to be filtered. If matrix, each column or row is filtered
        individually depending on &#39;dir&#39; parameter that takes either &#39;0&#39; for along-column
        and &#39;1&#39; for along-row filtering.
    filttype : str
        &#39;b&#39; for moving average or box filter. &#39;g&#39; for Gaussian filter
    filtsize
        Box size for box filter and sigma for Gaussian filter
        
    Returns
    -------
    ndarray
        Filtered data
    
    &#34;&#34;&#34;
    
    x = np.array(x)
    direction = kwargs.get(&#39;dir&#39;, 0) # default along column
    if filttype == &#39;g&#39;:
        halfwid = np.round(3*filtsize)
        xx = np.arange(-halfwid, halfwid+1, 1)
        filt = np.exp(-(xx**2)/(2*filtsize**2))/(np.sqrt(2*np.pi)*filtsize)
    elif filttype == &#39;b&#39;:
        filt = np.ones(filtsize, )/filtsize

    if len(x.shape) == 1:
        result = np.convolve(x, filt, mode=&#39;same&#39;)
    elif len([x.shape]) == 2:
        result = np.zeros(x.shape)
        if direction:
            for i in np.arange(0, x.shape[0]):
                result[i, :] = np.convolve(x[i, :], filt, mode=&#39;same&#39;)
        else:
            for i in np.arange(0, x.shape[0]):
                result[:, i] = np.convolve(x[:, i], filt, mode=&#39;same&#39;)
    return result</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.smooth_2d"><code class="name flex">
<span>def <span class="ident">smooth_2d</span></span>(<span>x, filttype='b', filtsize=5)</span>
</code></dt>
<dd>
<section class="desc"><p>Filters a 2D array or signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix to be filtered</dd>
<dt><strong><code>filttype</code></strong> :&ensp;<code>str</code></dt>
<dd>'b' for moving average or box filter. 'g' for Gaussian filter</dd>
<dt><strong><code>filtsize</code></strong></dt>
<dd>Box size for box filter and sigma for Gaussian filter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>smoothX</code></dt>
<dd>Filtered matrix</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def smooth_2d(x, filttype=&#39;b&#39;, filtsize=5):
    &#34;&#34;&#34;
    Filters a 2D array or signal.
    
    Parameters
    ----------
    x : ndarray
        Matrix to be filtered
    filttype : str
        &#39;b&#39; for moving average or box filter. &#39;g&#39; for Gaussian filter
    filtsize
        Box size for box filter and sigma for Gaussian filter
        
    Returns
    -------
    smoothX
        Filtered matrix
    
    &#34;&#34;&#34;
    
    nanInd = np.isnan(x)
    x[nanInd] = 0
    if filttype == &#39;g&#39;:
        halfwid = np.round(3*filtsize)
        xx, yy = np.meshgrid(np.arange(-halfwid, halfwid+1, 1), np.arange(-halfwid, halfwid+1, 1), copy=False)
        filt = np.exp(-(xx**2+ yy**2)/(2*filtsize**2)) # /(2*np.pi*filtsize**2) # This is the scaling used before;
                                                        #But tested with ones(50, 50); gives a hogher value
        filt = filt/ np.sum(filt)
    elif filttype == &#39;b&#39;:
        filt = np.ones((filtsize, filtsize))/filtsize**2

    smoothX = sg.convolve2d(x, filt, mode=&#39;same&#39;)
    smoothX[nanInd] = np.nan

    return smoothX</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.static_vars"><code class="name flex">
<span>def <span class="ident">static_vars</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def static_vars(**kwargs):
    def decorate(func):
        for k in kwargs:
            setattr(func, k, kwargs[k])
        return func
    return decorate</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.window_rms"><code class="name flex">
<span>def <span class="ident">window_rms</span></span>(<span>a, window_size, mode='same')</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the rms envelope, similar to matlab.
</p>
<p>mode determines how many points are output
mode valid will have no border effects
mode same will produce a value for each input</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def window_rms(a, window_size, mode=&#34;same&#34;):
    &#34;&#34;&#34;
    Calculate the rms envelope, similar to matlab.  
    
    mode determines how many points are output
    mode valid will have no border effects
    mode same will produce a value for each input
    &#34;&#34;&#34;
    a2 = np.power(a,2)
    window = np.ones(window_size)/float(window_size)
    return np.sqrt(np.convolve(a2, window, mode))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="neurochat.nc_utils.NLog"><code class="flex name class">
<span>class <span class="ident">NLog</span></span>
</code></dt>
<dd>
<section class="desc"><p>Class for handling log information (messages, errors and warnings) for NeuroChaT.
It formats the incoming message in HTML and sends it to the log interface of NeuroChaT.</p>
<p>Initializes the instance - basically setting the formatter to None
and the filter list to empty.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NLog(logging.Handler):
    &#34;&#34;&#34;
    Class for handling log information (messages, errors and warnings) for NeuroChaT.
    It formats the incoming message in HTML and sends it to the log interface of NeuroChaT.
    
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self.setup()
    def setup(self):
        &#34;&#34;&#34;
        Removes all the logging handlers and sets up a new logger with HTML formatting.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        log = logging.getLogger()
        for hdlr in log.handlers[:]:  # remove all old handlers
            log.removeHandler(hdlr)
        fmt = logging.Formatter(&#39;%(asctime)s (%(filename)s)  %(levelname)s--  %(message)s&#39;, &#39;%H:%M:%S&#39;)
        self.setFormatter(fmt)
        log.addHandler(self)
        # You can control the logging level
        log.setLevel(logging.DEBUG)
        logging.addLevelName(20, &#39;&#39;)
        
    def emit(self, record):
        &#34;&#34;&#34;
        Formats the incoming record and 
        
        Parameters
        ----------
        record
            Log record to dispkay or store
        
        Returns
        -------
        None
        
        &#34;&#34;&#34;
        
        msg = self.format(record)
        level = record.levelname
        msg = level+ &#39;:&#39;+ msg
        print(msg)
        time.sleep(0.25)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Handler</li>
<li>logging.Filterer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="neurochat.nc_utils.NLog.emit"><code class="name flex">
<span>def <span class="ident">emit</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Formats the incoming record and </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong></dt>
<dd>Log record to dispkay or store</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def emit(self, record):
    &#34;&#34;&#34;
    Formats the incoming record and 
    
    Parameters
    ----------
    record
        Log record to dispkay or store
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;
    
    msg = self.format(record)
    level = record.levelname
    msg = level+ &#39;:&#39;+ msg
    print(msg)
    time.sleep(0.25)</code></pre>
</details>
</dd>
<dt id="neurochat.nc_utils.NLog.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes all the logging handlers and sets up a new logger with HTML formatting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def setup(self):
    &#34;&#34;&#34;
    Removes all the logging handlers and sets up a new logger with HTML formatting.
    
    Parameters
    ----------
    None
    
    Returns
    -------
    None
    
    &#34;&#34;&#34;
    
    log = logging.getLogger()
    for hdlr in log.handlers[:]:  # remove all old handlers
        log.removeHandler(hdlr)
    fmt = logging.Formatter(&#39;%(asctime)s (%(filename)s)  %(levelname)s--  %(message)s&#39;, &#39;%H:%M:%S&#39;)
    self.setFormatter(fmt)
    log.addHandler(self)
    # You can control the logging level
    log.setLevel(logging.DEBUG)
    logging.addLevelName(20, &#39;&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="neurochat.nc_utils.Singleton"><code class="flex name class">
<span>class <span class="ident">Singleton</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a Singleton object created from a subclass of this class</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Singleton(object):
    &#34;&#34;&#34;
    Creates a Singleton object created from a subclass of this class
    
    &#34;&#34;&#34;
    
    def __new__(cls, *arg, **kwarg):
        if not hasattr(cls, &#39;_instance&#39;):
            cls._instance = super().__new__(cls, *arg, **kwarg)
        return cls._instance</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neurochat" href="index.html">neurochat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="neurochat.nc_utils.angle_between_points" href="#neurochat.nc_utils.angle_between_points">angle_between_points</a></code></li>
<li><code><a title="neurochat.nc_utils.bhatt" href="#neurochat.nc_utils.bhatt">bhatt</a></code></li>
<li><code><a title="neurochat.nc_utils.butter_filter" href="#neurochat.nc_utils.butter_filter">butter_filter</a></code></li>
<li><code><a title="neurochat.nc_utils.centre_of_mass" href="#neurochat.nc_utils.centre_of_mass">centre_of_mass</a></code></li>
<li><code><a title="neurochat.nc_utils.chop_edges" href="#neurochat.nc_utils.chop_edges">chop_edges</a></code></li>
<li><code><a title="neurochat.nc_utils.corr_coeff" href="#neurochat.nc_utils.corr_coeff">corr_coeff</a></code></li>
<li><code><a title="neurochat.nc_utils.distinct_window_rms" href="#neurochat.nc_utils.distinct_window_rms">distinct_window_rms</a></code></li>
<li><code><a title="neurochat.nc_utils.extrema" href="#neurochat.nc_utils.extrema">extrema</a></code></li>
<li><code><a title="neurochat.nc_utils.fft_psd" href="#neurochat.nc_utils.fft_psd">fft_psd</a></code></li>
<li><code><a title="neurochat.nc_utils.find" href="#neurochat.nc_utils.find">find</a></code></li>
<li><code><a title="neurochat.nc_utils.find2d" href="#neurochat.nc_utils.find2d">find2d</a></code></li>
<li><code><a title="neurochat.nc_utils.find_chunk" href="#neurochat.nc_utils.find_chunk">find_chunk</a></code></li>
<li><code><a title="neurochat.nc_utils.find_peaks" href="#neurochat.nc_utils.find_peaks">find_peaks</a></code></li>
<li><code><a title="neurochat.nc_utils.find_true_ranges" href="#neurochat.nc_utils.find_true_ranges">find_true_ranges</a></code></li>
<li><code><a title="neurochat.nc_utils.get_all_files_in_dir" href="#neurochat.nc_utils.get_all_files_in_dir">get_all_files_in_dir</a></code></li>
<li><code><a title="neurochat.nc_utils.get_axona_colours" href="#neurochat.nc_utils.get_axona_colours">get_axona_colours</a></code></li>
<li><code><a title="neurochat.nc_utils.has_ext" href="#neurochat.nc_utils.has_ext">has_ext</a></code></li>
<li><code><a title="neurochat.nc_utils.hellinger" href="#neurochat.nc_utils.hellinger">hellinger</a></code></li>
<li><code><a title="neurochat.nc_utils.histogram" href="#neurochat.nc_utils.histogram">histogram</a></code></li>
<li><code><a title="neurochat.nc_utils.histogram2d" href="#neurochat.nc_utils.histogram2d">histogram2d</a></code></li>
<li><code><a title="neurochat.nc_utils.linfit" href="#neurochat.nc_utils.linfit">linfit</a></code></li>
<li><code><a title="neurochat.nc_utils.log_exception" href="#neurochat.nc_utils.log_exception">log_exception</a></code></li>
<li><code><a title="neurochat.nc_utils.make_dir_if_not_exists" href="#neurochat.nc_utils.make_dir_if_not_exists">make_dir_if_not_exists</a></code></li>
<li><code><a title="neurochat.nc_utils.nxl_write" href="#neurochat.nc_utils.nxl_write">nxl_write</a></code></li>
<li><code><a title="neurochat.nc_utils.remove_extension" href="#neurochat.nc_utils.remove_extension">remove_extension</a></code></li>
<li><code><a title="neurochat.nc_utils.residual_stat" href="#neurochat.nc_utils.residual_stat">residual_stat</a></code></li>
<li><code><a title="neurochat.nc_utils.rot_2d" href="#neurochat.nc_utils.rot_2d">rot_2d</a></code></li>
<li><code><a title="neurochat.nc_utils.smooth_1d" href="#neurochat.nc_utils.smooth_1d">smooth_1d</a></code></li>
<li><code><a title="neurochat.nc_utils.smooth_2d" href="#neurochat.nc_utils.smooth_2d">smooth_2d</a></code></li>
<li><code><a title="neurochat.nc_utils.static_vars" href="#neurochat.nc_utils.static_vars">static_vars</a></code></li>
<li><code><a title="neurochat.nc_utils.window_rms" href="#neurochat.nc_utils.window_rms">window_rms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="neurochat.nc_utils.NLog" href="#neurochat.nc_utils.NLog">NLog</a></code></h4>
<ul class="">
<li><code><a title="neurochat.nc_utils.NLog.emit" href="#neurochat.nc_utils.NLog.emit">emit</a></code></li>
<li><code><a title="neurochat.nc_utils.NLog.setup" href="#neurochat.nc_utils.NLog.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="neurochat.nc_utils.Singleton" href="#neurochat.nc_utils.Singleton">Singleton</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>